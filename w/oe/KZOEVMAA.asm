; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEVMAA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG14094 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG14341 DB	'DropView %s: 0x%08x   LOD: %s', 00H
	ORG $+2
$SG14403 DB	'SfSetApplicationTask for App: %s   Task: 0x%08x', 00H
$SG13412 DB	'CreateView %s: 0x%08x   LOD: %s', 00H
$SG14455 DB	'APPLICATION', 00H
$SG14456 DB	'SYSTEM', 00H
	ORG $+1
$SG14457 DB	'SCOPE UNKNOWN', 00H
	ORG $+2
$SG13448 DB	'SfCreateSysViewFromView: 0x%08x', 00H
$SG14608 DB	'.Subtask.', 00H
	ORG $+2
$SG14458 DB	'SfTransferView trying to transfer view (0x%08x %s) from '
	DB	'Task: 0x%08x to Task: 0x%08x at Scope: %s', 00H
	ORG $+2
$SG14473 DB	'BombZDr', 00H
$SG14474 DB	'[Debug]', 00H
$SG14476 DB	'Recursive view', 00H
	ORG $+1
$SG14477 DB	'Houston ... we have a problem', 00H
	ORG $+2
$SG14610 DB	'View about to be dropped (0x%08x).  Object Name = %s', 00H
	ORG $+3
$SG14611 DB	'(vm) ', 00H
	ORG $+2
$SG14613 DB	'Core Warning', 00H
	ORG $+3
$SG14619 DB	'MainOI Invalid', 00H
	ORG $+1
$SG14620 DB	'fnDropView Error', 00H
	ORG $+3
$SG14624 DB	'Unexpected Invalid MainOI', 00H
	ORG $+2
$SG14625 DB	'fnDropView Error', 00H
	ORG $+3
$SG14682 DB	'(vm) Name cleanup error', 00H
$SG14683 DB	'Error', 00H
	ORG $+2
$SG13713 DB	'DropNameForView sending in view for TRANSIENT task: %d ('
	DB	'0x%08x)  should be for task: %d (0x%08x) ... WILL NOT RESET T'
	DB	'ASK VIEW', 00H
	ORG $+2
$SG13715 DB	'DropNameForView sending in view for task: %d (0x%08x)  s'
	DB	'hould be for task: %d (0x%08x) ... RESETTING TASK VIEW', 00H
	ORG $+1
$SG13718 DB	'DropNameForView Invalid scope for View name: ', 00H
	ORG $+2
$SG13721 DB	'DropNameForView Length Error: ', 00H
	ORG $+1
$SG13723 DB	'DropNameForView Invalid Subtask view for Name: ', 00H
$SG14891 DB	'Root cursors don''t match.  Contact QuinSoft', 00H
$SG14892 DB	'QuinSoft Internal Message', 00H
	ORG $+2
$SG13947 DB	'SetNameForView sending in view for TRANSIENT task: %d (0'
	DB	'x%08x)  should be for task: %d (0x%08x) ... WILL NOT RESET TA'
	DB	'SK VIEW', 00H
	ORG $+3
$SG13949 DB	'SetNameForView sending in view for task: %d (0x%08x)  sh'
	DB	'ould be for task: %d (0x%08x) ... RESETTING TASK VIEW', 00H
	ORG $+2
$SG13953 DB	'(vm) Invalid subtask -- name = ', 00H
$SG13959 DB	'(vm) Naming non-application level view at the applicatio'
	DB	'n level: ', 00H
	ORG $+2
$SG13961 DB	'(vm) Invalid view -- name = ', 00H
	ORG $+3
$SG13965 DB	'(vm) Invalid scoping level -- name = ', 00H
	ORG $+2
$SG14077 DB	'GetViewByName now requires a valid view', 00H
$SG14078 DB	'OE Error', 00H
	ORG $+3
$SG14083 DB	'GetViewByName sending in view for TRANSIENT task: %d (0x'
	DB	'%08x)  should be for task: %d (0x%08x) ... WILL NOT RESET TAS'
	DB	'K VIEW', 00H
$SG14088 DB	'GetViewByName Invalid scope for View name: ', 00H
$SG14085 DB	'GetViewByName sending in view for task: %d (0x%08x)  sho'
	DB	'uld be for task: %d (0x%08x) ... RESETTING TASK VIEW', 00H
	ORG $+3
$SG14093 DB	'GetViewByName Length Error: ', 00H
	ORG $+3
$SG14095 DB	'GetViewByName - Empty name', 00H
	ORG $+1
$SG14097 DB	'GetViewByName Invalid Subtask view for Name: ', 00H
	ORG $+2
$SG14099 DB	'GetViewByName Invalid view for Name: ', 00H
	ORG $+2
$SG14105 DB	'GetViewByName Invalid Subtask (null) for Name: ', 00H
$SG14107 DB	'GetViewByName Invalid Subtask view for Name: ', 00H
	ORG $+2
$SG14125 DB	'Zeidon DBHandler Work Object', 00H
	ORG $+3
$SG14126 DB	'Zeidon DBHandler Work Object', 00H
	ORG $+3
$SG14127 DB	'Zeidon DBHandler Work Object', 00H
	ORG $+3
$SG14128 DB	'NOT FOUND', 00H
	ORG $+2
$SG14129 DB	'SUBTASK', 00H
$SG14130 DB	'TASK', 00H
	ORG $+3
$SG14131 DB	'APPLICATION', 00H
$SG14132 DB	'SYSTEM', 00H
	ORG $+1
$SG14133 DB	'UNKNOWN', 00H
$SG14134 DB	'ANY', 00H
$SG14135 DB	'SUBTASK', 00H
$SG14136 DB	'TASK', 00H
	ORG $+3
$SG14137 DB	'APPLICATION', 00H
$SG14138 DB	'SYSTEM', 00H
	ORG $+1
$SG14139 DB	'UNKNOWN', 00H
	ORG $+4
$SG14140 DB	'GetViewByName TRANSIENT ERROR (0x%08x/0x%08x)  %s   View'
	DB	'/Task: 0x%08x/0x%08x   Level: %s   RC ===> %s', 00H
_DATA	ENDS
PUBLIC	_SetViewReadOnly@4
PUBLIC	_SetViewFlags@8
PUBLIC	_GetViewFlags@4
PUBLIC	_SetViewUpdate@4
PUBLIC	_CreateViewFromView@8
PUBLIC	_CreateViewFromViewForTask@12
PUBLIC	_CreateViewTrace@16
PUBLIC	_SfCreateSysViewFromView@8
PUBLIC	_SetViewFromView@8
PUBLIC	_SetDefaultViewForActiveTask@8
PUBLIC	_GetDefaultViewForActiveTask@0
PUBLIC	_GetViewByName@16
PUBLIC	_SetNameForView@16
PUBLIC	_DropNameForView@16
PUBLIC	_GetNameForView@16
PUBLIC	_DropView@4
PUBLIC	_DropViewTrace@8
PUBLIC	_SetViewToSubobject@8
PUBLIC	_ResetViewFromSubobject@4
PUBLIC	_ResetViewFromSubobjectTop@4
PUBLIC	_ResetViewFromSubobjectWithoutError@4
PUBLIC	_ResetView@4
PUBLIC	_ResetViewPositions@4
PUBLIC	_SfSetSubtaskView@8
PUBLIC	_SfGetFirstSubtaskView@8
PUBLIC	_SfGetNextSubtaskView@8
PUBLIC	_SfSetApplicationTask@8
PUBLIC	_SfGetUserIdForTask@8
PUBLIC	_SfSetUserIdForTask@8
PUBLIC	_SfTransferView@12
PUBLIC	_SfLockView@4
PUBLIC	_SfGetFirstNamedView@16
PUBLIC	_SfGetNextNamedView@16
PUBLIC	_fnDeclareView@20
PUBLIC	_fnSetViewFromView
PUBLIC	_fnDropView@4
PUBLIC	_fnSetViewToSubobject
PUBLIC	_fnResetView
PUBLIC	_fnResetViewFromSubobject
PUBLIC	_fnDropAllViewSubobjects
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_fnCreateEntityCsrHandle@12
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strncat:PROC
EXTRN	__imp__atol:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_SysDiagnosticMessage@16:PROC
EXTRN	_SysGetProcessID@4:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysReadZeidonIni@16:PROC
EXTRN	_SysSendOE_Message@8:PROC
EXTRN	_ActivateViewObject@12:PROC
EXTRN	_fnSysLockCoreMutex@4:PROC
EXTRN	_fnSysUnlockCoreMutex@4:PROC
EXTRN	_fnSelectedInstanceFarbler:PROC
EXTRN	_fnNullCursorForViewChildren:PROC
EXTRN	_fnResetCursorForViewChildren:PROC
EXTRN	_fnEstablishCursorForView:PROC
EXTRN	_fnAllocDataspace:PROC
EXTRN	_fnFreeDataspace:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnDeleteViewObject@4:PROC
EXTRN	_fnInvokeOCEOperation:PROC
EXTRN	_fnGetApplicationForSubtask@8:PROC
EXTRN	_fnStartBrowseOfTaskList@8:PROC
EXTRN	_fnEndBrowseOfTaskList@4:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	_fnValidView:PROC
EXTRN	_fnValidSubtaskView:PROC
EXTRN	_fnValidViewEntity@16:PROC
EXTRN	_fnDropViewCsr:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_fnCheckIfViewOD_IsUsed@8:PROC
EXTRN	_fnEntityNameFromCsr@4:PROC
EXTRN	_fnEntityNameFromInstance@4:PROC
EXTRN	_fnCallListeners:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_g_nOE_TraceWarning:WORD
EXTRN	_g_vRealTaskView:DWORD
EXTRN	_g_vDefaultTaskView:DWORD
EXTRN	_g_lProcessID:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_hndl$ = -4						; size = 4
_lpViewEntityCsr$ = 8					; size = 4
_lpViewCsr$ = 12					; size = 4
_nIndex$ = 16						; size = 2
_fnCreateEntityCsrHandle@12 PROC

; 89   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 90   :    zLONG hndl;
; 91   : 
; 92   :    // If lpViewEntityCsr is 0 then the resulting handle is 0 too.
; 93   :    if ( lpViewEntityCsr == 0 )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	jne	SHORT $LN2@fnCreateEn

; 94   :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnCreateEn
$LN2@fnCreateEn:

; 95   : 
; 96   :    // Get the handle for the ViewCsr pointer.
; 97   :    hndl = (zLONG) zGETHNDL( lpViewCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hndl$[ebp], eax

; 98   : 
; 99   :    // Set lpViewEntityCsr to a prev/next Csr (if nIndex is 0 nothing happens).
; 100  :    lpViewEntityCsr = lpViewEntityCsr + nIndex;

	movsx	ecx, WORD PTR _nIndex$[ebp]
	imul	edx, ecx, 30
	add	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], edx

; 101  : 
; 102  :    // The new handle is created by adding the difference between the 2
; 103  :    // pointers (the offset) to the ViewCsr handle.
; 104  :    hndl = hndl + ((zLONG) lpViewEntityCsr - (zLONG) lpViewCsr);

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	sub	eax, DWORD PTR _lpViewCsr$[ebp]
	add	eax, DWORD PTR _hndl$[ebp]
	mov	DWORD PTR _hndl$[ebp], eax

; 105  : 
; 106  :    return( (LPVIEWENTITYCSR) hndl );

	mov	eax, DWORD PTR _hndl$[ebp]
$LN1@fnCreateEn:

; 107  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnCreateEntityCsrHandle@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpViewSubobject$1 = -8					; size = 4
_lpViewCsr$ = -4					; size = 4
_zView$ = 8						; size = 4
_fnDropAllViewSubobjects PROC

; 4613 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 4614 :    LPVIEWCSR   lpViewCsr;
; 4615 : 
; 4616 :    lpViewCsr = zGETPTR( zView->hViewCsr );

	mov	eax, DWORD PTR _zView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax
$LN2@fnDropAllV:

; 4617 : 
; 4618 :    // Discard all subobject views.
; 4619 :    while ( lpViewCsr->hFirstViewSubobject )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+30], 0
	je	SHORT $LN1@fnDropAllV

; 4620 :    {
; 4621 :       LPVIEWSUBOBJECT   lpViewSubobject;
; 4622 : 
; 4623 :       lpViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$1[ebp], eax

; 4624 :       lpViewCsr->hFirstViewSubobject = lpViewSubobject->hNextViewSubobject;

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR _lpViewSubobject$1[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+30], ecx

; 4625 :       fnFreeDataspace( lpViewSubobject );

	mov	edx, DWORD PTR _lpViewSubobject$1[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 4626 :    }

	jmp	SHORT $LN2@fnDropAllV
$LN1@fnDropAllV:

; 4627 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnDropAllViewSubobjects ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpNextViewSubobject$1 = -64				; size = 4
_lpFirstViewSubobject$2 = -60				; size = 4
_nLevelChg$3 = -56					; size = 4
_lpWorkEntityInstance$4 = -52				; size = 4
_hRecursChildEntityInstance$5 = -48			; size = 4
_lpRecursChildEntityInstance$6 = -44			; size = 4
_lpLastDescCsr$ = -40					; size = 4
_lpNextViewSubobject$7 = -36				; size = 4
_lpSubRootCsr$8 = -32					; size = 4
_lpRecursChildEntityCsr$9 = -28				; size = 4
_lpRootCsr$ = -24					; size = 4
_lpWorkViewSubobject$10 = -20				; size = 4
_lpViewCsr$ = -16					; size = 4
_lpViewSubobject$ = -12					; size = 4
_lpWorkCsr$ = -8					; size = 4
_nLevelChg$ = -4					; size = 2
_lpView$ = 8						; size = 4
_fnResetViewFromSubobject PROC

; 4402 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 4403 :    zSHORT            nLevelChg;
; 4404 :    LPVIEWCSR         lpViewCsr;
; 4405 :    LPVIEWENTITYCSR   lpRootCsr;
; 4406 :    LPVIEWENTITYCSR   lpWorkCsr;
; 4407 :    LPVIEWENTITYCSR   lpLastDescCsr;
; 4408 :    LPVIEWSUBOBJECT   lpViewSubobject;
; 4409 : 
; 4410 :    // Get the ViewCsr for the view.
; 4411 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 4412 :    lpRootCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootCsr$[ebp], eax

; 4413 :    lpViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$[ebp], eax

; 4414 :    if ( lpViewSubobject == 0 )

	cmp	DWORD PTR _lpViewSubobject$[ebp], 0
	jne	SHORT $LN16@fnResetVie

; 4415 :       return( 1 );

	mov	eax, 1
	jmp	$LN1@fnResetVie
$LN16@fnResetVie:

; 4416 : 
; 4417 :    lpLastDescCsr = zGETPTR( lpViewSubobject->hLastDescCsr );

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastDescCsr$[ebp], eax

; 4418 : 
; 4419 :    // Check to see if there is another subobject structure.  If there is then
; 4420 :    // the current cursor structure won't change, just the entity instances.
; 4421 :    if ( lpViewSubobject->hNextViewSubobject == 0 )

	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	cmp	DWORD PTR [edx+2], 0
	jne	$LN17@fnResetVie

; 4422 :    {
; 4423 :       // No other subobject structures so change the cursor structure back to
; 4424 :       // its original form.
; 4425 :       lpRootCsr->hParent = lpViewSubobject->hViewRootParentCsr;

	mov	eax, DWORD PTR _lpRootCsr$[ebp]
	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	mov	DWORD PTR [eax+10], edx

; 4426 :    // if ( lpRootCsr->hParent == (LPVIEWENTITYCSR) 1 )
; 4427 :    //    SysMessageBox( 0, "fnResetViewFromSubobject", "1", -1 );
; 4428 : 
; 4429 :       lpRootCsr->hPrevHier = fnCreateEntityCsrHandle( lpRootCsr, lpViewCsr, -1 );

	push	-1
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpRootCsr$[ebp]
	push	ecx
	call	_fnCreateEntityCsrHandle@12
	mov	edx, DWORD PTR _lpRootCsr$[ebp]
	mov	DWORD PTR [edx+6], eax

; 4430 :       if ( lpViewSubobject->nLastDescHierNbr < lpViewCsr->uEntities )

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	movsx	ecx, WORD PTR [eax+24]
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	movzx	eax, WORD PTR [edx+34]
	cmp	ecx, eax
	jge	SHORT $LN19@fnResetVie

; 4431 :          lpLastDescCsr->hNextHier = fnCreateEntityCsrHandle( lpLastDescCsr, lpViewCsr, 1 );

	push	1
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpLastDescCsr$[ebp]
	push	edx
	call	_fnCreateEntityCsrHandle@12
	mov	ecx, DWORD PTR _lpLastDescCsr$[ebp]
	mov	DWORD PTR [ecx+2], eax
$LN19@fnResetVie:

; 4432 : 
; 4433 :       // Reset RootViewCsr parent.
; 4434 :       lpWorkCsr = lpRootCsr;

	mov	edx, DWORD PTR _lpRootCsr$[ebp]
	mov	DWORD PTR _lpWorkCsr$[ebp], edx
$LN2@fnResetVie:

; 4435 :       while ( lpWorkCsr->hParent )

	mov	eax, DWORD PTR _lpWorkCsr$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN3@fnResetVie

; 4436 :          lpWorkCsr = zGETPTR( lpWorkCsr->hParent );

	mov	ecx, DWORD PTR _lpWorkCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkCsr$[ebp], eax
	jmp	SHORT $LN2@fnResetVie
$LN3@fnResetVie:

; 4437 : 
; 4438 :       lpViewCsr->hRootViewEntityCsr = fnCreateEntityCsrHandle( lpWorkCsr, lpViewCsr, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWorkCsr$[ebp]
	push	ecx
	call	_fnCreateEntityCsrHandle@12
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [edx+18], eax

; 4439 :    }

	jmp	SHORT $LN18@fnResetVie
$LN17@fnResetVie:

; 4440 :    // DGC 2000.1.31
; 4441 :    // Following code just for testing a theory ... can be removed at any time.
; 4442 :    else
; 4443 :    {
; 4444 :       LPVIEWSUBOBJECT lpNextViewSubobject = zGETPTR( lpViewSubobject->hNextViewSubobject );

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextViewSubobject$1[ebp], eax

; 4445 : 
; 4446 :       if ( lpNextViewSubobject->hRootCsr != lpViewSubobject->hRootCsr )

	mov	edx, DWORD PTR _lpNextViewSubobject$1[ebp]
	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+14]
	je	SHORT $LN18@fnResetVie

; 4447 :       {
; 4448 :          // We should never see this message.  The root cursors should always
; 4449 :          // be the same.
; 4450 :          SysDiagnosticMessage( lpView, "QuinSoft Internal Message",

	push	0
	push	OFFSET $SG14891
	push	OFFSET $SG14892
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysDiagnosticMessage@16
$LN18@fnResetVie:

; 4451 :                                "Root cursors don't match.  Contact QuinSoft", 0 );
; 4452 :       }
; 4453 :    }
; 4454 : 
; 4455 :    // Get level change.
; 4456 :    nLevelChg = lpViewSubobject->nLevelChg;

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	cx, WORD PTR [eax+34]
	mov	WORD PTR _nLevelChg$[ebp], cx

; 4457 :    if ( nLevelChg )

	movsx	edx, WORD PTR _nLevelChg$[ebp]
	test	edx, edx
	je	$LN21@fnResetVie

; 4458 :    {
; 4459 :       LPVIEWSUBOBJECT  lpWorkViewSubobject;
; 4460 :       LPVIEWENTITYCSR  lpRecursChildEntityCsr;
; 4461 :       LPENTITYINSTANCE lpRecursChildEntityInstance;
; 4462 :       zPVOID           hRecursChildEntityInstance;
; 4463 : 
; 4464 :       lpWorkCsr = lpRootCsr;

	mov	eax, DWORD PTR _lpRootCsr$[ebp]
	mov	DWORD PTR _lpWorkCsr$[ebp], eax

; 4465 :       lpWorkCsr->nLevel -= nLevelChg;

	movsx	ecx, WORD PTR _nLevelChg$[ebp]
	mov	edx, DWORD PTR _lpWorkCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	sub	eax, ecx
	mov	ecx, DWORD PTR _lpWorkCsr$[ebp]
	mov	WORD PTR [ecx+22], ax
$LN4@fnResetVie:

; 4466 :       while ( lpWorkCsr != lpLastDescCsr )

	mov	edx, DWORD PTR _lpWorkCsr$[ebp]
	cmp	edx, DWORD PTR _lpLastDescCsr$[ebp]
	je	SHORT $LN5@fnResetVie

; 4467 :       {
; 4468 :          lpWorkCsr++;

	mov	eax, DWORD PTR _lpWorkCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpWorkCsr$[ebp], eax

; 4469 :          lpWorkCsr->nLevel -= nLevelChg;

	movsx	ecx, WORD PTR _nLevelChg$[ebp]
	mov	edx, DWORD PTR _lpWorkCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	sub	eax, ecx
	mov	ecx, DWORD PTR _lpWorkCsr$[ebp]
	mov	WORD PTR [ecx+22], ax

; 4470 :       }

	jmp	SHORT $LN4@fnResetVie
$LN5@fnResetVie:

; 4471 : 
; 4472 :       // Reset the recursive parent entity cursor to the recursive
; 4473 :       // parent entity instance when SetViewToSubobject was called.
; 4474 :       lpRecursChildEntityInstance = zGETPTR( lpRootCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpRootCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecursChildEntityInstance$6[ebp], eax

; 4475 :       lpRootCsr->hEntityInstance = lpViewSubobject->hRecursParentEntityInstance;

	mov	ecx, DWORD PTR _lpRootCsr$[ebp]
	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	mov	eax, DWORD PTR [edx+44]
	mov	DWORD PTR [ecx+26], eax

; 4476 :    // if ( lpRootCsr->hEntityInstance == UNSET_CSR )
; 4477 :    //    SysMessageBox( 0, "fnResetViewFromSubobject", "UNSET_CSR", -1 );
; 4478 : 
; 4479 :       fnResetCursorForViewChildren( lpRootCsr );

	mov	ecx, DWORD PTR _lpRootCsr$[ebp]
	push	ecx
	call	_fnResetCursorForViewChildren
	add	esp, 4

; 4480 : 
; 4481 :       // Now reset the recursive childe entity cursor to the recursive
; 4482 :       // parents cursor value when the reset was called. Note: this
; 4483 :       // entity instance may be NULL.
; 4484 :       lpRecursChildEntityCsr = zGETPTR( lpViewSubobject->hRecursViewEntityCsr );

	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	mov	eax, DWORD PTR [edx+40]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecursChildEntityCsr$9[ebp], eax

; 4485 :       lpRecursChildEntityCsr->hEntityInstance = zGETHNDL( lpRecursChildEntityInstance );

	mov	ecx, DWORD PTR _lpRecursChildEntityInstance$6[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpRecursChildEntityCsr$9[ebp]
	mov	DWORD PTR [edx+26], eax

; 4486 :    // if ( lpRecursChildEntityCsr->hEntityInstance == UNSET_CSR )
; 4487 :    //    SysMessageBox( 0, "fnResetViewFromSubobject2", "UNSET_CSR", -1 );
; 4488 : 
; 4489 :       // Now re-establish all cursors up the path from the recursive
; 4490 :       // child to the recursive parent entity types in the event that
; 4491 :       // the recursive child's parent is NOT the recursive parent.
; 4492 :       hRecursChildEntityInstance = lpViewSubobject->hViewParentEntityInstance;

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR _hRecursChildEntityInstance$5[ebp], ecx

; 4493 :       lpRecursChildEntityCsr = zGETPTR( lpRecursChildEntityCsr->hParent );

	mov	edx, DWORD PTR _lpRecursChildEntityCsr$9[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecursChildEntityCsr$9[ebp], eax
$LN6@fnResetVie:

; 4494 :       while ( lpRecursChildEntityCsr != lpRootCsr )

	mov	ecx, DWORD PTR _lpRecursChildEntityCsr$9[ebp]
	cmp	ecx, DWORD PTR _lpRootCsr$[ebp]
	je	SHORT $LN7@fnResetVie

; 4495 :       {
; 4496 :          lpRecursChildEntityCsr->hEntityInstance = hRecursChildEntityInstance;

	mov	edx, DWORD PTR _lpRecursChildEntityCsr$9[ebp]
	mov	eax, DWORD PTR _hRecursChildEntityInstance$5[ebp]
	mov	DWORD PTR [edx+26], eax

; 4497 :       // if ( lpRecursChildEntityCsr->hEntityInstance == UNSET_CSR )
; 4498 :       //    SysMessageBox( 0, "fnResetViewFromSubobject3", "UNSET_CSR", -1 );
; 4499 : 
; 4500 :          lpRecursChildEntityInstance = zGETPTR( hRecursChildEntityInstance );

	mov	ecx, DWORD PTR _hRecursChildEntityInstance$5[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecursChildEntityInstance$6[ebp], eax

; 4501 :          hRecursChildEntityInstance = lpRecursChildEntityInstance->hParent;

	mov	edx, DWORD PTR _lpRecursChildEntityInstance$6[ebp]
	mov	eax, DWORD PTR [edx+30]
	mov	DWORD PTR _hRecursChildEntityInstance$5[ebp], eax

; 4502 :          lpRecursChildEntityCsr = zGETPTR( lpRecursChildEntityCsr->hParent );

	mov	ecx, DWORD PTR _lpRecursChildEntityCsr$9[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecursChildEntityCsr$9[ebp], eax

; 4503 :       }

	jmp	SHORT $LN6@fnResetVie
$LN7@fnResetVie:

; 4504 : 
; 4505 :       // Now that we have reset the recursive view, see if a previous view
; 4506 :       // had been established which was subordinate to the recursive view.
; 4507 :       lpWorkViewSubobject = zGETPTR( lpViewSubobject->hNextViewSubobject );

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewSubobject$10[ebp], eax

; 4508 :       if ( lpWorkViewSubobject &&

	cmp	DWORD PTR _lpWorkViewSubobject$10[ebp], 0
	je	$LN21@fnResetVie
	mov	edx, DWORD PTR _lpWorkViewSubobject$10[ebp]
	movsx	eax, WORD PTR [edx+18]
	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	movsx	edx, WORD PTR [ecx+18]
	cmp	eax, edx
	jle	$LN21@fnResetVie

; 4509 :            lpWorkViewSubobject->nRootHierNbr > lpViewSubobject->nRootHierNbr )
; 4510 :       {
; 4511 :          LPVIEWSUBOBJECT lpNextViewSubobject =

	mov	eax, DWORD PTR _lpWorkViewSubobject$10[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextViewSubobject$7[ebp], eax
$LN8@fnResetVie:

; 4512 :                            zGETPTR( lpWorkViewSubobject->hNextViewSubobject );
; 4513 : 
; 4514 :          while ( lpNextViewSubobject &&

	cmp	DWORD PTR _lpNextViewSubobject$7[ebp], 0
	je	SHORT $LN10@fnResetVie
	mov	edx, DWORD PTR _lpNextViewSubobject$7[ebp]
	movsx	eax, WORD PTR [edx+18]
	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	movsx	edx, WORD PTR [ecx+18]
	cmp	eax, edx
	jle	SHORT $LN10@fnResetVie

; 4515 :                  lpNextViewSubobject->nRootHierNbr >
; 4516 :                                              lpViewSubobject->nRootHierNbr )
; 4517 :          {
; 4518 :             lpWorkViewSubobject = lpNextViewSubobject;

	mov	eax, DWORD PTR _lpNextViewSubobject$7[ebp]
	mov	DWORD PTR _lpWorkViewSubobject$10[ebp], eax

; 4519 :             lpNextViewSubobject =

	mov	ecx, DWORD PTR _lpWorkViewSubobject$10[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextViewSubobject$7[ebp], eax

; 4520 :                            zGETPTR( lpWorkViewSubobject->hNextViewSubobject );
; 4521 :          }

	jmp	SHORT $LN8@fnResetVie
$LN10@fnResetVie:

; 4522 : 
; 4523 :          while ( lpWorkViewSubobject != lpViewSubobject )

	mov	eax, DWORD PTR _lpWorkViewSubobject$10[ebp]
	cmp	eax, DWORD PTR _lpViewSubobject$[ebp]
	je	$LN21@fnResetVie

; 4524 :          {
; 4525 :             LPVIEWENTITYCSR   lpSubRootCsr;
; 4526 :             LPENTITYINSTANCE  lpWorkEntityInstance;
; 4527 :             int               nLevelChg;
; 4528 : 
; 4529 :             // Re-establish previous views from recursive view.
; 4530 :             // Here we restablish previous subordinate views to a recursive
; 4531 :             // view in the order in which they were initially established.
; 4532 :             lpSubRootCsr = zGETPTR( lpWorkViewSubobject->hRootCsr );

	mov	ecx, DWORD PTR _lpWorkViewSubobject$10[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubRootCsr$8[ebp], eax

; 4533 :             lpSubRootCsr->hEntityInstance = lpWorkViewSubobject->hRootEntityInstance;

	mov	eax, DWORD PTR _lpSubRootCsr$8[ebp]
	mov	ecx, DWORD PTR _lpWorkViewSubobject$10[ebp]
	mov	edx, DWORD PTR [ecx+30]
	mov	DWORD PTR [eax+26], edx

; 4534 :          // if ( lpSubRootCsr->hEntityInstance == UNSET_CSR )
; 4535 :          //    SysMessageBox( 0, "fnResetViewFromSubobject4", "UNSET_CSR", -1 );
; 4536 : 
; 4537 :             if ( lpSubRootCsr->hEntityInstance )

	mov	eax, DWORD PTR _lpSubRootCsr$8[ebp]
	cmp	DWORD PTR [eax+26], 0
	je	SHORT $LN23@fnResetVie

; 4538 :             {
; 4539 :                fnResetCursorForViewChildren( lpSubRootCsr );

	mov	ecx, DWORD PTR _lpSubRootCsr$8[ebp]
	push	ecx
	call	_fnResetCursorForViewChildren
	add	esp, 4

; 4540 : 
; 4541 :                // Set parent cursors from subobject csr to lpRootCsr.
; 4542 :                lpWorkCsr = zGETPTR( lpSubRootCsr->hParent );

	mov	edx, DWORD PTR _lpSubRootCsr$8[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkCsr$[ebp], eax

; 4543 :                lpWorkEntityInstance = zGETPTR( lpSubRootCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpSubRootCsr$8[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkEntityInstance$4[ebp], eax
$LN12@fnResetVie:

; 4544 :                while ( lpWorkCsr && lpWorkCsr != lpRootCsr )

	cmp	DWORD PTR _lpWorkCsr$[ebp], 0
	je	SHORT $LN13@fnResetVie
	mov	eax, DWORD PTR _lpWorkCsr$[ebp]
	cmp	eax, DWORD PTR _lpRootCsr$[ebp]
	je	SHORT $LN13@fnResetVie

; 4545 :                {
; 4546 :                   lpWorkEntityInstance = zGETPTR( lpWorkEntityInstance->hParent );

	mov	ecx, DWORD PTR _lpWorkEntityInstance$4[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkEntityInstance$4[ebp], eax

; 4547 :                   lpWorkCsr = zGETPTR( lpWorkCsr->hParent );

	mov	eax, DWORD PTR _lpWorkCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkCsr$[ebp], eax

; 4548 :                }

	jmp	SHORT $LN12@fnResetVie
$LN13@fnResetVie:

; 4549 :             }

	jmp	SHORT $LN24@fnResetVie
$LN23@fnResetVie:

; 4550 :             else
; 4551 :                fnNullCursorForViewChildren( lpSubRootCsr );

	mov	edx, DWORD PTR _lpSubRootCsr$8[ebp]
	push	edx
	call	_fnNullCursorForViewChildren
	add	esp, 4
$LN24@fnResetVie:

; 4552 : 
; 4553 :             // Now that we've reset a cursor, redo the leveling if a level
; 4554 :             // change is necessary.
; 4555 :             nLevelChg = lpWorkViewSubobject->nLevelChg;

	mov	eax, DWORD PTR _lpWorkViewSubobject$10[ebp]
	movsx	ecx, WORD PTR [eax+34]
	mov	DWORD PTR _nLevelChg$3[ebp], ecx

; 4556 :             lpWorkCsr = zGETPTR( lpWorkViewSubobject->hLastDescCsr );

	mov	edx, DWORD PTR _lpWorkViewSubobject$10[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkCsr$[ebp], eax

; 4557 :             lpWorkCsr->hNextHier = 0;

	mov	ecx, DWORD PTR _lpWorkCsr$[ebp]
	mov	DWORD PTR [ecx+2], 0

; 4558 :             lpWorkCsr = zGETPTR( lpWorkViewSubobject->hRootCsr );

	mov	edx, DWORD PTR _lpWorkViewSubobject$10[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkCsr$[ebp], eax

; 4559 :             lpWorkCsr->hPrevHier = 0;

	mov	ecx, DWORD PTR _lpWorkCsr$[ebp]
	mov	DWORD PTR [ecx+6], 0

; 4560 :             lpWorkCsr->hParent = 0;

	mov	edx, DWORD PTR _lpWorkCsr$[ebp]
	mov	DWORD PTR [edx+10], 0

; 4561 :             lpViewCsr->hRootViewEntityCsr =

	push	0
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWorkCsr$[ebp]
	push	ecx
	call	_fnCreateEntityCsrHandle@12
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [edx+18], eax

; 4562 :                         fnCreateEntityCsrHandle( lpWorkCsr, lpViewCsr, 0 );
; 4563 :             lpViewCsr->hViewParentEntityInstance =

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR _lpWorkViewSubobject$10[ebp]
	mov	edx, DWORD PTR [ecx+26]
	mov	DWORD PTR [eax+38], edx

; 4564 :                         lpWorkViewSubobject->hViewParentEntityInstance;
; 4565 :             if ( nLevelChg )

	cmp	DWORD PTR _nLevelChg$3[ebp], 0
	je	SHORT $LN25@fnResetVie
$LN14@fnResetVie:

; 4566 :             {
; 4567 :                while( lpWorkCsr )

	cmp	DWORD PTR _lpWorkCsr$[ebp], 0
	je	SHORT $LN25@fnResetVie

; 4568 :                {
; 4569 :                   lpWorkCsr->nLevel += nLevelChg;

	mov	eax, DWORD PTR _lpWorkCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	add	ecx, DWORD PTR _nLevelChg$3[ebp]
	mov	edx, DWORD PTR _lpWorkCsr$[ebp]
	mov	WORD PTR [edx+22], cx

; 4570 :                   lpWorkCsr = zGETPTR( lpWorkCsr->hNextHier );

	mov	eax, DWORD PTR _lpWorkCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkCsr$[ebp], eax

; 4571 :                }

	jmp	SHORT $LN14@fnResetVie
$LN25@fnResetVie:

; 4572 :             }
; 4573 : 
; 4574 :             // Whew, one done, re-establish the next sub view.
; 4575 :             lpWorkViewSubobject =

	mov	edx, DWORD PTR _lpWorkViewSubobject$10[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewSubobject$10[ebp], eax

; 4576 :                         zGETPTR( lpWorkViewSubobject->hPrevViewSubobject );
; 4577 :          }

	jmp	$LN10@fnResetVie
$LN21@fnResetVie:

; 4578 :       }
; 4579 :    }
; 4580 : 
; 4581 :    // Unchain lpViewSubobject and return it to the system.
; 4582 :    lpViewCsr->hFirstViewSubobject = lpViewSubobject->hNextViewSubobject;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+30], eax

; 4583 :    if ( lpViewCsr->hFirstViewSubobject )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $LN26@fnResetVie

; 4584 :    {
; 4585 :       LPVIEWSUBOBJECT lpFirstViewSubobject =

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstViewSubobject$2[ebp], eax

; 4586 :                                  zGETPTR( lpViewCsr->hFirstViewSubobject );
; 4587 : 
; 4588 :       lpFirstViewSubobject->hPrevViewSubobject = 0;

	mov	ecx, DWORD PTR _lpFirstViewSubobject$2[ebp]
	mov	DWORD PTR [ecx+6], 0

; 4589 : 
; 4590 :       // Gig, 11/4/92 - Reset View Parent Entity Instance.
; 4591 :       lpViewCsr->hViewParentEntityInstance =

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR _lpFirstViewSubobject$2[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR [edx+38], ecx

; 4592 :                      lpFirstViewSubobject->hViewParentEntityInstance;
; 4593 :    }

	jmp	SHORT $LN27@fnResetVie
$LN26@fnResetVie:

; 4594 :    else
; 4595 :       lpViewCsr->hViewParentEntityInstance = 0;

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [edx+38], 0
$LN27@fnResetVie:

; 4596 : 
; 4597 :    fnFreeDataspace( lpViewSubobject );

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 4598 :    return( 0 );

	xor	eax, eax
$LN1@fnResetVie:

; 4599 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnResetViewFromSubobject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpViewOD$ = -36					; size = 4
_lpViewOI$ = -32					; size = 4
_lpSelectedInstance$ = -28				; size = 4
_lpViewSubobject$1 = -24				; size = 4
_lpRootEntityInstance$ = -20				; size = 4
_lpParentCsr$2 = -16					; size = 4
_lpViewEntity$ = -12					; size = 4
_lpViewCsr$ = -8					; size = 4
_lpViewEntityCsr$ = -4					; size = 4
_lpView$ = 8						; size = 4
_nControl$ = 12						; size = 2
_fnResetView PROC

; 4279 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 4280 :    LPVIEWCSR           lpViewCsr;
; 4281 :    LPVIEWOI            lpViewOI;
; 4282 :    LPVIEWOD            lpViewOD;
; 4283 :    LPVIEWENTITY        lpViewEntity;
; 4284 :    LPVIEWENTITYCSR     lpViewEntityCsr;
; 4285 :    LPENTITYINSTANCE    lpRootEntityInstance;
; 4286 :    LPSELECTEDINSTANCE  lpSelectedInstance;
; 4287 : 
; 4288 :    // Get View Cursors for instance.
; 4289 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 4290 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4291 :    lpViewOD  = zGETPTR( lpViewOI->hViewOD );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 4292 :    lpViewCsr->hHierRootEntityInstance = 0;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [eax+22], 0

; 4293 :    lpViewCsr->hHierEntityInstance = 0;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [ecx+26], 0

; 4294 : 
; 4295 :    // If the view has any outstanding subobjects, delete the subobject
; 4296 :    // entries and reset the hierarchical and parent pointers in the
; 4297 :    // view cursors as well as the levels.
; 4298 :    if ( lpViewCsr->hFirstViewSubobject )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+30], 0
	je	$LN14@fnResetVie
$LN2@fnResetVie:

; 4299 :    {
; 4300 :       while ( lpViewCsr->hFirstViewSubobject )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $LN3@fnResetVie

; 4301 :       {
; 4302 :          LPVIEWSUBOBJECT lpViewSubobject;
; 4303 : 
; 4304 :          lpViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$1[ebp], eax

; 4305 :          lpViewCsr->hFirstViewSubobject =

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR _lpViewSubobject$1[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+30], edx

; 4306 :                                     lpViewSubobject->hNextViewSubobject;
; 4307 :          fnFreeDataspace( lpViewSubobject );

	mov	eax, DWORD PTR _lpViewSubobject$1[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 4308 :       }

	jmp	SHORT $LN2@fnResetVie
$LN3@fnResetVie:

; 4309 : 
; 4310 :       // Now that we've blasted the subobject information, reset the
; 4311 :       // hierarchical pointers and parent pointers in the view cursors.
; 4312 :       lpViewEntity    = zGETPTR( lpViewOD->hFirstOD_Entity );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4313 :       lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
$LN4@fnResetVie:

; 4314 :       while ( lpViewEntity )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	je	SHORT $LN5@fnResetVie

; 4315 :       {
; 4316 :          lpViewEntityCsr->nLevel = lpViewEntity->nLevel;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	cx, WORD PTR [eax+215]
	mov	WORD PTR [edx+22], cx

; 4317 :          if ( lpViewEntity->hParent )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	SHORT $LN15@fnResetVie

; 4318 :             lpViewEntityCsr->hPrevHier =

	push	-1
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnCreateEntityCsrHandle@12
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+6], eax
$LN15@fnResetVie:

; 4319 :                fnCreateEntityCsrHandle( lpViewEntityCsr, lpViewCsr, -1 );
; 4320 : 
; 4321 :          if ( lpViewEntity->hNextHier )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	cmp	DWORD PTR [eax+2], 0
	je	SHORT $LN16@fnResetVie

; 4322 :             lpViewEntityCsr->hNextHier =

	push	1
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnCreateEntityCsrHandle@12
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+2], eax
$LN16@fnResetVie:

; 4323 :                fnCreateEntityCsrHandle( lpViewEntityCsr, lpViewCsr, 1 );
; 4324 : 
; 4325 :          lpViewEntity = zGETPTR( lpViewEntity->hNextHier );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 4326 :          lpViewEntityCsr++;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpViewEntityCsr$[ebp], ecx

; 4327 :       }

	jmp	SHORT $LN4@fnResetVie
$LN5@fnResetVie:

; 4328 : 
; 4329 :       // Now reset the parent cursor pointers.
; 4330 :       lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 4331 :       lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
$LN6@fnResetVie:

; 4332 :       while ( lpViewEntityCsr )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	je	SHORT $LN7@fnResetVie

; 4333 :       {
; 4334 :          if ( lpViewEntityCsr->hParent == 0 )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	SHORT $LN17@fnResetVie

; 4335 :          {
; 4336 :             LPVIEWENTITYCSR  lpParentCsr;
; 4337 : 
; 4338 :             lpParentCsr = lpViewEntityCsr - 1;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	sub	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpParentCsr$2[ebp], ecx
$LN8@fnResetVie:

; 4339 :             while ( lpParentCsr->nLevel != lpViewEntityCsr->nLevel - 1 )

	mov	edx, DWORD PTR _lpParentCsr$2[ebp]
	movsx	eax, WORD PTR [edx+22]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	sub	edx, 1
	cmp	eax, edx
	je	SHORT $LN9@fnResetVie

; 4340 :                lpParentCsr--;

	mov	eax, DWORD PTR _lpParentCsr$2[ebp]
	sub	eax, 30					; 0000001eH
	mov	DWORD PTR _lpParentCsr$2[ebp], eax
	jmp	SHORT $LN8@fnResetVie
$LN9@fnResetVie:

; 4341 : 
; 4342 :             lpViewEntityCsr->hParent = fnCreateEntityCsrHandle( lpParentCsr, lpViewCsr, 0 );

	push	0
	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpParentCsr$2[ebp]
	push	edx
	call	_fnCreateEntityCsrHandle@12
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+10], eax
$LN17@fnResetVie:

; 4343 :          // if ( lpViewEntityCsr->hParent == (LPVIEWENTITYCSR) 1 )
; 4344 :          //    SysMessageBox( 0, "fnResetView", "1", -1 );
; 4345 :          }
; 4346 : 
; 4347 :          lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 4348 :       }

	jmp	SHORT $LN6@fnResetVie
$LN7@fnResetVie:

; 4349 : 
; 4350 :       lpViewCsr->hRootViewEntityCsr = lpViewCsr->hFirstOD_EntityCsr;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR [ecx+18], eax

; 4351 :       lpViewCsr->hViewParentEntityInstance = 0;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR [ecx+38], 0
$LN14@fnResetVie:

; 4352 :    }
; 4353 : 
; 4354 :    // Clear any and all selected instances, unless asked not to.
; 4355 :    if ( (nControl & 1) == 0 )

	movsx	edx, WORD PTR _nControl$[ebp]
	and	edx, 1
	jne	SHORT $LN18@fnResetVie
$LN10@fnResetVie:

; 4356 :    {
; 4357 :       while ( lpViewCsr->hFirstSelectedInstance )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [eax+42], 0
	je	SHORT $LN18@fnResetVie

; 4358 :       {
; 4359 :          lpSelectedInstance = zGETPTR( lpViewCsr->hFirstSelectedInstance );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSelectedInstance$[ebp], eax

; 4360 :          lpViewCsr->hFirstSelectedInstance =

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR _lpSelectedInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+42], edx

; 4361 :             lpSelectedInstance->hNextSelectedInstance;
; 4362 : 
; 4363 :          fnFreeDataspace( lpSelectedInstance );

	mov	eax, DWORD PTR _lpSelectedInstance$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 4364 :       }

	jmp	SHORT $LN10@fnResetVie
$LN18@fnResetVie:

; 4365 :    }
; 4366 : 
; 4367 :    // Reset the cursor for all the view children from the root.
; 4368 :    lpRootEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootEntityInstance$[ebp], eax

; 4369 :    if ( lpRootEntityInstance )

	cmp	DWORD PTR _lpRootEntityInstance$[ebp], 0
	je	SHORT $LN19@fnResetVie

; 4370 :    {
; 4371 :       lpViewEntityCsr = zGETPTR( lpViewCsr->hRootViewEntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax
$LN12@fnResetVie:

; 4372 :       while ( lpViewEntityCsr->hViewEntity !=

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpRootEntityInstance$[ebp]
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+2]
	je	SHORT $LN13@fnResetVie

; 4373 :                                           lpRootEntityInstance->hViewEntity )
; 4374 :       {
; 4375 :          lpViewEntityCsr = zGETPTR( lpViewEntityCsr->hNextHier );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 4376 :       }

	jmp	SHORT $LN12@fnResetVie
$LN13@fnResetVie:

; 4377 : 
; 4378 :       lpViewEntityCsr->hEntityInstance = zGETHNDL( lpRootEntityInstance );

	mov	ecx, DWORD PTR _lpRootEntityInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+26], eax

; 4379 :    // if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )
; 4380 :    //    SysMessageBox( 0, "fnResetView", "UNSET_CSR", -1 );
; 4381 : 
; 4382 :       fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnResetCursorForViewChildren
	add	esp, 4
$LN19@fnResetVie:

; 4383 :    }
; 4384 : 
; 4385 :    return( 0 );  // we're done, return success

	xor	eax, eax

; 4386 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnResetView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpFirstViewSubobject$1 = -80				; size = 4
_lpRootCsr$2 = -76					; size = 4
_lpRecursParentEntity$3 = -72				; size = 4
_lpOwningTask$ = -68					; size = 4
_lpViewOI$ = -64					; size = 4
_lpWorkViewEntity$ = -60				; size = 4
_lpNextHierCsr$4 = -56					; size = 4
_hViewSubobject$ = -52					; size = 4
_hWorkCsr$5 = -48					; size = 4
_lpPrevViewSubobject$ = -44				; size = 4
_hViewEntityCsr$ = -40					; size = 4
_lpViewRootParentCsr$ = -36				; size = 4
_lpLastDescCsr$ = -32					; size = 4
_lpViewSubobject$ = -28					; size = 4
_lpWorkViewSubobject$6 = -24				; size = 4
_lpWorkCsr$7 = -20					; size = 4
_lpRecursParentCsr$ = -16				; size = 4
_lpViewCsr$ = -12					; size = 4
_nLevelChg$ = -8					; size = 2
_nLevelChg$8 = -4					; size = 2
_lpView$ = 8						; size = 4
_lpViewEntity$ = 12					; size = 4
_lpViewEntityCsr$ = 16					; size = 4
_fnSetViewToSubobject PROC

; 4028 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 4029 :    zSHORT            nLevelChg;
; 4030 :    LPTASK            lpOwningTask;
; 4031 :    LPVIEWOI          lpViewOI;
; 4032 :    LPVIEWCSR         lpViewCsr;
; 4033 :    LPVIEWENTITYCSR   lpViewRootParentCsr;
; 4034 :    LPVIEWENTITYCSR   lpRecursParentCsr;
; 4035 :    LPVIEWENTITYCSR   lpLastDescCsr;
; 4036 :    LPVIEWSUBOBJECT   lpViewSubobject;
; 4037 :    LPVIEWSUBOBJECT   lpPrevViewSubobject;
; 4038 :    zPVOID            hViewSubobject;
; 4039 :    LPVIEWENTITY      lpWorkViewEntity;
; 4040 : 
; 4041 :    // Following handles are declared as pointers instead of zPVOID so that
; 4042 :    // we can use pointer arithmetic on them.
; 4043 :    LPVIEWENTITYCSR   hViewEntityCsr;
; 4044 : 
; 4045 :    // Get the ViewCsr associated with the view
; 4046 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 4047 :    lpViewOI  = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 4048 : 
; 4049 :    // Get the instance owning task so we can do allocates
; 4050 :    lpOwningTask = zGETPTR( lpViewOI->hTask );

	mov	ecx, DWORD PTR _lpViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 4051 : 
; 4052 :    if ( lpViewEntityCsr == 0 )

	cmp	DWORD PTR _lpViewEntityCsr$[ebp], 0
	jne	SHORT $LN11@fnSetViewT

; 4053 :    {
; 4054 :       lpViewEntityCsr = zGETPTR( lpViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 4055 :       lpViewEntityCsr += ( lpViewEntity->nHierNbr - 1 );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	sub	eax, 1
	imul	ecx, eax, 30
	add	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], ecx
$LN11@fnSetViewT:

; 4056 :    }
; 4057 : 
; 4058 :    // Create a handle for the view entity csr.
; 4059 :    hViewEntityCsr = fnCreateEntityCsrHandle( lpViewEntityCsr, lpViewCsr, 0 );

	push	0
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnCreateEntityCsrHandle@12
	mov	DWORD PTR _hViewEntityCsr$[ebp], eax

; 4060 : 
; 4061 :    if ( lpViewCsr->hRootViewEntityCsr == hViewEntityCsr )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	cmp	edx, DWORD PTR _hViewEntityCsr$[ebp]
	jne	SHORT $LN12@fnSetViewT

; 4062 :       return( 1 );

	mov	eax, 1
	jmp	$LN1@fnSetViewT
$LN12@fnSetViewT:

; 4063 : 
; 4064 :    if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+26], 1
	jne	SHORT $LN13@fnSetViewT

; 4065 :       fnEstablishCursorForView( lpViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEstablishCursorForView
	add	esp, 4
$LN13@fnSetViewT:

; 4066 : 
; 4067 :    lpViewRootParentCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewRootParentCsr$[ebp], eax

; 4068 : 
; 4069 :    // We double check that the parent cursor does not need establishing
; 4070 :    // because create entity ( through another view ) might mark the
; 4071 :    // parent only as needing to be established.
; 4072 :    if ( lpViewRootParentCsr->hEntityInstance == UNSET_CSR )

	mov	ecx, DWORD PTR _lpViewRootParentCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 1
	jne	SHORT $LN14@fnSetViewT

; 4073 :       fnEstablishCursorForView( lpViewRootParentCsr );

	mov	edx, DWORD PTR _lpViewRootParentCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4
$LN14@fnSetViewT:

; 4074 : 
; 4075 :    // Create a viewsubobject record for saving view switching info.
; 4076 :    hViewSubobject = fnAllocDataspace( lpOwningTask->hFirstDataHeader,

	push	10020					; 00002724H
	push	0
	push	1
	push	48					; 00000030H
	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	mov	ecx, DWORD PTR [eax+94]
	push	ecx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hViewSubobject$[ebp], eax

; 4077 :                                       sizeof( ViewSubobjectRecord ), 1, 0,
; 4078 :                                       iViewSubobject );
; 4079 :    lpViewSubobject = (LPVIEWSUBOBJECT) zGETPTR( hViewSubobject );

	mov	edx, DWORD PTR _hViewSubobject$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$[ebp], eax

; 4080 :    if ( lpViewSubobject == 0 )

	cmp	DWORD PTR _lpViewSubobject$[ebp], 0
	jne	SHORT $LN15@fnSetViewT

; 4081 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetViewT
$LN15@fnSetViewT:

; 4082 : 
; 4083 :    // Next, look for a recursive parent to the entity to see if the
; 4084 :    // structure needs to be folded up recursively.
; 4085 :    lpRecursParentCsr = 0;

	mov	DWORD PTR _lpRecursParentCsr$[ebp], 0

; 4086 :    if ( lpViewEntity->bRecursive )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	$LN16@fnSetViewT

; 4087 :    {
; 4088 :       lpPrevViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevViewSubobject$[ebp], eax

; 4089 :       lpRecursParentCsr = lpViewRootParentCsr;

	mov	ecx, DWORD PTR _lpViewRootParentCsr$[ebp]
	mov	DWORD PTR _lpRecursParentCsr$[ebp], ecx
$LN2@fnSetViewT:

; 4090 :       while ( lpRecursParentCsr )

	cmp	DWORD PTR _lpRecursParentCsr$[ebp], 0
	je	$LN16@fnSetViewT

; 4091 :       {
; 4092 :          LPVIEWENTITY lpRecursParentEntity = zGETPTR( lpRecursParentCsr->hViewEntity );

	mov	edx, DWORD PTR _lpRecursParentCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecursParentEntity$3[ebp], eax

; 4093 : 
; 4094 :          if ( lpRecursParentEntity->lEREntTok == lpViewEntity->lEREntTok &&

	mov	ecx, DWORD PTR _lpRecursParentEntity$3[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [ecx+195]
	cmp	eax, DWORD PTR [edx+195]
	jne	SHORT $LN17@fnSetViewT
	mov	ecx, DWORD PTR _lpRecursParentCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	cmp	edx, ecx
	jge	SHORT $LN17@fnSetViewT

; 4095 :               lpRecursParentCsr->nLevel < lpViewEntityCsr->nLevel )
; 4096 :          {
; 4097 :             break;

	jmp	SHORT $LN16@fnSetViewT

; 4098 :          }

	jmp	SHORT $LN18@fnSetViewT
$LN17@fnSetViewT:

; 4099 :          else
; 4100 :          if ( lpRecursParentCsr == zGETPTR( lpViewCsr->hFirstOD_EntityCsr ) )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpRecursParentCsr$[ebp], eax
	jne	SHORT $LN19@fnSetViewT

; 4101 :          {
; 4102 :             lpRecursParentCsr = 0;

	mov	DWORD PTR _lpRecursParentCsr$[ebp], 0

; 4103 :             break;

	jmp	SHORT $LN16@fnSetViewT

; 4104 :          }

	jmp	SHORT $LN18@fnSetViewT
$LN19@fnSetViewT:

; 4105 :          else
; 4106 :          if ( lpRecursParentCsr->hParent )

	mov	ecx, DWORD PTR _lpRecursParentCsr$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	SHORT $LN21@fnSetViewT

; 4107 :          {
; 4108 :             lpRecursParentCsr = zGETPTR( lpRecursParentCsr->hParent );

	mov	edx, DWORD PTR _lpRecursParentCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecursParentCsr$[ebp], eax

; 4109 :          }

	jmp	SHORT $LN18@fnSetViewT
$LN21@fnSetViewT:

; 4110 :          else
; 4111 :          {
; 4112 :             lpRecursParentCsr = zGETPTR( lpPrevViewSubobject->hViewRootParentCsr );

	mov	ecx, DWORD PTR _lpPrevViewSubobject$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRecursParentCsr$[ebp], eax

; 4113 :             lpPrevViewSubobject = zGETPTR( lpPrevViewSubobject->hNextViewSubobject );

	mov	eax, DWORD PTR _lpPrevViewSubobject$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpPrevViewSubobject$[ebp], eax
$LN18@fnSetViewT:

; 4114 :          }
; 4115 :       }

	jmp	$LN2@fnSetViewT
$LN16@fnSetViewT:

; 4116 :    }
; 4117 : 
; 4118 :    // Set view parent entity instance.
; 4119 :    lpViewCsr->hViewParentEntityInstance = lpViewRootParentCsr->hEntityInstance;

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR _lpViewRootParentCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR [edx+38], ecx

; 4120 :    lpViewSubobject->hViewParentEntityInstance = lpViewRootParentCsr->hEntityInstance;

	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	mov	eax, DWORD PTR _lpViewRootParentCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR [edx+26], ecx

; 4121 : 
; 4122 :    // Determine the level change for the recursive subobject.
; 4123 :    nLevelChg = 0;

	xor	edx, edx
	mov	WORD PTR _nLevelChg$[ebp], dx

; 4124 :    if ( lpRecursParentCsr ) // is it recursive

	cmp	DWORD PTR _lpRecursParentCsr$[ebp], 0
	je	$LN23@fnSetViewT

; 4125 :    {
; 4126 :       LPVIEWSUBOBJECT lpWorkViewSubobject;
; 4127 : 
; 4128 :       lpViewSubobject->hRecursParentEntityInstance = lpRecursParentCsr->hEntityInstance;

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	ecx, DWORD PTR _lpRecursParentCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	mov	DWORD PTR [eax+44], edx

; 4129 :       lpViewSubobject->hRecursViewEntityCsr = hViewEntityCsr;

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	ecx, DWORD PTR _hViewEntityCsr$[ebp]
	mov	DWORD PTR [eax+40], ecx

; 4130 :       lpViewSubobject->hRecursViewEntity = lpViewEntityCsr->hViewEntity;

	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR [edx+36], ecx

; 4131 :       nLevelChg = lpViewEntityCsr->nLevel - lpRecursParentCsr->nLevel;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	eax, WORD PTR [edx+22]
	mov	ecx, DWORD PTR _lpRecursParentCsr$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	sub	eax, edx
	mov	WORD PTR _nLevelChg$[ebp], ax

; 4132 :       lpRecursParentCsr->hEntityInstance = lpViewEntityCsr->hEntityInstance;

	mov	eax, DWORD PTR _lpRecursParentCsr$[ebp]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	mov	DWORD PTR [eax+26], edx

; 4133 :    // if ( lpRecursParentCsr->hEntityInstance == UNSET_CSR )
; 4134 :    //    SysMessageBox( 0, "fnSetViewToSubobject", "UNSET_CSR", -1 );
; 4135 : 
; 4136 :       lpViewEntityCsr = lpRecursParentCsr;

	mov	eax, DWORD PTR _lpRecursParentCsr$[ebp]
	mov	DWORD PTR _lpViewEntityCsr$[ebp], eax

; 4137 :       lpViewRootParentCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewRootParentCsr$[ebp], eax

; 4138 :       hViewEntityCsr = fnCreateEntityCsrHandle( lpViewEntityCsr, lpViewCsr, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnCreateEntityCsrHandle@12
	mov	DWORD PTR _hViewEntityCsr$[ebp], eax

; 4139 : 
; 4140 :       // Before resetting cursor for children, capture the current
; 4141 :       // root cursor positions for outstanding subobject views which
; 4142 :       // are subordinate to the recursive parent cursor and re-do
; 4143 :       // any recursive level changes which are subordinate to the
; 4144 :       // parent cursor.
; 4145 :       lpWorkViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewSubobject$6[ebp], eax
$LN4@fnSetViewT:

; 4146 :       while ( lpWorkViewSubobject )

	cmp	DWORD PTR _lpWorkViewSubobject$6[ebp], 0
	je	$LN5@fnSetViewT

; 4147 :       {
; 4148 :          zSHORT          nLevelChg;
; 4149 :          LPVIEWENTITYCSR lpRootCsr;
; 4150 :          LPVIEWENTITYCSR lpWorkCsr;
; 4151 : 
; 4152 :          if ( lpWorkViewSubobject->nRootHierNbr <= lpRecursParentCsr->nHierNbr )

	mov	ecx, DWORD PTR _lpWorkViewSubobject$6[ebp]
	movsx	edx, WORD PTR [ecx+18]
	mov	eax, DWORD PTR _lpRecursParentCsr$[ebp]
	movsx	ecx, WORD PTR [eax+24]
	cmp	edx, ecx
	jg	SHORT $LN24@fnSetViewT

; 4153 :             break;

	jmp	$LN5@fnSetViewT
$LN24@fnSetViewT:

; 4154 : 
; 4155 :          // Get current entity instance for reset.
; 4156 :          lpRootCsr = zGETPTR( lpWorkViewSubobject->hRootCsr );

	mov	edx, DWORD PTR _lpWorkViewSubobject$6[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpRootCsr$2[ebp], eax

; 4157 :          lpWorkViewSubobject->hRootEntityInstance = lpRootCsr->hEntityInstance;

	mov	ecx, DWORD PTR _lpWorkViewSubobject$6[ebp]
	mov	edx, DWORD PTR _lpRootCsr$2[ebp]
	mov	eax, DWORD PTR [edx+26]
	mov	DWORD PTR [ecx+30], eax

; 4158 :          nLevelChg = lpWorkViewSubobject->nLevelChg;

	mov	ecx, DWORD PTR _lpWorkViewSubobject$6[ebp]
	mov	dx, WORD PTR [ecx+34]
	mov	WORD PTR _nLevelChg$8[ebp], dx

; 4159 :          if ( lpWorkViewSubobject->nLastDescHierNbr < lpViewCsr->uEntities )

	mov	eax, DWORD PTR _lpWorkViewSubobject$6[ebp]
	movsx	ecx, WORD PTR [eax+24]
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	movzx	eax, WORD PTR [edx+34]
	cmp	ecx, eax
	jge	SHORT $LN25@fnSetViewT

; 4160 :          {
; 4161 :             lpWorkCsr = zGETPTR( lpWorkViewSubobject->hLastDescCsr );

	mov	ecx, DWORD PTR _lpWorkViewSubobject$6[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkCsr$7[ebp], eax

; 4162 :             lpWorkCsr->hNextHier = fnCreateEntityCsrHandle( lpWorkCsr, lpViewCsr, 1 );

	push	1
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWorkCsr$7[ebp]
	push	ecx
	call	_fnCreateEntityCsrHandle@12
	mov	edx, DWORD PTR _lpWorkCsr$7[ebp]
	mov	DWORD PTR [edx+2], eax
$LN25@fnSetViewT:

; 4163 :          }
; 4164 : 
; 4165 :          // Reset hierarchical and parent pointers.
; 4166 :          lpWorkCsr = zGETPTR( lpWorkViewSubobject->hRootCsr );

	mov	eax, DWORD PTR _lpWorkViewSubobject$6[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkCsr$7[ebp], eax

; 4167 :          lpWorkCsr->hPrevHier = fnCreateEntityCsrHandle( lpWorkCsr, lpViewCsr, -1 );

	push	-1
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWorkCsr$7[ebp]
	push	eax
	call	_fnCreateEntityCsrHandle@12
	mov	ecx, DWORD PTR _lpWorkCsr$7[ebp]
	mov	DWORD PTR [ecx+6], eax

; 4168 :          lpWorkCsr->hParent = lpWorkViewSubobject->hViewRootParentCsr;

	mov	edx, DWORD PTR _lpWorkCsr$7[ebp]
	mov	eax, DWORD PTR _lpWorkViewSubobject$6[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	DWORD PTR [edx+10], ecx

; 4169 :       // if ( lpWorkCsr->hParent == (LPVIEWENTITYCSR) 1 )
; 4170 :       //    SysMessageBox( 0, "fnSetViewToSubobject", "1", -1 );
; 4171 : 
; 4172 :          // Redo the leveling of the recursive subobject which is
; 4173 :          // itself a subobject of a parent recursive subobject.
; 4174 :          if ( nLevelChg )

	movsx	edx, WORD PTR _nLevelChg$8[ebp]
	test	edx, edx
	je	SHORT $LN26@fnSetViewT

; 4175 :          {
; 4176 :             LPVIEWENTITYCSR hWorkCsr;
; 4177 : 
; 4178 :             hWorkCsr = fnCreateEntityCsrHandle( lpWorkCsr, lpViewCsr, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWorkCsr$7[ebp]
	push	ecx
	call	_fnCreateEntityCsrHandle@12
	mov	DWORD PTR _hWorkCsr$5[ebp], eax
$LN6@fnSetViewT:

; 4179 :             while ( hWorkCsr != lpWorkViewSubobject->hLastDescCsr )

	mov	edx, DWORD PTR _lpWorkViewSubobject$6[ebp]
	mov	eax, DWORD PTR _hWorkCsr$5[ebp]
	cmp	eax, DWORD PTR [edx+20]
	je	SHORT $LN7@fnSetViewT

; 4180 :             {
; 4181 :                lpWorkCsr->nLevel -= nLevelChg;

	movsx	ecx, WORD PTR _nLevelChg$8[ebp]
	mov	edx, DWORD PTR _lpWorkCsr$7[ebp]
	movsx	eax, WORD PTR [edx+22]
	sub	eax, ecx
	mov	ecx, DWORD PTR _lpWorkCsr$7[ebp]
	mov	WORD PTR [ecx+22], ax

; 4182 :                lpWorkCsr++;

	mov	edx, DWORD PTR _lpWorkCsr$7[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _lpWorkCsr$7[ebp], edx

; 4183 :                hWorkCsr++;

	mov	eax, DWORD PTR _hWorkCsr$5[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _hWorkCsr$5[ebp], eax

; 4184 :             }

	jmp	SHORT $LN6@fnSetViewT
$LN7@fnSetViewT:

; 4185 : 
; 4186 :             lpWorkCsr->nLevel -= nLevelChg; // change level of last desc

	movsx	ecx, WORD PTR _nLevelChg$8[ebp]
	mov	edx, DWORD PTR _lpWorkCsr$7[ebp]
	movsx	eax, WORD PTR [edx+22]
	sub	eax, ecx
	mov	ecx, DWORD PTR _lpWorkCsr$7[ebp]
	mov	WORD PTR [ecx+22], ax
$LN26@fnSetViewT:

; 4187 :          }
; 4188 : 
; 4189 :          lpWorkViewSubobject = zGETPTR( lpWorkViewSubobject->hNextViewSubobject );

	mov	edx, DWORD PTR _lpWorkViewSubobject$6[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewSubobject$6[ebp], eax

; 4190 :       }

	jmp	$LN4@fnSetViewT
$LN5@fnSetViewT:

; 4191 : 
; 4192 :       if ( lpViewEntityCsr->hEntityInstance )

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 0
	je	SHORT $LN27@fnSetViewT

; 4193 :          fnResetCursorForViewChildren( lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnResetCursorForViewChildren
	add	esp, 4
	jmp	SHORT $LN23@fnSetViewT
$LN27@fnSetViewT:

; 4194 :       else
; 4195 :          fnNullCursorForViewChildren( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnNullCursorForViewChildren
	add	esp, 4
$LN23@fnSetViewT:

; 4196 :    }
; 4197 : 
; 4198 :    // Continue setting subobject information for reset.
; 4199 :    lpWorkViewEntity = zGETPTR( lpViewEntityCsr->hViewEntity );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEntity$[ebp], eax

; 4200 :    lpViewSubobject->hRootCsr           = hViewEntityCsr;

	mov	eax, DWORD PTR _lpViewSubobject$[ebp]
	mov	ecx, DWORD PTR _hViewEntityCsr$[ebp]
	mov	DWORD PTR [eax+14], ecx

; 4201 :    lpViewSubobject->nRootHierNbr       = lpWorkViewEntity->nHierNbr;

	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	mov	eax, DWORD PTR _lpWorkViewEntity$[ebp]
	mov	cx, WORD PTR [eax+217]
	mov	WORD PTR [edx+18], cx

; 4202 :    lpViewSubobject->hViewRootParentCsr =

	push	0
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewRootParentCsr$[ebp]
	push	eax
	call	_fnCreateEntityCsrHandle@12
	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	DWORD PTR [ecx+10], eax

; 4203 :             fnCreateEntityCsrHandle( lpViewRootParentCsr, lpViewCsr, 0 );
; 4204 :    lpViewSubobject->nLevelChg = nLevelChg;

	mov	edx, DWORD PTR _lpViewSubobject$[ebp]
	mov	ax, WORD PTR _nLevelChg$[ebp]
	mov	WORD PTR [edx+34], ax

; 4205 : 
; 4206 :    // Set the new root view entity cursor.
; 4207 :    lpViewCsr->hRootViewEntityCsr = hViewEntityCsr;

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR _hViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+18], edx

; 4208 : 
; 4209 :    // Chain view subobject on to view csr.
; 4210 :    if ( lpViewCsr->hFirstViewSubobject )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $LN29@fnSetViewT

; 4211 :    {
; 4212 :       LPVIEWSUBOBJECT lpFirstViewSubobject;
; 4213 : 
; 4214 :       lpViewSubobject->hNextViewSubobject = lpViewCsr->hFirstViewSubobject;

	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+30]
	mov	DWORD PTR [ecx+2], eax

; 4215 :       lpFirstViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstViewSubobject$1[ebp], eax

; 4216 :       lpFirstViewSubobject->hPrevViewSubobject = hViewSubobject;

	mov	eax, DWORD PTR _lpFirstViewSubobject$1[ebp]
	mov	ecx, DWORD PTR _hViewSubobject$[ebp]
	mov	DWORD PTR [eax+6], ecx
$LN29@fnSetViewT:

; 4217 :    }
; 4218 : 
; 4219 :    lpViewCsr->hFirstViewSubobject = hViewSubobject;

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR _hViewSubobject$[ebp]
	mov	DWORD PTR [edx+30], eax

; 4220 : 
; 4221 :    // Now, go from the current view position to the last descendent
; 4222 :    // of the entity view and adjust the levels if necessary.
; 4223 :    // Note: we do this loop whether or not an adjustment is necessary
; 4224 :    //       in order to get a pointer to the last descendent.
; 4225 :    lpLastDescCsr = lpViewEntityCsr;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR _lpLastDescCsr$[ebp], ecx
$LN10@fnSetViewT:

; 4226 :    for ( ; ; )
; 4227 :    {
; 4228 :       LPVIEWENTITYCSR lpNextHierCsr;
; 4229 : 
; 4230 :       lpLastDescCsr->nLevel += nLevelChg;

	movsx	edx, WORD PTR _nLevelChg$[ebp]
	mov	eax, DWORD PTR _lpLastDescCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	add	ecx, edx
	mov	edx, DWORD PTR _lpLastDescCsr$[ebp]
	mov	WORD PTR [edx+22], cx

; 4231 :       lpNextHierCsr = zGETPTR( lpLastDescCsr->hNextHier );

	mov	eax, DWORD PTR _lpLastDescCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextHierCsr$4[ebp], eax

; 4232 :       if ( lpNextHierCsr == 0 ||

	cmp	DWORD PTR _lpNextHierCsr$4[ebp], 0
	je	SHORT $LN31@fnSetViewT
	mov	edx, DWORD PTR _lpNextHierCsr$4[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	SHORT $LN30@fnSetViewT
	mov	eax, DWORD PTR _lpNextHierCsr$4[ebp]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [eax+10]
	cmp	edx, DWORD PTR [ecx+10]
	jne	SHORT $LN30@fnSetViewT
$LN31@fnSetViewT:

; 4233 :            (lpNextHierCsr->hParent &&
; 4234 :             lpNextHierCsr->hParent == lpViewEntityCsr->hParent) )
; 4235 :       {
; 4236 :          break;

	jmp	SHORT $LN9@fnSetViewT
$LN30@fnSetViewT:

; 4237 :       }
; 4238 : 
; 4239 :       lpLastDescCsr = zGETPTR( lpLastDescCsr->hNextHier );

	mov	eax, DWORD PTR _lpLastDescCsr$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpLastDescCsr$[ebp], eax

; 4240 :    }

	jmp	SHORT $LN10@fnSetViewT
$LN9@fnSetViewT:

; 4241 : 
; 4242 :    // Set last descendent information in lpViewSubobject.
; 4243 :    lpViewSubobject->hLastDescCsr =

	push	0
	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpLastDescCsr$[ebp]
	push	eax
	call	_fnCreateEntityCsrHandle@12
	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	DWORD PTR [ecx+20], eax

; 4244 :                      fnCreateEntityCsrHandle( lpLastDescCsr, lpViewCsr, 0 );
; 4245 :    lpWorkViewEntity = zGETPTR( lpLastDescCsr->hViewEntity );

	mov	edx, DWORD PTR _lpLastDescCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWorkViewEntity$[ebp], eax

; 4246 :    lpViewSubobject->nLastDescHierNbr = lpWorkViewEntity->nHierNbr;

	mov	ecx, DWORD PTR _lpViewSubobject$[ebp]
	mov	edx, DWORD PTR _lpWorkViewEntity$[ebp]
	mov	ax, WORD PTR [edx+217]
	mov	WORD PTR [ecx+24], ax

; 4247 : 
; 4248 :    // Null the previous hierarchical pointer and parent pointer from
; 4249 :    // the target entity.
; 4250 :    lpViewEntityCsr->hParent   = 0;

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+10], 0

; 4251 :    lpViewEntityCsr->hPrevHier = 0;

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+6], 0

; 4252 :    lpLastDescCsr->hNextHier   = 0;

	mov	eax, DWORD PTR _lpLastDescCsr$[ebp]
	mov	DWORD PTR [eax+2], 0

; 4253 :    return( 0 );

	xor	eax, eax
$LN1@fnSetViewT:

; 4254 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSetViewToSubobject ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpViewOD$1 = -300					; size = 4
_lpSubtask$2 = -296					; size = 4
_lpMainOI$3 = -292					; size = 4
_lpMainOI$4 = -288					; size = 4
_lpViewOD$5 = -284					; size = 4
_lpViewCsr$ = -280					; size = 4
_pch$6 = -276						; size = 4
_lpCsrListener$7 = -272					; size = 4
_hOwningTask$ = -268					; size = 4
_lpViewOD$ = -264					; size = 4
_lpOwningApp$ = -260					; size = 4
_lpSearchTask$8 = -256					; size = 4
_lpSearchView$9 = -252					; size = 4
_lpSearchApp$10 = -248					; size = 4
_lpSearchView$11 = -244					; size = 4
_lpSearchApp$12 = -240					; size = 4
_lpSearchTask$13 = -236					; size = 4
_lpOwningTask$ = -232					; size = 4
_hView$ = -228						; size = 4
_lpSubtask$ = -224					; size = 4
_bDone$14 = -217					; size = 1
_lpNextViewName$ = -216					; size = 4
_lpPrevViewName$ = -212					; size = 4
_lpViewName$ = -208					; size = 4
_szMsg$15 = -204					; size = 200
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_fnDropView@4 PROC

; 3502 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 300				; 0000012cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3503 :    LPTASK      hOwningTask;
; 3504 :    LPTASK      lpOwningTask;
; 3505 :    LPAPP       lpOwningApp;
; 3506 :    LPSUBTASK   lpSubtask;
; 3507 :    LPVIEWCSR   lpViewCsr;
; 3508 :    LPVIEWNAME  lpViewName;
; 3509 :    LPVIEWNAME  lpPrevViewName;
; 3510 :    LPVIEWNAME  lpNextViewName;
; 3511 :    LPVIEWOD    lpViewOD;
; 3512 :    zPVOID      hView = zGETHNDL( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hView$[ebp], eax

; 3513 : 
; 3514 : #ifdef DEBUG_VIEW
; 3515 : 
; 3516 :    lpViewOD = zGETPTR( lpView->hViewOD );
; 3517 :    if ( lpViewOD && zstrcmpi( lpViewOD->szName, "TZ__PRFO" ) == 0 )
; 3518 :    {
; 3519 :       zLONG  k;
; 3520 : 
; 3521 :       TraceLine( "fnDropView: 0x%08x   LOD: %s", lpView, lpViewOD ? lpViewOD->szName : "???" );
; 3522 : 
; 3523 :       for ( k = 0; k < g_lHighWaterView; k++ )
; 3524 :       {
; 3525 :          if ( g_pvView[ k ] == (zPVOID) lpView )
; 3526 :          {
; 3527 :             g_pvView[ k ] = 0;
; 3528 :             break;
; 3529 :          }
; 3530 :       }
; 3531 : 
; 3532 :       if ( k >= zMAX_VIEW_TEST )
; 3533 :       {
; 3534 :          TraceLine( "DropView Error ... View Not Found: 0x%08x", lpView );
; 3535 :       }
; 3536 :    }
; 3537 : 
; 3538 : #endif
; 3539 : 
; 3540 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 3541 :    hOwningTask = lpView->hTask;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hOwningTask$[ebp], ecx

; 3542 :    lpOwningTask = zGETPTR( hOwningTask );

	mov	edx, DWORD PTR _hOwningTask$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 3543 : 
; 3544 :    // Remove any cursor listeners.
; 3545 :    fnCallListeners( lpView, 0 ); // first call to inform of DropView

	push	0
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCallListeners
	add	esp, 8
$LN2@fnDropView:

; 3546 :    while ( lpView->hFirstCursorListener )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+34], 0
	je	SHORT $LN3@fnDropView

; 3547 :    {
; 3548 :       LPCURSORLISTENER lpCsrListener = zGETPTR( lpView->hFirstCursorListener );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+34]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCsrListener$7[ebp], eax

; 3549 : 
; 3550 :       lpView->hFirstCursorListener = lpCsrListener->hNextCursorListener;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR _lpCsrListener$7[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+34], eax

; 3551 :       fnFreeDataspace( lpCsrListener );

	mov	ecx, DWORD PTR _lpCsrListener$7[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 3552 :    }

	jmp	SHORT $LN2@fnDropView
$LN3@fnDropView:

; 3553 : 
; 3554 :    // Check to see if the user wants to pop up a warning when a view is dropped.
; 3555 :    if ( lpView->hViewOD &&

	mov	edx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [edx+6], 0
	je	$LN35@fnDropView
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	jne	SHORT $LN36@fnDropView
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 9
	and	eax, 1
	je	$LN35@fnDropView
$LN36@fnDropView:

; 3556 :         (lpView->bFlagDropView || lpView->bTraceDropView) )
; 3557 :    {
; 3558 :       zCHAR    szMsg[ 200 ];
; 3559 :       zPCHAR   pch = ".Subtask.";

	mov	DWORD PTR _pch$6[ebp], OFFSET $SG14608

; 3560 : 
; 3561 :       if ( lpView->hViewOD )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+6], 0
	je	SHORT $LN37@fnDropView

; 3562 :       {
; 3563 :          LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$5[ebp], eax

; 3564 :          pch = lpViewOD->szName;

	mov	ecx, DWORD PTR _lpViewOD$5[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _pch$6[ebp], ecx
$LN37@fnDropView:

; 3565 :       }
; 3566 : 
; 3567 :       zsprintf( szMsg, "View about to be dropped (0x%08x).  Object Name = %s",

	mov	edx, DWORD PTR _pch$6[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	OFFSET $SG14610
	lea	ecx, DWORD PTR _szMsg$15[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 3568 :                 lpView, pch );
; 3569 :       TraceLineS( "(vm) ", szMsg );

	lea	edx, DWORD PTR _szMsg$15[ebp]
	push	edx
	push	OFFSET $SG14611
	call	_TraceLineS@8

; 3570 :       if ( lpView->bFlagDropView )

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN35@fnDropView

; 3571 :          SysMessageBox( lpView, "Core Warning", szMsg, 0 );

	push	0
	lea	edx, DWORD PTR _szMsg$15[ebp]
	push	edx
	push	OFFSET $SG14613
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMessageBox@16
$LN35@fnDropView:

; 3572 :    }
; 3573 : 
; 3574 :    if ( lpViewCsr )

	cmp	DWORD PTR _lpViewCsr$[ebp], 0
	je	SHORT $LN39@fnDropView

; 3575 :       fnDropViewCsr( lpViewCsr ); //   // dks 2006.09.18 error while cleaning up client OE

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	push	ecx
	call	_fnDropViewCsr
	add	esp, 4
$LN39@fnDropView:

; 3576 : 
; 3577 :    // If the view is the "original" view as part of optimistic locking, then
; 3578 :    // we need to flag the "main" OI that the "original" view has been dropped.
; 3579 :    // Same thing with qualification view.
; 3580 :    if ( lpView->bOrigView )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 7
	and	eax, 1
	je	SHORT $LN40@fnDropView

; 3581 :    {
; 3582 :       if ( lpView->bInvalidMainOI == FALSE )

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	shr	edx, 4
	and	edx, 1
	jne	SHORT $LN42@fnDropView

; 3583 :       {
; 3584 :          LPVIEWOI lpMainOI = zGETPTR( lpView->hMainOI );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMainOI$4[ebp], eax

; 3585 : 
; 3586 :          lpMainOI->vOriginalOI = 0;

	mov	edx, DWORD PTR _lpMainOI$4[ebp]
	mov	DWORD PTR [edx+40], 0

; 3587 :          lpView->bOrigView = FALSE;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	and	ecx, -129				; ffffff7fH
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+30], ecx

; 3588 :       }

	jmp	SHORT $LN43@fnDropView
$LN42@fnDropView:

; 3589 :       else
; 3590 :          SysMessageBox( lpView, "fnDropView Error", "MainOI Invalid", 0 );

	push	0
	push	OFFSET $SG14619
	push	OFFSET $SG14620
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMessageBox@16
$LN43@fnDropView:

; 3591 :    }

	jmp	SHORT $LN41@fnDropView
$LN40@fnDropView:

; 3592 :    else
; 3593 :    if ( lpView->bQualView )

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	shr	edx, 8
	and	edx, 1
	je	SHORT $LN41@fnDropView

; 3594 :    {
; 3595 :       if ( lpView->bInvalidMainOI == FALSE )

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 4
	and	ecx, 1
	jne	SHORT $LN45@fnDropView

; 3596 :       {
; 3597 :          LPVIEWOI lpMainOI = zGETPTR( lpView->hMainOI );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMainOI$3[ebp], eax

; 3598 : 
; 3599 :          lpMainOI->vQualOI = 0;

	mov	ecx, DWORD PTR _lpMainOI$3[ebp]
	mov	DWORD PTR [ecx+44], 0

; 3600 :          lpView->bQualView = FALSE;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	and	eax, -257				; fffffeffH
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 3601 :       }

	jmp	SHORT $LN41@fnDropView
$LN45@fnDropView:

; 3602 :       else
; 3603 :          SysMessageBox( lpView, "fnDropView Error", "Unexpected Invalid MainOI", 0 );

	push	0
	push	OFFSET $SG14624
	push	OFFSET $SG14625
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysMessageBox@16
$LN41@fnDropView:

; 3604 :    }
; 3605 : 
; 3606 :    // If the view is a subtask view, do not unchain it NOR remove it
; 3607 :    // from the task chain, simply NULL the ViewCsr pointer.
; 3608 :    if ( lpView->hSubtask )

	mov	eax, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [eax+18], 0
	je	SHORT $LN47@fnDropView

; 3609 :    {
; 3610 :       lpView->hViewCsr = 0;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+10], 0

; 3611 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnDropView
$LN47@fnDropView:

; 3612 :    }
; 3613 : 
; 3614 :    // Drop all names for the view 1: first go through all the subtasks and
; 3615 :    // find all names for the view at any subtask level within the task.
; 3616 :    if ( lpView->nViewNames )

	mov	edx, DWORD PTR _lpView$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	je	$LN48@fnDropView

; 3617 :    {
; 3618 :       lpSubtask = zGETPTR( lpOwningTask->hFirstSubtask );

	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax
$LN4@fnDropView:

; 3619 :       while ( lpSubtask )

	cmp	DWORD PTR _lpSubtask$[ebp], 0
	je	$LN48@fnDropView

; 3620 :       {
; 3621 :          lpPrevViewName = 0;

	mov	DWORD PTR _lpPrevViewName$[ebp], 0

; 3622 :          lpViewName = zGETPTR( lpSubtask->hFirstViewName );

	mov	eax, DWORD PTR _lpSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN6@fnDropView:

; 3623 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	$LN7@fnDropView

; 3624 :          {
; 3625 :             lpNextViewName = zGETPTR( lpViewName->hNextViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextViewName$[ebp], eax

; 3626 :             if ( lpViewName->hView == hView )

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN49@fnDropView

; 3627 :             {
; 3628 :                if ( lpPrevViewName )

	cmp	DWORD PTR _lpPrevViewName$[ebp], 0
	je	SHORT $LN51@fnDropView

; 3629 :                   lpPrevViewName->hNextViewName = zGETHNDL( lpNextViewName );

	mov	eax, DWORD PTR _lpNextViewName$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpPrevViewName$[ebp]
	mov	DWORD PTR [ecx+6], eax
	jmp	SHORT $LN52@fnDropView
$LN51@fnDropView:

; 3630 :                else
; 3631 :                   lpSubtask->hFirstViewName = zGETHNDL( lpNextViewName );

	mov	edx, DWORD PTR _lpNextViewName$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSubtask$[ebp]
	mov	DWORD PTR [ecx+18], eax
$LN52@fnDropView:

; 3632 : 
; 3633 :                lpView->nViewNames--;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [ecx+22], ax

; 3634 :                fnFreeDataspace( lpViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 3635 :                if ( lpView->nViewNames == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	jne	SHORT $LN53@fnDropView

; 3636 :                   break;

	jmp	SHORT $LN7@fnDropView
$LN53@fnDropView:

; 3637 :             }

	jmp	SHORT $LN50@fnDropView
$LN49@fnDropView:

; 3638 :             else
; 3639 :                lpPrevViewName = lpViewName;

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR _lpPrevViewName$[ebp], edx
$LN50@fnDropView:

; 3640 : 
; 3641 :             lpViewName = lpNextViewName;

	mov	eax, DWORD PTR _lpNextViewName$[ebp]
	mov	DWORD PTR _lpViewName$[ebp], eax

; 3642 :          }

	jmp	$LN6@fnDropView
$LN7@fnDropView:

; 3643 : 
; 3644 :          if ( lpView->nViewNames == 0 )

	mov	ecx, DWORD PTR _lpView$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	jne	SHORT $LN54@fnDropView

; 3645 :             break;

	jmp	SHORT $LN48@fnDropView
$LN54@fnDropView:

; 3646 : 
; 3647 :          lpSubtask = zGETPTR( lpSubtask->hNextSubtask );

	mov	eax, DWORD PTR _lpSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 3648 :       }

	jmp	$LN4@fnDropView
$LN48@fnDropView:

; 3649 :    }
; 3650 : 
; 3651 :    // Drop all names for the view 2: if a name was created at the task
; 3652 :    // level, go through all names for the owning task and delete any
; 3653 :    // names found for the current view.
; 3654 :    if ( lpView->nViewNames && lpView->bTaskNamed )

	mov	edx, DWORD PTR _lpView$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	je	$LN55@fnDropView
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	and	edx, 1
	je	$LN55@fnDropView

; 3655 :    {
; 3656 :       lpPrevViewName = 0;

	mov	DWORD PTR _lpPrevViewName$[ebp], 0

; 3657 :       lpViewName = zGETPTR( lpOwningTask->hFirstViewName );

	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	mov	ecx, DWORD PTR [eax+110]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN8@fnDropView:

; 3658 :       while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	$LN55@fnDropView

; 3659 :       {
; 3660 :          lpNextViewName = zGETPTR( lpViewName->hNextViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextViewName$[ebp], eax

; 3661 :          if ( lpViewName->hView == hView )

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN56@fnDropView

; 3662 :          {
; 3663 :             if ( lpPrevViewName )

	cmp	DWORD PTR _lpPrevViewName$[ebp], 0
	je	SHORT $LN58@fnDropView

; 3664 :                lpPrevViewName->hNextViewName = zGETHNDL( lpNextViewName );

	mov	eax, DWORD PTR _lpNextViewName$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpPrevViewName$[ebp]
	mov	DWORD PTR [ecx+6], eax
	jmp	SHORT $LN59@fnDropView
$LN58@fnDropView:

; 3665 :             else
; 3666 :                lpOwningTask->hFirstViewName = zGETHNDL( lpNextViewName );

	mov	edx, DWORD PTR _lpNextViewName$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	mov	DWORD PTR [ecx+110], eax
$LN59@fnDropView:

; 3667 : 
; 3668 :             lpView->nViewNames--;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [ecx+22], ax

; 3669 :             fnFreeDataspace( lpViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 3670 :             if ( lpView->nViewNames == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	jne	SHORT $LN60@fnDropView

; 3671 :                break;

	jmp	SHORT $LN55@fnDropView
$LN60@fnDropView:

; 3672 :          }

	jmp	SHORT $LN57@fnDropView
$LN56@fnDropView:

; 3673 :          else
; 3674 :             lpPrevViewName = lpViewName;

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR _lpPrevViewName$[ebp], edx
$LN57@fnDropView:

; 3675 : 
; 3676 :          lpViewName = lpNextViewName;

	mov	eax, DWORD PTR _lpNextViewName$[ebp]
	mov	DWORD PTR _lpViewName$[ebp], eax

; 3677 :       }

	jmp	$LN8@fnDropView
$LN55@fnDropView:

; 3678 :    }
; 3679 : 
; 3680 :    // Drop all names for the view 3: if a name was created at the
; 3681 :    // application level, go through all names for the application
; 3682 :    // and delete any names found for the current view.
; 3683 :    if ( lpView->nViewNames && lpView->bApplicationNamed )

	mov	ecx, DWORD PTR _lpView$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	je	$LN61@fnDropView
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 1
	and	ecx, 1
	je	$LN61@fnDropView

; 3684 :    {
; 3685 :       if ( lpView->hSubtask )

	mov	edx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $LN62@fnDropView

; 3686 :       {
; 3687 :          LPSUBTASK lpSubtask = zGETPTR( lpView->hSubtask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$2[ebp], eax

; 3688 : 
; 3689 :          lpOwningApp = zGETPTR( lpSubtask->hApp );

	mov	edx, DWORD PTR _lpSubtask$2[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningApp$[ebp], eax

; 3690 :       }

	jmp	SHORT $LN63@fnDropView
$LN62@fnDropView:

; 3691 :       else
; 3692 :       if ( lpView->hViewOD )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+6], 0
	je	SHORT $LN64@fnDropView

; 3693 :       {
; 3694 :          LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 3695 : 
; 3696 :          lpOwningApp = zGETPTR( lpViewOD->hApp );

	mov	ecx, DWORD PTR _lpViewOD$1[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningApp$[ebp], eax

; 3697 :       }

	jmp	SHORT $LN63@fnDropView
$LN64@fnDropView:

; 3698 :       else
; 3699 :          lpOwningApp = zGETPTR( lpOwningTask->hApp );

	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningApp$[ebp], eax
$LN63@fnDropView:

; 3700 : 
; 3701 :       lpPrevViewName = 0;

	mov	DWORD PTR _lpPrevViewName$[ebp], 0

; 3702 :       lpViewName = zGETPTR( lpOwningApp->hFirstViewName );

	mov	edx, DWORD PTR _lpOwningApp$[ebp]
	mov	eax, DWORD PTR [edx+1893]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN10@fnDropView:

; 3703 :       while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	$LN61@fnDropView

; 3704 :       {
; 3705 :          lpNextViewName = zGETPTR( lpViewName->hNextViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextViewName$[ebp], eax

; 3706 :          if ( lpViewName->hView == hView )

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN66@fnDropView

; 3707 :          {
; 3708 :             if ( lpPrevViewName )

	cmp	DWORD PTR _lpPrevViewName$[ebp], 0
	je	SHORT $LN68@fnDropView

; 3709 :                lpPrevViewName->hNextViewName = zGETHNDL( lpNextViewName );

	mov	edx, DWORD PTR _lpNextViewName$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpPrevViewName$[ebp]
	mov	DWORD PTR [ecx+6], eax
	jmp	SHORT $LN69@fnDropView
$LN68@fnDropView:

; 3710 :             else
; 3711 :                lpOwningApp->hFirstViewName = zGETHNDL( lpNextViewName );

	mov	edx, DWORD PTR _lpNextViewName$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpOwningApp$[ebp]
	mov	DWORD PTR [ecx+1893], eax
$LN69@fnDropView:

; 3712 : 
; 3713 :             lpView->nViewNames--;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [ecx+22], ax

; 3714 :             fnFreeDataspace( lpViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 3715 :             if ( lpView->nViewNames == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	jne	SHORT $LN70@fnDropView

; 3716 :                break;

	jmp	SHORT $LN61@fnDropView
$LN70@fnDropView:

; 3717 :          }

	jmp	SHORT $LN67@fnDropView
$LN66@fnDropView:

; 3718 :          else
; 3719 :             lpPrevViewName = lpViewName;

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR _lpPrevViewName$[ebp], edx
$LN67@fnDropView:

; 3720 : 
; 3721 :          lpViewName = lpNextViewName;

	mov	eax, DWORD PTR _lpNextViewName$[ebp]
	mov	DWORD PTR _lpViewName$[ebp], eax

; 3722 :       }

	jmp	$LN10@fnDropView
$LN61@fnDropView:

; 3723 :    }
; 3724 : 
; 3725 :    // Drop all names for the view 4: if a name was created at
; 3726 :    // the system level, go through all names for the system
; 3727 :    // and delete any names found for the current view.
; 3728 :    if ( lpView->nViewNames && lpView->bSystemNamed )

	mov	ecx, DWORD PTR _lpView$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	je	$LN71@fnDropView
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 2
	and	ecx, 1
	je	$LN71@fnDropView

; 3729 :    {
; 3730 :       zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 3731 : 
; 3732 :       lpPrevViewName = 0;

	mov	DWORD PTR _lpPrevViewName$[ebp], 0

; 3733 :       lpViewName = zGETPTR( AnchorBlock->hFirstViewName );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1489]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN12@fnDropView:

; 3734 :       while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	$LN13@fnDropView

; 3735 :       {
; 3736 :          lpNextViewName = zGETPTR( lpViewName->hNextViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextViewName$[ebp], eax

; 3737 :          if ( lpViewName->hView == hView )

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN72@fnDropView

; 3738 :          {
; 3739 :             if ( lpPrevViewName )

	cmp	DWORD PTR _lpPrevViewName$[ebp], 0
	je	SHORT $LN74@fnDropView

; 3740 :                lpPrevViewName->hNextViewName = zGETHNDL( lpNextViewName );

	mov	edx, DWORD PTR _lpNextViewName$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpPrevViewName$[ebp]
	mov	DWORD PTR [ecx+6], eax
	jmp	SHORT $LN75@fnDropView
$LN74@fnDropView:

; 3741 :             else
; 3742 :                AnchorBlock->hFirstViewName = zGETHNDL( lpNextViewName );

	mov	edx, DWORD PTR _lpNextViewName$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _AnchorBlock
	mov	DWORD PTR [ecx+1489], eax
$LN75@fnDropView:

; 3743 : 
; 3744 :             lpView->nViewNames--;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [ecx+22], ax

; 3745 :             fnFreeDataspace( lpViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 3746 :             if ( lpView->nViewNames == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	jne	SHORT $LN76@fnDropView

; 3747 :                break;

	jmp	SHORT $LN13@fnDropView
$LN76@fnDropView:

; 3748 :          }

	jmp	SHORT $LN73@fnDropView
$LN72@fnDropView:

; 3749 :          else
; 3750 :             lpPrevViewName = lpViewName;

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR _lpPrevViewName$[ebp], edx
$LN73@fnDropView:

; 3751 : 
; 3752 :          lpViewName = lpNextViewName;

	mov	eax, DWORD PTR _lpNextViewName$[ebp]
	mov	DWORD PTR _lpViewName$[ebp], eax

; 3753 :       }

	jmp	$LN12@fnDropView
$LN13@fnDropView:

; 3754 : 
; 3755 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN71@fnDropView:

; 3756 :    }
; 3757 : 
; 3758 :    // Drop all names for the view 5: if a name was created at the task
; 3759 :    // level, go through all tasks other than the owning task and see
; 3760 :    // if the view can be found in one of them.
; 3761 :    if ( lpView->nViewNames && lpView->bTaskNamed )

	mov	ecx, DWORD PTR _lpView$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	je	$LN77@fnDropView
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	and	ecx, 1
	je	$LN77@fnDropView

; 3762 :    {
; 3763 :       LPTASK lpSearchTask;
; 3764 : 
; 3765 :       // Make sure nobody else is deleting a task.
; 3766 :       fnStartBrowseOfTaskList( lpView->hTask, FALSE );

	push	0
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	_fnStartBrowseOfTaskList@8

; 3767 : 
; 3768 :       lpSearchTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+130]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$13[ebp], eax
$LN14@fnDropView:

; 3769 :       while ( lpSearchTask )

	cmp	DWORD PTR _lpSearchTask$13[ebp], 0
	je	$LN15@fnDropView

; 3770 :       {
; 3771 :          if ( lpSearchTask != lpOwningTask )

	mov	eax, DWORD PTR _lpSearchTask$13[ebp]
	cmp	eax, DWORD PTR _lpOwningTask$[ebp]
	je	$LN78@fnDropView

; 3772 :          {
; 3773 :             lpPrevViewName = 0;

	mov	DWORD PTR _lpPrevViewName$[ebp], 0

; 3774 :             lpViewName = zGETPTR( lpSearchTask->hFirstViewName );

	mov	ecx, DWORD PTR _lpSearchTask$13[ebp]
	mov	edx, DWORD PTR [ecx+110]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN16@fnDropView:

; 3775 :             while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	$LN78@fnDropView

; 3776 :             {
; 3777 :                lpNextViewName = zGETPTR( lpViewName->hNextViewName );

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextViewName$[ebp], eax

; 3778 :                if ( lpViewName->hView == hView )

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+2]
	cmp	eax, DWORD PTR _hView$[ebp]
	jne	SHORT $LN79@fnDropView

; 3779 :                {
; 3780 :                   if ( lpPrevViewName )

	cmp	DWORD PTR _lpPrevViewName$[ebp], 0
	je	SHORT $LN81@fnDropView

; 3781 :                      lpPrevViewName->hNextViewName = zGETHNDL( lpNextViewName );

	mov	ecx, DWORD PTR _lpNextViewName$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpPrevViewName$[ebp]
	mov	DWORD PTR [edx+6], eax
	jmp	SHORT $LN82@fnDropView
$LN81@fnDropView:

; 3782 :                   else
; 3783 :                      lpSearchTask->hFirstViewName = zGETHNDL( lpNextViewName );

	mov	eax, DWORD PTR _lpNextViewName$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSearchTask$13[ebp]
	mov	DWORD PTR [ecx+110], eax
$LN82@fnDropView:

; 3784 : 
; 3785 :                   lpView->nViewNames--;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [ecx+22], ax

; 3786 :                   fnFreeDataspace( lpViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 3787 :                   if ( lpView->nViewNames == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	jne	SHORT $LN83@fnDropView

; 3788 :                      break;

	jmp	SHORT $LN78@fnDropView
$LN83@fnDropView:

; 3789 :                }

	jmp	SHORT $LN80@fnDropView
$LN79@fnDropView:

; 3790 :                else
; 3791 :                   lpPrevViewName = lpViewName;

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR _lpPrevViewName$[ebp], edx
$LN80@fnDropView:

; 3792 : 
; 3793 :                lpViewName = lpNextViewName;

	mov	eax, DWORD PTR _lpNextViewName$[ebp]
	mov	DWORD PTR _lpViewName$[ebp], eax

; 3794 :             }

	jmp	$LN16@fnDropView
$LN78@fnDropView:

; 3795 :          }
; 3796 :          if ( lpView->nViewNames == 0 )

	mov	ecx, DWORD PTR _lpView$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	jne	SHORT $LN84@fnDropView

; 3797 :             break;

	jmp	SHORT $LN15@fnDropView
$LN84@fnDropView:

; 3798 : 
; 3799 :          lpSearchTask = zGETPTR( lpSearchTask->hNextTask );

	mov	eax, DWORD PTR _lpSearchTask$13[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$13[ebp], eax

; 3800 :       }

	jmp	$LN14@fnDropView
$LN15@fnDropView:

; 3801 : 
; 3802 :       fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4
$LN77@fnDropView:

; 3803 :    }
; 3804 : 
; 3805 :    // Drop all names for the view 6: if a name still exists at this
; 3806 :    // point, then it must exist in a subtask for another task, search
; 3807 :    // all subtasks in the other tasks for a name for this view.
; 3808 :    if ( lpView->nViewNames )

	mov	edx, DWORD PTR _lpView$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	je	$LN85@fnDropView

; 3809 :    {
; 3810 :       LPTASK lpSearchTask;
; 3811 : 
; 3812 :       // Make sure nobody else is deleting a task.
; 3813 :       fnStartBrowseOfTaskList( lpView->hTask, FALSE );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	_fnStartBrowseOfTaskList@8

; 3814 : 
; 3815 :       lpSearchTask = zGETPTR( AnchorBlock->hFirstTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+130]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$8[ebp], eax
$LN18@fnDropView:

; 3816 :       while ( lpSearchTask )

	cmp	DWORD PTR _lpSearchTask$8[ebp], 0
	je	$LN19@fnDropView

; 3817 :       {
; 3818 :          if ( lpSearchTask != lpOwningTask )

	mov	edx, DWORD PTR _lpSearchTask$8[ebp]
	cmp	edx, DWORD PTR _lpOwningTask$[ebp]
	je	$LN86@fnDropView

; 3819 :          {
; 3820 :             lpSubtask = zGETPTR( lpSearchTask->hFirstSubtask );

	mov	eax, DWORD PTR _lpSearchTask$8[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax
$LN20@fnDropView:

; 3821 :             while ( lpSubtask )

	cmp	DWORD PTR _lpSubtask$[ebp], 0
	je	$LN86@fnDropView

; 3822 :             {
; 3823 :                lpPrevViewName = 0;

	mov	DWORD PTR _lpPrevViewName$[ebp], 0

; 3824 :                lpViewName = zGETPTR( lpSubtask->hFirstViewName );

	mov	edx, DWORD PTR _lpSubtask$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN22@fnDropView:

; 3825 :                while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	$LN23@fnDropView

; 3826 :                {
; 3827 :                   lpNextViewName = zGETPTR( lpViewName->hNextViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextViewName$[ebp], eax

; 3828 :                   if ( lpViewName->hView == hView )

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN87@fnDropView

; 3829 :                   {
; 3830 :                      if ( lpPrevViewName )

	cmp	DWORD PTR _lpPrevViewName$[ebp], 0
	je	SHORT $LN89@fnDropView

; 3831 :                         lpPrevViewName->hNextViewName = zGETHNDL( lpNextViewName );

	mov	edx, DWORD PTR _lpNextViewName$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpPrevViewName$[ebp]
	mov	DWORD PTR [ecx+6], eax
	jmp	SHORT $LN90@fnDropView
$LN89@fnDropView:

; 3832 :                      else
; 3833 :                         lpSubtask->hFirstViewName = zGETHNDL( lpNextViewName );

	mov	edx, DWORD PTR _lpNextViewName$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSubtask$[ebp]
	mov	DWORD PTR [ecx+18], eax
$LN90@fnDropView:

; 3834 : 
; 3835 :                      lpView->nViewNames--;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [ecx+22], ax

; 3836 :                      fnFreeDataspace( lpViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 3837 :                      if ( lpView->nViewNames == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	jne	SHORT $LN91@fnDropView

; 3838 :                         break;

	jmp	SHORT $LN23@fnDropView
$LN91@fnDropView:

; 3839 :                   }

	jmp	SHORT $LN88@fnDropView
$LN87@fnDropView:

; 3840 :                   else
; 3841 :                      lpPrevViewName = lpViewName;

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR _lpPrevViewName$[ebp], edx
$LN88@fnDropView:

; 3842 : 
; 3843 :                   lpViewName = lpNextViewName;

	mov	eax, DWORD PTR _lpNextViewName$[ebp]
	mov	DWORD PTR _lpViewName$[ebp], eax

; 3844 :                }

	jmp	$LN22@fnDropView
$LN23@fnDropView:

; 3845 : 
; 3846 :                if ( lpView->nViewNames == 0 )

	mov	ecx, DWORD PTR _lpView$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	jne	SHORT $LN92@fnDropView

; 3847 :                   break;

	jmp	SHORT $LN86@fnDropView
$LN92@fnDropView:

; 3848 : 
; 3849 :                lpSubtask = zGETPTR( lpSubtask->hNextSubtask );

	mov	eax, DWORD PTR _lpSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 3850 :             }

	jmp	$LN20@fnDropView
$LN86@fnDropView:

; 3851 :          }
; 3852 : 
; 3853 :          if ( lpView->nViewNames == 0 )

	mov	edx, DWORD PTR _lpView$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	jne	SHORT $LN93@fnDropView

; 3854 :             break;

	jmp	SHORT $LN19@fnDropView
$LN93@fnDropView:

; 3855 : 
; 3856 :          lpSearchTask = zGETPTR( lpSearchTask->hNextTask );

	mov	ecx, DWORD PTR _lpSearchTask$8[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchTask$8[ebp], eax

; 3857 :       }

	jmp	$LN18@fnDropView
$LN19@fnDropView:

; 3858 : 
; 3859 :       fnEndBrowseOfTaskList( FALSE );

	push	0
	call	_fnEndBrowseOfTaskList@4
$LN85@fnDropView:

; 3860 :    }
; 3861 : 
; 3862 :    // Drop all names for the view 7: if a name was created at the
; 3863 :    // application level, go through all apps other than the owning
; 3864 :    // app and see if the view can be found in one of them.
; 3865 :    if ( lpView->nViewNames && lpView->bApplicationNamed )

	mov	eax, DWORD PTR _lpView$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	je	$LN94@fnDropView
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 1
	and	eax, 1
	je	$LN94@fnDropView

; 3866 :    {
; 3867 :       LPAPP  lpSearchApp;
; 3868 : 
; 3869 :       zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 3870 : 
; 3871 :       lpSearchApp = zGETPTR( AnchorBlock->hFirstApp );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+126]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchApp$12[ebp], eax
$LN24@fnDropView:

; 3872 :       while ( lpSearchApp )

	cmp	DWORD PTR _lpSearchApp$12[ebp], 0
	je	$LN25@fnDropView

; 3873 :       {
; 3874 :          if ( lpSearchApp != lpOwningApp )

	mov	eax, DWORD PTR _lpSearchApp$12[ebp]
	cmp	eax, DWORD PTR _lpOwningApp$[ebp]
	je	$LN95@fnDropView

; 3875 :          {
; 3876 :             lpPrevViewName = 0;

	mov	DWORD PTR _lpPrevViewName$[ebp], 0

; 3877 :             lpViewName = zGETPTR( lpSearchApp->hFirstViewName );

	mov	ecx, DWORD PTR _lpSearchApp$12[ebp]
	mov	edx, DWORD PTR [ecx+1893]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN26@fnDropView:

; 3878 :             while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	$LN95@fnDropView

; 3879 :             {
; 3880 :                lpNextViewName = zGETPTR( lpViewName->hNextViewName );

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextViewName$[ebp], eax

; 3881 :                if ( lpViewName->hView == hView )

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+2]
	cmp	eax, DWORD PTR _hView$[ebp]
	jne	SHORT $LN96@fnDropView

; 3882 :                {
; 3883 :                   if ( lpPrevViewName )

	cmp	DWORD PTR _lpPrevViewName$[ebp], 0
	je	SHORT $LN98@fnDropView

; 3884 :                      lpPrevViewName->hNextViewName = zGETHNDL( lpNextViewName );

	mov	ecx, DWORD PTR _lpNextViewName$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpPrevViewName$[ebp]
	mov	DWORD PTR [edx+6], eax
	jmp	SHORT $LN99@fnDropView
$LN98@fnDropView:

; 3885 :                   else
; 3886 :                      lpSearchApp->hFirstViewName = zGETHNDL( lpNextViewName );

	mov	eax, DWORD PTR _lpNextViewName$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSearchApp$12[ebp]
	mov	DWORD PTR [ecx+1893], eax
$LN99@fnDropView:

; 3887 : 
; 3888 :                   lpView->nViewNames--;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [ecx+22], ax

; 3889 :                   fnFreeDataspace( lpViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 3890 :                   if ( lpView->nViewNames == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	test	ecx, ecx
	jne	SHORT $LN100@fnDropView

; 3891 :                      break;

	jmp	SHORT $LN95@fnDropView
$LN100@fnDropView:

; 3892 :                }

	jmp	SHORT $LN97@fnDropView
$LN96@fnDropView:

; 3893 :                else
; 3894 :                   lpPrevViewName = lpViewName;

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR _lpPrevViewName$[ebp], edx
$LN97@fnDropView:

; 3895 : 
; 3896 :                lpViewName = lpNextViewName;

	mov	eax, DWORD PTR _lpNextViewName$[ebp]
	mov	DWORD PTR _lpViewName$[ebp], eax

; 3897 :             }

	jmp	$LN26@fnDropView
$LN95@fnDropView:

; 3898 :          }
; 3899 : 
; 3900 :          if ( lpView->nViewNames == 0 )

	mov	ecx, DWORD PTR _lpView$[ebp]
	movsx	edx, WORD PTR [ecx+22]
	test	edx, edx
	jne	SHORT $LN101@fnDropView

; 3901 :             break;

	jmp	SHORT $LN25@fnDropView
$LN101@fnDropView:

; 3902 : 
; 3903 :          lpSearchApp = zGETPTR( lpSearchApp->hNextApp );

	mov	eax, DWORD PTR _lpSearchApp$12[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchApp$12[ebp], eax

; 3904 :       }

	jmp	$LN24@fnDropView
$LN25@fnDropView:

; 3905 : 
; 3906 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN94@fnDropView:

; 3907 :    }
; 3908 : 
; 3909 :    // Whew, end of view name cleanup code.  If there is still a name here,
; 3910 :    // issue an internal name cleanup error.
; 3911 :    if ( lpView->nViewNames )

	mov	edx, DWORD PTR _lpView$[ebp]
	movsx	eax, WORD PTR [edx+22]
	test	eax, eax
	je	SHORT $LN102@fnDropView

; 3912 :       SysMessageBox( lpView, "Error", "(vm) Name cleanup error", 1 );

	push	1
	push	OFFSET $SG14682
	push	OFFSET $SG14683
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_SysMessageBox@16
$LN102@fnDropView:

; 3913 : 
; 3914 :    // Unchain the view from its view chain, either in the task or app.
; 3915 :    //
; 3916 :    // Check to see if view is part of application chain and unchain it
; 3917 :    // if it is.
; 3918 :    if ( lpView->bApplicationView )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 3
	and	eax, 1
	je	$LN103@fnDropView

; 3919 :    {
; 3920 :       LPAPP  lpSearchApp;
; 3921 :       zBOOL  bDone = 0;

	mov	BYTE PTR _bDone$14[ebp], 0

; 3922 : 
; 3923 :       zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 3924 : 
; 3925 :       lpSearchApp = zGETPTR( AnchorBlock->hFirstApp );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+126]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchApp$10[ebp], eax
$LN28@fnDropView:

; 3926 :       while ( lpSearchApp && bDone == FALSE )

	cmp	DWORD PTR _lpSearchApp$10[ebp], 0
	je	$LN29@fnDropView
	movzx	eax, BYTE PTR _bDone$14[ebp]
	test	eax, eax
	jne	$LN29@fnDropView

; 3927 :       {
; 3928 :          zVIEW  lpSearchView;
; 3929 : 
; 3930 :          if ( lpSearchApp->hFirstView == hView )

	mov	ecx, DWORD PTR _lpSearchApp$10[ebp]
	mov	edx, DWORD PTR [ecx+1889]
	cmp	edx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN105@fnDropView

; 3931 :          {
; 3932 :             // Unchain view from view chain.
; 3933 :             lpSearchApp->hFirstView = lpView->hNextView;

	mov	eax, DWORD PTR _lpSearchApp$10[ebp]
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+1889], edx

; 3934 :             bDone = TRUE;

	mov	BYTE PTR _bDone$14[ebp], 1

; 3935 :          }

	jmp	$LN106@fnDropView
$LN105@fnDropView:

; 3936 :          else
; 3937 :          {
; 3938 :             lpSearchView = zGETPTR( lpSearchApp->hFirstView );

	mov	eax, DWORD PTR _lpSearchApp$10[ebp]
	mov	ecx, DWORD PTR [eax+1889]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchView$11[ebp], eax

; 3939 :             if ( lpSearchView )

	cmp	DWORD PTR _lpSearchView$11[ebp], 0
	je	SHORT $LN107@fnDropView
$LN30@fnDropView:

; 3940 :             {
; 3941 :                while ( lpSearchView->hNextView && bDone == FALSE )

	mov	edx, DWORD PTR _lpSearchView$11[ebp]
	cmp	DWORD PTR [edx+2], 0
	je	SHORT $LN107@fnDropView
	movzx	eax, BYTE PTR _bDone$14[ebp]
	test	eax, eax
	jne	SHORT $LN107@fnDropView

; 3942 :                {
; 3943 :                   if ( lpSearchView->hNextView == hView )

	mov	ecx, DWORD PTR _lpSearchView$11[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN108@fnDropView

; 3944 :                   {
; 3945 :                      // Unchain view from view chain.
; 3946 :                      lpSearchView->hNextView = lpView->hNextView;

	mov	eax, DWORD PTR _lpSearchView$11[ebp]
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+2], edx

; 3947 :                      bDone = TRUE;

	mov	BYTE PTR _bDone$14[ebp], 1

; 3948 :                   }

	jmp	SHORT $LN109@fnDropView
$LN108@fnDropView:

; 3949 :                   else
; 3950 :                      lpSearchView = zGETPTR( lpSearchView->hNextView );

	mov	eax, DWORD PTR _lpSearchView$11[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchView$11[ebp], eax
$LN109@fnDropView:

; 3951 :                }

	jmp	SHORT $LN30@fnDropView
$LN107@fnDropView:

; 3952 :             }
; 3953 : 
; 3954 :             lpSearchApp = zGETPTR( lpSearchApp->hNextApp );

	mov	edx, DWORD PTR _lpSearchApp$10[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchApp$10[ebp], eax
$LN106@fnDropView:

; 3955 :          }
; 3956 :       }  // while...

	jmp	$LN28@fnDropView
$LN29@fnDropView:

; 3957 : 
; 3958 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 3959 : 
; 3960 :    } // if ( lpView->bApplicationView )...

	jmp	$LN104@fnDropView
$LN103@fnDropView:

; 3961 :    else
; 3962 :    {
; 3963 :       if ( hOwningTask == AnchorBlock->hMainTask )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _hOwningTask$[ebp]
	cmp	edx, DWORD PTR [ecx+106]
	jne	SHORT $LN110@fnDropView

; 3964 :          zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4
$LN110@fnDropView:

; 3965 : 
; 3966 :       // View is not part of application chain ... unchain from owning task.
; 3967 :       if ( lpOwningTask->hFirstView == hView )

	mov	eax, DWORD PTR _lpOwningTask$[ebp]
	mov	ecx, DWORD PTR [eax+106]
	cmp	ecx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN111@fnDropView

; 3968 :          lpOwningTask->hFirstView = lpView->hNextView;

	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+106], ecx
	jmp	SHORT $LN112@fnDropView
$LN111@fnDropView:

; 3969 :       else
; 3970 :       {
; 3971 :          zVIEW  lpSearchView;
; 3972 : 
; 3973 :          // Repair the view chain.
; 3974 :          for ( lpSearchView = zGETPTR( lpOwningTask->hFirstView );

	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchView$9[ebp], eax
	jmp	SHORT $LN34@fnDropView
$LN32@fnDropView:

; 3976 :                lpSearchView = zGETPTR( lpSearchView->hNextView ) )

	mov	ecx, DWORD PTR _lpSearchView$9[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchView$9[ebp], eax
$LN34@fnDropView:

; 3975 :                lpSearchView && lpSearchView->hNextView != hView;

	cmp	DWORD PTR _lpSearchView$9[ebp], 0
	je	SHORT $LN33@fnDropView
	mov	eax, DWORD PTR _lpSearchView$9[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hView$[ebp]
	je	SHORT $LN33@fnDropView

; 3977 :          {
; 3978 :             // Nothing needs to be done here.
; 3979 :          }

	jmp	SHORT $LN32@fnDropView
$LN33@fnDropView:

; 3980 : 
; 3981 :          if ( lpSearchView )

	cmp	DWORD PTR _lpSearchView$9[ebp], 0
	je	SHORT $LN112@fnDropView

; 3982 :             lpSearchView->hNextView = lpView->hNextView;

	mov	edx, DWORD PTR _lpSearchView$9[ebp]
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR [edx+2], ecx
$LN112@fnDropView:

; 3983 :       }
; 3984 : 
; 3985 :       if ( hOwningTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR _hOwningTask$[ebp]
	cmp	eax, DWORD PTR [edx+106]
	jne	SHORT $LN104@fnDropView

; 3986 :          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN104@fnDropView:

; 3987 : 
; 3988 :    }  // if ( lpView->bApplicationView )...else...
; 3989 : 
; 3990 :    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 3991 : 
; 3992 :    // If the ViewOD is flagged as deprecated, let's see if we can remove it.
; 3993 :    if ( lpViewOD && lpViewOD->bDeprecated &&

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	je	SHORT $LN115@fnDropView
	mov	eax, DWORD PTR _lpViewOD$[ebp]
	mov	ecx, DWORD PTR [eax+240]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN115@fnDropView
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnCheckIfViewOD_IsUsed@8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN115@fnDropView

; 3994 :         fnCheckIfViewOD_IsUsed( lpView, lpViewOD ) == 0 )
; 3995 :    {
; 3996 :       // View is not used by any tasks so it's safe to remove it.
; 3997 :       zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 3998 :       fnDeleteViewObject ( lpViewOD );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	push	edx
	call	_fnDeleteViewObject@4

; 3999 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN115@fnDropView:

; 4000 :    }
; 4001 : 
; 4002 :    // Finally, free the dataspace for the view.
; 4003 :    fnFreeDataspace( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 4004 :    return( 0 );

	xor	eax, eax
$LN1@fnDropView:

; 4005 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnDropView@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpTempParent$1 = -112					; size = 4
_lpTask$2 = -108					; size = 4
_lpOwningTask$ = -104					; size = 4
_ulViewSize$ = -100					; size = 4
_lpTgtViewOI$ = -96					; size = 4
_szName1$3 = -92					; size = 4
_szName2$4 = -88					; size = 4
_lpTgtViewOD$ = -84					; size = 4
_lEntities$5 = -80					; size = 4
_hNewViewSubobject$6 = -76				; size = 4
_hParentViewEntityCsr$7 = -72				; size = 4
_lpParentViewEntityCsr$8 = -68				; size = 4
_lpSrcViewOI$ = -64					; size = 4
_lpPrevNewViewSubobject$ = -60				; size = 4
_lpSrcViewOD$ = -56					; size = 4
_hNewViewCsr$ = -52					; size = 4
_lpSrcSelectedInstance$9 = -48				; size = 4
_lpTgtViewCsr$ = -44					; size = 4
_lpSrcViewSubobject$ = -40				; size = 4
_lEntities$ = -36					; size = 4
_lpNewViewSubobject$ = -32				; size = 4
_lpSrcViewCsr$ = -28					; size = 4
_hSrcViewEntityCsr$ = -24				; size = 4
_lpSrcViewEntityCsr$ = -20				; size = 4
_lpNewViewCsr$ = -16					; size = 4
_hNewViewEntityCsr$ = -12				; size = 4
_lpNewViewEntityCsr$ = -8				; size = 4
_nParentHierNbr$10 = -4					; size = 2
_vTgt$ = 8						; size = 4
_vSrc$ = 12						; size = 4
_fnSetViewFromView PROC

; 614  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H

; 615  :    LPTASK            lpOwningTask;
; 616  :    LPVIEWOD          lpSrcViewOD;
; 617  :    LPVIEWOD          lpTgtViewOD;
; 618  :    LPVIEWOI          lpSrcViewOI;
; 619  :    LPVIEWOI          lpTgtViewOI;
; 620  :    LPVIEWCSR         lpTgtViewCsr;
; 621  :    LPVIEWCSR         lpSrcViewCsr;
; 622  :    LPVIEWCSR         lpNewViewCsr;
; 623  :    LPVIEWENTITYCSR   lpSrcViewEntityCsr;
; 624  :    LPVIEWENTITYCSR   lpNewViewEntityCsr;
; 625  :    LPVIEWSUBOBJECT   lpSrcViewSubobject;
; 626  :    LPVIEWSUBOBJECT   lpNewViewSubobject;
; 627  :    LPVIEWSUBOBJECT   lpPrevNewViewSubobject;
; 628  :    zPVOID            hNewViewCsr;
; 629  :    zULONG            ulViewSize;
; 630  :    zLONG             lEntities;
; 631  : 
; 632  :    // We use LPVIEWENTITYCSR instead of zPVOID to declare the following
; 633  :    // handles so that we can perform pointer arithmetic on it.
; 634  :    LPVIEWENTITYCSR   hSrcViewEntityCsr;
; 635  :    LPVIEWENTITYCSR   hNewViewEntityCsr;
; 636  : 
; 637  :    // If the ViewCsr for the source and target are the same, then
; 638  :    // there is nothing to do, return a 0.
; 639  :    if ( vSrc->hViewCsr == vTgt->hViewCsr )

	mov	eax, DWORD PTR _vSrc$[ebp]
	mov	ecx, DWORD PTR _vTgt$[ebp]
	mov	edx, DWORD PTR [eax+10]
	cmp	edx, DWORD PTR [ecx+10]
	jne	SHORT $LN31@fnSetViewF

; 640  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnSetViewF
$LN31@fnSetViewF:

; 641  : 
; 642  :    lpSrcViewOD = zGETPTR( vSrc->hViewOD );

	mov	eax, DWORD PTR _vSrc$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewOD$[ebp], eax

; 643  :    lpTgtViewOD = zGETPTR( vTgt->hViewOD );

	mov	edx, DWORD PTR _vTgt$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOD$[ebp], eax

; 644  : 
; 645  :    // Now make sure the source view object definition and the target
; 646  :    // view object definition are the same object definition. If not,
; 647  :    // we're in deep trouble so issue an error and get out pronto.
; 648  :    if ( lpSrcViewOD == 0 || lpSrcViewOD != lpSrcViewOD )

	cmp	DWORD PTR _lpSrcViewOD$[ebp], 0
	je	SHORT $LN33@fnSetViewF
	mov	ecx, DWORD PTR _lpSrcViewOD$[ebp]
	cmp	ecx, DWORD PTR _lpSrcViewOD$[ebp]
	je	SHORT $LN32@fnSetViewF
$LN33@fnSetViewF:

; 649  :    {
; 650  :       LPTASK lpTask = zGETPTR( vTgt->hTask );

	mov	edx, DWORD PTR _vTgt$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 651  :       zPCHAR  szName1;
; 652  :       zPCHAR  szName2;
; 653  : 
; 654  :       szName1 = 0;

	mov	DWORD PTR _szName1$3[ebp], 0

; 655  :       if ( lpTgtViewOD )

	cmp	DWORD PTR _lpTgtViewOD$[ebp], 0
	je	SHORT $LN34@fnSetViewF

; 656  :          szName1 = lpTgtViewOD->szName;

	mov	ecx, DWORD PTR _lpTgtViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	mov	DWORD PTR _szName1$3[ebp], ecx
$LN34@fnSetViewF:

; 657  : 
; 658  :       szName2 = 0;

	mov	DWORD PTR _szName2$4[ebp], 0

; 659  :       if ( lpSrcViewOD )

	cmp	DWORD PTR _lpSrcViewOD$[ebp], 0
	je	SHORT $LN35@fnSetViewF

; 660  :          szName2 = lpSrcViewOD->szName;

	mov	edx, DWORD PTR _lpSrcViewOD$[ebp]
	add	edx, 10					; 0000000aH
	mov	DWORD PTR _szName2$4[ebp], edx
$LN35@fnSetViewF:

; 661  : 
; 662  :       // "KZOEE274 - Target and Source views are different View Object types"
; 663  :       fnIssueCoreError( lpTask, vSrc, 8, 274, 0, szName1, szName2 );

	mov	eax, DWORD PTR _szName2$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _szName1$3[ebp]
	push	ecx
	push	0
	push	274					; 00000112H
	push	8
	mov	edx, DWORD PTR _vSrc$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTask$2[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 664  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetViewF
$LN32@fnSetViewF:

; 665  :    }
; 666  : 
; 667  :    lpSrcViewCsr   = zGETPTR( vSrc->hViewCsr );

	mov	ecx, DWORD PTR _vSrc$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewCsr$[ebp], eax

; 668  :    lpSrcViewOI    = zGETPTR( lpSrcViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewOI$[ebp], eax

; 669  :    lpOwningTask   = zGETPTR( lpSrcViewOI->hTask );

	mov	edx, DWORD PTR _lpSrcViewOI$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpOwningTask$[ebp], eax

; 670  :    lpTgtViewCsr   = zGETPTR( vTgt->hViewCsr );

	mov	ecx, DWORD PTR _vTgt$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewCsr$[ebp], eax

; 671  : 
; 672  :    if ( lpTgtViewCsr )

	cmp	DWORD PTR _lpTgtViewCsr$[ebp], 0
	je	SHORT $LN36@fnSetViewF

; 673  :       lpTgtViewOI = zGETPTR( lpTgtViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpTgtViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTgtViewOI$[ebp], eax
	jmp	SHORT $LN37@fnSetViewF
$LN36@fnSetViewF:

; 674  :    else
; 675  :       lpTgtViewOI = 0;

	mov	DWORD PTR _lpTgtViewOI$[ebp], 0
$LN37@fnSetViewF:

; 676  : 
; 677  :    if ( lpSrcViewOI == lpTgtViewOI )

	mov	edx, DWORD PTR _lpSrcViewOI$[ebp]
	cmp	edx, DWORD PTR _lpTgtViewOI$[ebp]
	jne	$LN38@fnSetViewF

; 678  :    {
; 679  :       lpNewViewCsr = lpTgtViewCsr;

	mov	eax, DWORD PTR _lpTgtViewCsr$[ebp]
	mov	DWORD PTR _lpNewViewCsr$[ebp], eax

; 680  :       hNewViewCsr  = zGETHNDL( lpNewViewCsr );

	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hNewViewCsr$[ebp], eax

; 681  :       fnResetView( vTgt, 0 );   // Reset the target View

	push	0
	mov	edx, DWORD PTR _vTgt$[ebp]
	push	edx
	call	_fnResetView
	add	esp, 8

; 682  :       lpTgtViewCsr->hHierRootEntityInstance = lpSrcViewCsr->hHierRootEntityInstance;

	mov	eax, DWORD PTR _lpTgtViewCsr$[ebp]
	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	mov	DWORD PTR [eax+22], edx

; 683  :       lpTgtViewCsr->hHierEntityInstance = lpSrcViewCsr->hHierEntityInstance;

	mov	eax, DWORD PTR _lpTgtViewCsr$[ebp]
	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+26]
	mov	DWORD PTR [eax+26], edx

; 684  :       lpTgtViewCsr->hViewParentEntityInstance = lpSrcViewCsr->hViewParentEntityInstance;

	mov	eax, DWORD PTR _lpTgtViewCsr$[ebp]
	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+38]
	mov	DWORD PTR [eax+38], edx

; 685  :       lEntities = lpTgtViewCsr->uEntities;

	mov	eax, DWORD PTR _lpTgtViewCsr$[ebp]
	movzx	ecx, WORD PTR [eax+34]
	mov	DWORD PTR _lEntities$[ebp], ecx

; 686  :       hSrcViewEntityCsr  = lpSrcViewCsr->hFirstOD_EntityCsr;

	mov	edx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], eax

; 687  :       lpSrcViewEntityCsr = zGETPTR( lpSrcViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax

; 688  :       hNewViewEntityCsr  = lpNewViewCsr->hFirstOD_EntityCsr;

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], ecx

; 689  :       lpNewViewEntityCsr = zGETPTR( lpNewViewCsr->hFirstOD_EntityCsr );

	mov	edx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], eax

; 690  :       if ( lpSrcViewCsr->hFirstViewSubobject == 0 )

	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	jne	SHORT $LN4@fnSetViewF
$LN2@fnSetViewF:

; 691  :       {
; 692  :          while ( lEntities )

	cmp	DWORD PTR _lEntities$[ebp], 0
	je	SHORT $LN3@fnSetViewF

; 693  :          {
; 694  :             lpNewViewEntityCsr->hEntityInstance = lpSrcViewEntityCsr->hEntityInstance;

	mov	edx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR [edx+26], ecx

; 695  :          // if ( lpNewViewEntityCsr->hEntityInstance == UNSET_CSR )
; 696  :          //    SysMessageBox( 0, "fnSetViewFromView", "UNSET_CSR", -1 );  // happens too much
; 697  : 
; 698  :             hSrcViewEntityCsr++;

	mov	edx, DWORD PTR _hSrcViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], edx

; 699  :             lpSrcViewEntityCsr++;

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax

; 700  :             hNewViewEntityCsr++;

	mov	ecx, DWORD PTR _hNewViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], ecx

; 701  :             lpNewViewEntityCsr++;

	mov	edx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], edx

; 702  : 
; 703  :             lEntities--;

	mov	eax, DWORD PTR _lEntities$[ebp]
	sub	eax, 1
	mov	DWORD PTR _lEntities$[ebp], eax

; 704  :          }

	jmp	SHORT $LN2@fnSetViewF
$LN3@fnSetViewF:

; 705  :       }

	jmp	$LN41@fnSetViewF
$LN4@fnSetViewF:

; 706  :       else
; 707  :       {
; 708  :          // Set root view entity csr.
; 709  :          while ( hSrcViewEntityCsr != lpSrcViewCsr->hRootViewEntityCsr )

	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	edx, DWORD PTR _hSrcViewEntityCsr$[ebp]
	cmp	edx, DWORD PTR [ecx+18]
	je	SHORT $LN5@fnSetViewF

; 710  :          {
; 711  :             hSrcViewEntityCsr++;

	mov	eax, DWORD PTR _hSrcViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], eax

; 712  :             lpSrcViewEntityCsr++;

	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], ecx

; 713  :             hNewViewEntityCsr++;

	mov	edx, DWORD PTR _hNewViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], edx

; 714  :             lpNewViewEntityCsr++;

	mov	eax, DWORD PTR _lpNewViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], eax

; 715  :          }

	jmp	SHORT $LN4@fnSetViewF
$LN5@fnSetViewF:

; 716  : 
; 717  :          lpNewViewCsr->hRootViewEntityCsr = hNewViewEntityCsr;

	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	edx, DWORD PTR _hNewViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+18], edx

; 718  : 
; 719  :          // Reset first cursor in case root view csr is not the first csr.
; 720  :          hSrcViewEntityCsr  = lpSrcViewCsr->hFirstOD_EntityCsr;

	mov	eax, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], ecx

; 721  :          lpSrcViewEntityCsr = zGETPTR( lpSrcViewCsr->hFirstOD_EntityCsr );

	mov	edx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax

; 722  :          hNewViewEntityCsr  = lpNewViewCsr->hFirstOD_EntityCsr;

	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], edx

; 723  :          lpNewViewEntityCsr = zGETPTR( lpNewViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], eax
$LN6@fnSetViewF:

; 724  : 
; 725  :          while ( lEntities )

	cmp	DWORD PTR _lEntities$[ebp], 0
	je	$LN41@fnSetViewF

; 726  :          {
; 727  :             lpNewViewEntityCsr->hEntityInstance = lpSrcViewEntityCsr->hEntityInstance;

	mov	edx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR [edx+26], ecx

; 728  :          // if ( lpNewViewEntityCsr->hEntityInstance == UNSET_CSR )
; 729  :          //    SysMessageBox( 0, "fnSetViewFromView2", "UNSET_CSR", -1 );  // happens too much
; 730  : 
; 731  :             lpNewViewEntityCsr->hViewEntity = lpSrcViewEntityCsr->hViewEntity;

	mov	edx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR [edx+14], ecx

; 732  :             lpNewViewEntityCsr->nLevel = lpSrcViewEntityCsr->nLevel;

	mov	edx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	cx, WORD PTR [eax+22]
	mov	WORD PTR [edx+22], cx

; 733  :             if ( lpSrcViewEntityCsr->hNextHier == 0 )

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	cmp	DWORD PTR [edx+2], 0
	jne	SHORT $LN42@fnSetViewF

; 734  :                lpNewViewEntityCsr->hNextHier = 0;

	mov	eax, DWORD PTR _lpNewViewEntityCsr$[ebp]
	mov	DWORD PTR [eax+2], 0
$LN42@fnSetViewF:

; 735  : 
; 736  :             if ( lpSrcViewEntityCsr->hPrevHier == 0 )

	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+6], 0
	jne	SHORT $LN43@fnSetViewF

; 737  :                lpNewViewEntityCsr->hPrevHier = 0;

	mov	edx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+6], 0
$LN43@fnSetViewF:

; 738  : 
; 739  :             if ( lpSrcViewEntityCsr->hParent == 0 )

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+10], 0
	jne	SHORT $LN44@fnSetViewF

; 740  :                lpNewViewEntityCsr->hParent = 0;

	mov	ecx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+10], 0
$LN44@fnSetViewF:

; 741  : 
; 742  :             hSrcViewEntityCsr++;

	mov	edx, DWORD PTR _hSrcViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], edx

; 743  :             lpSrcViewEntityCsr++;

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax

; 744  :             hNewViewEntityCsr++;

	mov	ecx, DWORD PTR _hNewViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], ecx

; 745  :             lpNewViewEntityCsr++;

	mov	edx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], edx

; 746  : 
; 747  :             lEntities--;

	mov	eax, DWORD PTR _lEntities$[ebp]
	sub	eax, 1
	mov	DWORD PTR _lEntities$[ebp], eax

; 748  :          }

	jmp	$LN6@fnSetViewF
$LN41@fnSetViewF:

; 749  :       }
; 750  :    }

	jmp	$LN39@fnSetViewF
$LN38@fnSetViewF:

; 751  :    else
; 752  :    {
; 753  :       // If the source and target ViewOI are not equal, we need to allocate
; 754  :       // a new ViewCsr and ViewEntityCsrs so we can drop the previous
; 755  :       // ViewCsr and appropriate cleanup will take place on the ViewOI
; 756  :       // previously referenced by the SrcView.
; 757  :       // Allocate space for View.
; 758  :       lEntities = lpSrcViewCsr->uEntities;

	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	movzx	edx, WORD PTR [ecx+34]
	mov	DWORD PTR _lEntities$[ebp], edx

; 759  :       ulViewSize = sizeof( ViewCsrRecord ) + (lEntities * sizeof( ViewEntityCsrRecord ));

	imul	eax, DWORD PTR _lEntities$[ebp], 30
	add	eax, 46					; 0000002eH
	mov	DWORD PTR _ulViewSize$[ebp], eax

; 760  : 
; 761  :       // Create a ViewOI Record.
; 762  :       hNewViewCsr = fnAllocDataspace( lpOwningTask->hFirstDataHeader,

	push	10019					; 00002723H
	push	0
	push	0
	mov	ecx, DWORD PTR _ulViewSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOwningTask$[ebp]
	mov	eax, DWORD PTR [edx+94]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hNewViewCsr$[ebp], eax

; 763  :                                       ulViewSize, 0, 0, iViewCsr );
; 764  :       lpNewViewCsr = zGETPTR( hNewViewCsr );

	mov	ecx, DWORD PTR _hNewViewCsr$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewCsr$[ebp], eax

; 765  :       if ( lpNewViewCsr == 0 )

	cmp	DWORD PTR _lpNewViewCsr$[ebp], 0
	jne	SHORT $LN45@fnSetViewF

; 766  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetViewF
$LN45@fnSetViewF:

; 767  : 
; 768  :       // Copy the information from the old view to the new view.
; 769  :       zmemcpy( lpNewViewCsr, lpSrcViewCsr, ulViewSize );

	mov	edx, DWORD PTR _ulViewSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpSrcViewCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 770  : 
; 771  :       // Initialize ViewEntityCsr records.
; 772  :       // Now go through and set the entity pointers.
; 773  :       hSrcViewEntityCsr  = lpSrcViewCsr->hFirstOD_EntityCsr;

	mov	edx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], eax

; 774  :       lpSrcViewEntityCsr = zGETPTR( lpSrcViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax

; 775  :       hNewViewEntityCsr  = (zPVOID) ((zLONG) hNewViewCsr + sizeof( ViewCsrRecord ));

	mov	eax, DWORD PTR _hNewViewCsr$[ebp]
	add	eax, 46					; 0000002eH
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], eax

; 776  :       lpNewViewEntityCsr = (LPVIEWENTITYCSR) zGETPTR( hNewViewEntityCsr );

	mov	ecx, DWORD PTR _hNewViewEntityCsr$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], eax

; 777  :       lpNewViewCsr->hFirstOD_EntityCsr = hNewViewEntityCsr;

	mov	edx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	eax, DWORD PTR _hNewViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+14], eax
$LN8@fnSetViewF:

; 778  : 
; 779  :       // Set root view entity csr.
; 780  :       while ( hSrcViewEntityCsr != lpSrcViewCsr->hRootViewEntityCsr )

	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	edx, DWORD PTR _hSrcViewEntityCsr$[ebp]
	cmp	edx, DWORD PTR [ecx+18]
	je	SHORT $LN9@fnSetViewF

; 781  :       {
; 782  :          hSrcViewEntityCsr++;

	mov	eax, DWORD PTR _hSrcViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], eax

; 783  :          lpSrcViewEntityCsr++;

	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], ecx

; 784  :          hNewViewEntityCsr++;

	mov	edx, DWORD PTR _hNewViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], edx

; 785  :          lpNewViewEntityCsr++;

	mov	eax, DWORD PTR _lpNewViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], eax

; 786  :       }

	jmp	SHORT $LN8@fnSetViewF
$LN9@fnSetViewF:

; 787  : 
; 788  :       lpNewViewCsr->hRootViewEntityCsr  = hNewViewEntityCsr;

	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	edx, DWORD PTR _hNewViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+18], edx

; 789  :       lpNewViewCsr->hHierRootEntityInstance = 0;

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	mov	DWORD PTR [eax+22], 0

; 790  :       lpNewViewCsr->hHierEntityInstance = 0;

	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	DWORD PTR [ecx+26], 0

; 791  :       lpNewViewCsr->hFirstSelectedInstance = 0;

	mov	edx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	DWORD PTR [edx+42], 0

; 792  : 
; 793  :       // Reset first cursor in case root view csr is not the first csr.
; 794  :       hSrcViewEntityCsr  = lpSrcViewCsr->hFirstOD_EntityCsr;

	mov	eax, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], ecx

; 795  :       lpSrcViewEntityCsr = zGETPTR( lpSrcViewCsr->hFirstOD_EntityCsr );

	mov	edx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax

; 796  :       hNewViewEntityCsr  = lpNewViewCsr->hFirstOD_EntityCsr;

	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], edx

; 797  :       lpNewViewEntityCsr = zGETPTR( lpNewViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], eax
$LN10@fnSetViewF:

; 798  : 
; 799  :       // Note: we use lEntities when initializing the ViewEntityCsr records
; 800  :       // because hierarchical pointers may have been zeroed by a call.
; 801  :       // to SetViewToSubobject.
; 802  :       while ( lEntities )

	cmp	DWORD PTR _lEntities$[ebp], 0
	je	$LN39@fnSetViewF

; 803  :       {
; 804  :          lpNewViewEntityCsr->hViewCsr = hNewViewCsr;

	mov	edx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	mov	eax, DWORD PTR _hNewViewCsr$[ebp]
	mov	DWORD PTR [edx+18], eax

; 805  : 
; 806  :          if ( lpSrcViewEntityCsr->hNextHier )

	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	cmp	DWORD PTR [ecx+2], 0
	je	SHORT $LN46@fnSetViewF

; 807  :             lpNewViewEntityCsr->hNextHier = hNewViewEntityCsr + 1;

	mov	edx, DWORD PTR _hNewViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	eax, DWORD PTR _lpNewViewEntityCsr$[ebp]
	mov	DWORD PTR [eax+2], edx
$LN46@fnSetViewF:

; 808  : 
; 809  :          // If it's not the first ViewEntityCsr in the chain.
; 810  :          if ( hSrcViewEntityCsr != lpSrcViewCsr->hFirstOD_EntityCsr )

	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	edx, DWORD PTR _hSrcViewEntityCsr$[ebp]
	cmp	edx, DWORD PTR [ecx+14]
	je	SHORT $LN47@fnSetViewF

; 811  :          {
; 812  :             LPVIEWENTITYCSR lpParentViewEntityCsr;
; 813  :             LPVIEWENTITYCSR hParentViewEntityCsr;
; 814  : 
; 815  :             // When establishing a parent cursor in the new view, we use the
; 816  :             // hierarchical number from the previous view instead of levels
; 817  :             // because levels may have been mucked with by calls to
; 818  :             // SetViewToSubobject which can cause erroneous parent setting.
; 819  :             if ( lpSrcViewEntityCsr->hPrevHier )

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+6], 0
	je	SHORT $LN48@fnSetViewF

; 820  :                lpNewViewEntityCsr->hPrevHier = hNewViewEntityCsr - 1;

	mov	ecx, DWORD PTR _hNewViewEntityCsr$[ebp]
	sub	ecx, 30					; 0000001eH
	mov	edx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+6], ecx
$LN48@fnSetViewF:

; 821  : 
; 822  :             if ( lpSrcViewEntityCsr->hParent )

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+10], 0
	je	SHORT $LN47@fnSetViewF

; 823  :             {
; 824  :                zSHORT          nParentHierNbr;
; 825  :                LPVIEWENTITYCSR lpTempParent;
; 826  : 
; 827  :                hParentViewEntityCsr  = hNewViewEntityCsr - 1;

	mov	ecx, DWORD PTR _hNewViewEntityCsr$[ebp]
	sub	ecx, 30					; 0000001eH
	mov	DWORD PTR _hParentViewEntityCsr$7[ebp], ecx

; 828  :                lpParentViewEntityCsr = lpNewViewEntityCsr - 1;

	mov	edx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	sub	edx, 30					; 0000001eH
	mov	DWORD PTR _lpParentViewEntityCsr$8[ebp], edx

; 829  : 
; 830  :                lpTempParent = zGETPTR( lpSrcViewEntityCsr->hParent );

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempParent$1[ebp], eax

; 831  :                nParentHierNbr = lpTempParent->nHierNbr;

	mov	edx, DWORD PTR _lpTempParent$1[ebp]
	mov	ax, WORD PTR [edx+24]
	mov	WORD PTR _nParentHierNbr$10[ebp], ax
$LN12@fnSetViewF:

; 832  :                while ( lpParentViewEntityCsr->nHierNbr != nParentHierNbr )

	mov	ecx, DWORD PTR _lpParentViewEntityCsr$8[ebp]
	movsx	edx, WORD PTR [ecx+24]
	movsx	eax, WORD PTR _nParentHierNbr$10[ebp]
	cmp	edx, eax
	je	SHORT $LN13@fnSetViewF

; 833  :                {
; 834  :                   hParentViewEntityCsr--;

	mov	ecx, DWORD PTR _hParentViewEntityCsr$7[ebp]
	sub	ecx, 30					; 0000001eH
	mov	DWORD PTR _hParentViewEntityCsr$7[ebp], ecx

; 835  :                   lpParentViewEntityCsr--;

	mov	edx, DWORD PTR _lpParentViewEntityCsr$8[ebp]
	sub	edx, 30					; 0000001eH
	mov	DWORD PTR _lpParentViewEntityCsr$8[ebp], edx

; 836  :                }

	jmp	SHORT $LN12@fnSetViewF
$LN13@fnSetViewF:

; 837  : 
; 838  :                lpNewViewEntityCsr->hParent = hParentViewEntityCsr;

	mov	eax, DWORD PTR _lpNewViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR _hParentViewEntityCsr$7[ebp]
	mov	DWORD PTR [eax+10], ecx
$LN47@fnSetViewF:

; 839  :             // if ( lpNewViewEntityCsr->hParent == (LPVIEWENTITYCSR) 1 )
; 840  :             //    SysMessageBox( 0, "fnSetViewFromView", "UNSET_CSR", -1 );
; 841  :             }
; 842  :          }
; 843  : 
; 844  :          hSrcViewEntityCsr++;

	mov	edx, DWORD PTR _hSrcViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], edx

; 845  :          lpSrcViewEntityCsr++;

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax

; 846  :          hNewViewEntityCsr++;

	mov	ecx, DWORD PTR _hNewViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], ecx

; 847  :          lpNewViewEntityCsr++;

	mov	edx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], edx

; 848  : 
; 849  :          lEntities--;

	mov	eax, DWORD PTR _lEntities$[ebp]
	sub	eax, 1
	mov	DWORD PTR _lEntities$[ebp], eax

; 850  :       }

	jmp	$LN10@fnSetViewF
$LN39@fnSetViewF:

; 851  :    }
; 852  : 
; 853  :    // Now that the new view has been created, copy all of the view
; 854  :    // subobject records.
; 855  :    lpSrcViewSubobject = zGETPTR( lpSrcViewCsr->hFirstViewSubobject );

	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewSubobject$[ebp], eax

; 856  :    lpNewViewCsr->hFirstViewSubobject = 0;

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	mov	DWORD PTR [eax+30], 0

; 857  :    lpPrevNewViewSubobject = 0;

	mov	DWORD PTR _lpPrevNewViewSubobject$[ebp], 0
$LN14@fnSetViewF:

; 858  :    while ( lpSrcViewSubobject )

	cmp	DWORD PTR _lpSrcViewSubobject$[ebp], 0
	je	$LN15@fnSetViewF

; 859  :    {
; 860  :       zPVOID hNewViewSubobject;
; 861  : 
; 862  :       // Create a viewsubobject record and chain it to the ViewCsr.
; 863  :       hNewViewSubobject = fnAllocDataspace( lpOwningTask->hFirstDataHeader,

	push	10020					; 00002724H
	push	0
	push	1
	push	48					; 00000030H
	mov	ecx, DWORD PTR _lpOwningTask$[ebp]
	mov	edx, DWORD PTR [ecx+94]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hNewViewSubobject$6[ebp], eax

; 864  :                                             sizeof( ViewSubobjectRecord ), 1, 0,
; 865  :                                             iViewSubobject );
; 866  :       lpNewViewSubobject = zGETPTR( hNewViewSubobject );

	mov	eax, DWORD PTR _hNewViewSubobject$6[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewSubobject$[ebp], eax

; 867  :       if ( lpNewViewSubobject == 0 )

	cmp	DWORD PTR _lpNewViewSubobject$[ebp], 0
	jne	SHORT $LN50@fnSetViewF

; 868  :       {
; 869  :          if ( lpNewViewCsr == lpTgtViewCsr )

	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	cmp	ecx, DWORD PTR _lpTgtViewCsr$[ebp]
	jne	SHORT $LN16@fnSetViewF

; 870  :          {
; 871  :             fnResetView( vTgt, 0 );   // reset the target view

	push	0
	mov	edx, DWORD PTR _vTgt$[ebp]
	push	edx
	call	_fnResetView
	add	esp, 8

; 872  :          }

	jmp	SHORT $LN50@fnSetViewF
$LN16@fnSetViewF:

; 873  :          else
; 874  :          {
; 875  :             while ( lpNewViewCsr->hFirstViewSubobject )

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $LN17@fnSetViewF

; 876  :             {
; 877  :                lpNewViewSubobject = zGETPTR( lpNewViewCsr->hFirstViewSubobject );

	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewSubobject$[ebp], eax

; 878  :                lpNewViewCsr->hFirstViewSubobject = lpNewViewSubobject->hNextViewSubobject;

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	mov	ecx, DWORD PTR _lpNewViewSubobject$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax+30], edx

; 879  :                fnFreeDataspace( lpNewViewSubobject );

	mov	eax, DWORD PTR _lpNewViewSubobject$[ebp]
	push	eax
	call	_fnFreeDataspace
	add	esp, 4

; 880  :             }

	jmp	SHORT $LN16@fnSetViewF
$LN17@fnSetViewF:

; 881  : 
; 882  :             fnFreeDataspace( lpNewViewCsr );

	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 883  :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnSetViewF
$LN50@fnSetViewF:

; 884  :          }
; 885  :       }
; 886  : 
; 887  :       zmemcpy( (zPCHAR) lpNewViewSubobject, (zPCHAR) lpSrcViewSubobject,

	push	48					; 00000030H
	mov	edx, DWORD PTR _lpSrcViewSubobject$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpNewViewSubobject$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 888  :                sizeof( ViewSubobjectRecord ) );
; 889  : 
; 890  :       // Set appropriate view entity cursors in new subobject
; 891  :       // First, set lpViewParent csr. NOTE: the view parent
; 892  :       // Cursor may be NULL in the case of recursion when the
; 893  :       // recursive parent entity type is to root of the
; 894  :       // view object.
; 895  :       if ( lpSrcViewSubobject->hViewRootParentCsr )

	mov	ecx, DWORD PTR _lpSrcViewSubobject$[ebp]
	cmp	DWORD PTR [ecx+10], 0
	je	SHORT $LN53@fnSetViewF

; 896  :       {
; 897  :          hSrcViewEntityCsr  = lpSrcViewCsr->hFirstOD_EntityCsr;

	mov	edx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], eax

; 898  :          lpSrcViewEntityCsr = zGETPTR( lpSrcViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax

; 899  :          hNewViewEntityCsr  = lpNewViewCsr->hFirstOD_EntityCsr;

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], ecx

; 900  :          lpNewViewEntityCsr = zGETPTR( lpNewViewCsr->hFirstOD_EntityCsr );

	mov	edx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], eax
$LN18@fnSetViewF:

; 901  :          while ( hSrcViewEntityCsr != lpSrcViewSubobject->hViewRootParentCsr )

	mov	ecx, DWORD PTR _lpSrcViewSubobject$[ebp]
	mov	edx, DWORD PTR _hSrcViewEntityCsr$[ebp]
	cmp	edx, DWORD PTR [ecx+10]
	je	SHORT $LN19@fnSetViewF

; 902  :          {
; 903  :             hSrcViewEntityCsr++;

	mov	eax, DWORD PTR _hSrcViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], eax

; 904  :             lpSrcViewEntityCsr++;

	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], ecx

; 905  :             hNewViewEntityCsr++;

	mov	edx, DWORD PTR _hNewViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], edx

; 906  :             lpNewViewEntityCsr++;

	mov	eax, DWORD PTR _lpNewViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], eax

; 907  :          }

	jmp	SHORT $LN18@fnSetViewF
$LN19@fnSetViewF:

; 908  : 
; 909  :          lpNewViewSubobject->hViewRootParentCsr = hNewViewEntityCsr;

	mov	ecx, DWORD PTR _lpNewViewSubobject$[ebp]
	mov	edx, DWORD PTR _hNewViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+10], edx
$LN53@fnSetViewF:

; 910  :       }
; 911  : 
; 912  :       // Next set lpRootCsr
; 913  :       hSrcViewEntityCsr  = lpSrcViewCsr->hFirstOD_EntityCsr;

	mov	eax, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], ecx

; 914  :       lpSrcViewEntityCsr = zGETPTR( lpSrcViewCsr->hFirstOD_EntityCsr );

	mov	edx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax

; 915  :       hNewViewEntityCsr  = lpNewViewCsr->hFirstOD_EntityCsr;

	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], edx

; 916  :       lpNewViewEntityCsr = zGETPTR( lpNewViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], eax
$LN20@fnSetViewF:

; 917  :       while ( hSrcViewEntityCsr != lpSrcViewSubobject->hRootCsr )

	mov	edx, DWORD PTR _lpSrcViewSubobject$[ebp]
	mov	eax, DWORD PTR _hSrcViewEntityCsr$[ebp]
	cmp	eax, DWORD PTR [edx+14]
	je	SHORT $LN21@fnSetViewF

; 918  :       {
; 919  :          hSrcViewEntityCsr++;

	mov	ecx, DWORD PTR _hSrcViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], ecx

; 920  :          lpSrcViewEntityCsr++;

	mov	edx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], edx

; 921  :          hNewViewEntityCsr++;

	mov	eax, DWORD PTR _hNewViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], eax

; 922  :          lpNewViewEntityCsr++;

	mov	ecx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], ecx

; 923  :       }

	jmp	SHORT $LN20@fnSetViewF
$LN21@fnSetViewF:

; 924  : 
; 925  :       lpNewViewSubobject->hRootCsr = hNewViewEntityCsr;

	mov	edx, DWORD PTR _lpNewViewSubobject$[ebp]
	mov	eax, DWORD PTR _hNewViewEntityCsr$[ebp]
	mov	DWORD PTR [edx+14], eax
$LN22@fnSetViewF:

; 926  : 
; 927  :       // Next, set lpLastDescCsr, note we do not reset lpSrcViewEntityCsr
; 928  :       // and lpNewViewEntityCsr because the last descendent must occur
; 929  :       // on the same or a subsequent cursor to the root cursor
; 930  :       while ( hSrcViewEntityCsr != lpSrcViewSubobject->hLastDescCsr )

	mov	ecx, DWORD PTR _lpSrcViewSubobject$[ebp]
	mov	edx, DWORD PTR _hSrcViewEntityCsr$[ebp]
	cmp	edx, DWORD PTR [ecx+20]
	je	SHORT $LN23@fnSetViewF

; 931  :       {
; 932  :          hSrcViewEntityCsr++;

	mov	eax, DWORD PTR _hSrcViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], eax

; 933  :          lpSrcViewEntityCsr++;

	mov	ecx, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], ecx

; 934  :          hNewViewEntityCsr++;

	mov	edx, DWORD PTR _hNewViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], edx

; 935  :          lpNewViewEntityCsr++;

	mov	eax, DWORD PTR _lpNewViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], eax

; 936  :       }

	jmp	SHORT $LN22@fnSetViewF
$LN23@fnSetViewF:

; 937  : 
; 938  :       lpNewViewSubobject->hLastDescCsr = hNewViewEntityCsr;

	mov	ecx, DWORD PTR _lpNewViewSubobject$[ebp]
	mov	edx, DWORD PTR _hNewViewEntityCsr$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 939  : 
; 940  :       // Next, set RecursViewEntityCsr if set in old View Subobject.
; 941  :       if ( lpSrcViewSubobject->hRecursViewEntityCsr )

	mov	eax, DWORD PTR _lpSrcViewSubobject$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN54@fnSetViewF

; 942  :       {
; 943  :          hSrcViewEntityCsr  = lpSrcViewCsr->hFirstOD_EntityCsr;

	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], edx

; 944  :          lpSrcViewEntityCsr = zGETPTR( lpSrcViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax

; 945  :          hNewViewEntityCsr  = lpNewViewCsr->hFirstOD_EntityCsr;

	mov	edx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], eax

; 946  :          lpNewViewEntityCsr = zGETPTR( lpNewViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], eax
$LN24@fnSetViewF:

; 947  :          while ( hSrcViewEntityCsr != lpSrcViewSubobject->hRecursViewEntityCsr )

	mov	eax, DWORD PTR _lpSrcViewSubobject$[ebp]
	mov	ecx, DWORD PTR _hSrcViewEntityCsr$[ebp]
	cmp	ecx, DWORD PTR [eax+40]
	je	SHORT $LN25@fnSetViewF

; 948  :          {
; 949  :             hSrcViewEntityCsr++;

	mov	edx, DWORD PTR _hSrcViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _hSrcViewEntityCsr$[ebp], edx

; 950  :             lpSrcViewEntityCsr++;

	mov	eax, DWORD PTR _lpSrcViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpSrcViewEntityCsr$[ebp], eax

; 951  :             hNewViewEntityCsr++;

	mov	ecx, DWORD PTR _hNewViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], ecx

; 952  :             lpNewViewEntityCsr++;

	mov	edx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	add	edx, 30					; 0000001eH
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], edx

; 953  :          }

	jmp	SHORT $LN24@fnSetViewF
$LN25@fnSetViewF:

; 954  : 
; 955  :          lpNewViewSubobject->hRecursViewEntityCsr = hNewViewEntityCsr;

	mov	eax, DWORD PTR _lpNewViewSubobject$[ebp]
	mov	ecx, DWORD PTR _hNewViewEntityCsr$[ebp]
	mov	DWORD PTR [eax+40], ecx
$LN54@fnSetViewF:

; 956  :       }
; 957  : 
; 958  :       if ( lpPrevNewViewSubobject )

	cmp	DWORD PTR _lpPrevNewViewSubobject$[ebp], 0
	je	SHORT $LN55@fnSetViewF

; 959  :       {
; 960  :          lpPrevNewViewSubobject->hNextViewSubobject = hNewViewSubobject;

	mov	edx, DWORD PTR _lpPrevNewViewSubobject$[ebp]
	mov	eax, DWORD PTR _hNewViewSubobject$6[ebp]
	mov	DWORD PTR [edx+2], eax

; 961  :          lpNewViewSubobject->hPrevViewSubobject =

	mov	ecx, DWORD PTR _lpPrevNewViewSubobject$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpNewViewSubobject$[ebp]
	mov	DWORD PTR [edx+6], eax

; 962  :                                           zGETHNDL( lpPrevNewViewSubobject );
; 963  :       }

	jmp	SHORT $LN56@fnSetViewF
$LN55@fnSetViewF:

; 964  :       else
; 965  :          lpNewViewCsr->hFirstViewSubobject = hNewViewSubobject;

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	mov	ecx, DWORD PTR _hNewViewSubobject$6[ebp]
	mov	DWORD PTR [eax+30], ecx
$LN56@fnSetViewF:

; 966  : 
; 967  :       lpNewViewSubobject->hNextViewSubobject = 0;

	mov	edx, DWORD PTR _lpNewViewSubobject$[ebp]
	mov	DWORD PTR [edx+2], 0

; 968  :       lpPrevNewViewSubobject = lpNewViewSubobject;

	mov	eax, DWORD PTR _lpNewViewSubobject$[ebp]
	mov	DWORD PTR _lpPrevNewViewSubobject$[ebp], eax

; 969  :       lpSrcViewSubobject = zGETPTR( lpSrcViewSubobject->hNextViewSubobject );

	mov	ecx, DWORD PTR _lpSrcViewSubobject$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcViewSubobject$[ebp], eax

; 970  :    }

	jmp	$LN14@fnSetViewF
$LN15@fnSetViewF:

; 971  : 
; 972  :    // 'copy' the selected instance chain.
; 973  :    if ( lpSrcViewCsr->hFirstSelectedInstance )

	mov	eax, DWORD PTR _lpSrcViewCsr$[ebp]
	cmp	DWORD PTR [eax+42], 0
	je	$LN57@fnSetViewF

; 974  :    {
; 975  :       LPSELECTEDINSTANCE   lpSrcSelectedInstance;
; 976  : 
; 977  :       lpSrcSelectedInstance = zGETPTR( lpSrcViewCsr->hFirstSelectedInstance );

	mov	ecx, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcSelectedInstance$9[ebp], eax
$LN26@fnSetViewF:

; 978  :       while ( lpSrcSelectedInstance )

	cmp	DWORD PTR _lpSrcSelectedInstance$9[ebp], 0
	je	$LN27@fnSetViewF

; 979  :       {
; 980  :          zLONG    lEntities;
; 981  : 
; 982  :          lpNewViewEntityCsr = zGETPTR( lpNewViewCsr->hFirstOD_EntityCsr );

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], eax

; 983  :          hNewViewEntityCsr  = lpNewViewCsr->hFirstOD_EntityCsr;

	mov	edx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], eax

; 984  :          lEntities = lpNewViewCsr->uEntities;

	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	movzx	edx, WORD PTR [ecx+34]
	mov	DWORD PTR _lEntities$5[ebp], edx
$LN30@fnSetViewF:

; 985  :          do
; 986  :          {
; 987  :             if ( lpNewViewEntityCsr->hViewEntity == lpSrcSelectedInstance->hViewEntity )

	mov	eax, DWORD PTR _lpNewViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR _lpSrcSelectedInstance$9[ebp]
	mov	edx, DWORD PTR [eax+14]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN58@fnSetViewF

; 988  :             {
; 989  :                break;

	jmp	SHORT $LN29@fnSetViewF
$LN58@fnSetViewF:

; 990  :             }
; 991  : 
; 992  :             lpNewViewEntityCsr++;

	mov	eax, DWORD PTR _lpNewViewEntityCsr$[ebp]
	add	eax, 30					; 0000001eH
	mov	DWORD PTR _lpNewViewEntityCsr$[ebp], eax

; 993  :             hNewViewEntityCsr++;

	mov	ecx, DWORD PTR _hNewViewEntityCsr$[ebp]
	add	ecx, 30					; 0000001eH
	mov	DWORD PTR _hNewViewEntityCsr$[ebp], ecx

; 994  :             lEntities--;

	mov	edx, DWORD PTR _lEntities$5[ebp]
	sub	edx, 1
	mov	DWORD PTR _lEntities$5[ebp], edx

; 995  : 
; 996  :          } while ( lEntities > 0 );

	cmp	DWORD PTR _lEntities$5[ebp], 0
	jg	SHORT $LN30@fnSetViewF
$LN29@fnSetViewF:

; 997  : 
; 998  :          // Set the current select set to the summ of the selections for the
; 999  :          // select instance.
; 1000 :          lpNewViewCsr->nCurrentSelectSet = lpSrcSelectedInstance->nSelectSet;

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	mov	ecx, DWORD PTR _lpSrcSelectedInstance$9[ebp]
	mov	dx, WORD PTR [ecx+6]
	mov	WORD PTR [eax+36], dx

; 1001 :          fnSelectedInstanceFarbler( zGETPTR( lpNewViewEntityCsr->hViewCsr ),

	push	2
	mov	eax, DWORD PTR _lpSrcSelectedInstance$9[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	edx, DWORD PTR _lpSrcSelectedInstance$9[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpNewViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnSelectedInstanceFarbler
	add	esp, 16					; 00000010H

; 1002 :                                     zGETPTR( lpSrcSelectedInstance->hViewEntity ),
; 1003 :                                     lpSrcSelectedInstance->xEntityInstance, 2 );
; 1004 :          lpSrcSelectedInstance = zGETPTR( lpSrcSelectedInstance->hNextSelectedInstance );

	mov	eax, DWORD PTR _lpSrcSelectedInstance$9[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrcSelectedInstance$9[ebp], eax

; 1005 :       }

	jmp	$LN26@fnSetViewF
$LN27@fnSetViewF:

; 1006 : 
; 1007 :       // After the selections in this view, reset the current select set
; 1008 :       // for the new view to match the source view.
; 1009 :       lpNewViewCsr->nCurrentSelectSet = lpSrcViewCsr->nCurrentSelectSet;

	mov	edx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	eax, DWORD PTR _lpSrcViewCsr$[ebp]
	mov	cx, WORD PTR [eax+36]
	mov	WORD PTR [edx+36], cx
$LN57@fnSetViewF:

; 1010 :    }
; 1011 : 
; 1012 :    // If we created a brand new ViewCsr, clear up the old view and
; 1013 :    // chain the new ViewCsr to the ViewOI.
; 1014 :    if ( lpNewViewCsr != lpTgtViewCsr )

	mov	edx, DWORD PTR _lpNewViewCsr$[ebp]
	cmp	edx, DWORD PTR _lpTgtViewCsr$[ebp]
	je	SHORT $LN59@fnSetViewF

; 1015 :    {
; 1016 :       // Chain ViewCsr to ViewOI.
; 1017 :       lpNewViewCsr->hNextViewCsr = lpSrcViewOI->hFirstViewCsr;

	mov	eax, DWORD PTR _lpNewViewCsr$[ebp]
	mov	ecx, DWORD PTR _lpSrcViewOI$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	mov	DWORD PTR [eax+2], edx

; 1018 :       lpSrcViewOI->hFirstViewCsr = hNewViewCsr;

	mov	eax, DWORD PTR _lpSrcViewOI$[ebp]
	mov	ecx, DWORD PTR _hNewViewCsr$[ebp]
	mov	DWORD PTR [eax+10], ecx

; 1019 :       if ( lpTgtViewCsr )

	cmp	DWORD PTR _lpTgtViewCsr$[ebp], 0
	je	SHORT $LN60@fnSetViewF

; 1020 :          fnDropViewCsr( zGETPTR( vTgt->hViewCsr ) );

	mov	edx, DWORD PTR _vTgt$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnDropViewCsr
	add	esp, 4
$LN60@fnSetViewF:

; 1021 : 
; 1022 :       vTgt->hViewCsr = hNewViewCsr;

	mov	ecx, DWORD PTR _vTgt$[ebp]
	mov	edx, DWORD PTR _hNewViewCsr$[ebp]
	mov	DWORD PTR [ecx+10], edx

; 1023 :       lpNewViewCsr->hView = zGETHNDL( vTgt );

	mov	eax, DWORD PTR _vTgt$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpNewViewCsr$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN59@fnSetViewF:

; 1024 :    }
; 1025 : 
; 1026 :    // Finally, copy read only bit from source to target.
; 1027 :    vTgt->bReadOnly = vSrc->bReadOnly;

	mov	edx, DWORD PTR _vSrc$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 6
	and	eax, 1
	and	eax, 1
	shl	eax, 6
	mov	ecx, DWORD PTR _vTgt$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	and	edx, -65				; ffffffbfH
	or	edx, eax
	mov	eax, DWORD PTR _vTgt$[ebp]
	mov	DWORD PTR [eax+30], edx

; 1028 : 
; 1029 :    // We should be calling listeners to inform them that the cursor has been
; 1030 :    // set, but we don't know the (if any) entity name ... dks 2007.05.24
; 1031 : // fnCallListeners( lpView, ??????Entity->szName );
; 1032 : 
; 1033 :    return( 0 ); // success, return the good news

	xor	eax, eax
$LN1@fnSetViewF:

; 1034 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_fnSetViewFromView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_hNewView$ = -20					; size = 4
_hCurrentTask$ = -16					; size = 4
_lpViewOD$ = -12					; size = 4
_lpNewView$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pvReturnView$ = 8					; size = 4
_lpCurrentTask$ = 12					; size = 4
_lpView$ = 16						; size = 4
_cpcViewOD_Name$ = 20					; size = 4
_bSystemObject$ = 24					; size = 1
_fnDeclareView@20 PROC

; 483  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 484  :    LPTASK   hCurrentTask = zGETHNDL( lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hCurrentTask$[ebp], eax

; 485  :    LPVIEWOD lpViewOD;
; 486  :    zVIEW    lpNewView;
; 487  :    zPVOID   hNewView;
; 488  :    zSHORT   nRC;
; 489  : 
; 490  :    lpNewView = 0;

	mov	DWORD PTR _lpNewView$[ebp], 0

; 491  :    if ( cpcViewOD_Name )

	cmp	DWORD PTR _cpcViewOD_Name$[ebp], 0
	je	SHORT $LN2@fnDeclareV

; 492  :       lpViewOD = ActivateViewObject( lpView, cpcViewOD_Name, bSystemObject );

	movzx	ecx, BYTE PTR _bSystemObject$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cpcViewOD_Name$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_ActivateViewObject@12
	mov	DWORD PTR _lpViewOD$[ebp], eax
	jmp	SHORT $LN3@fnDeclareV
$LN2@fnDeclareV:

; 493  :    else
; 494  :    if ( lpView == (zVIEW) -1 )  // creating a dummy view

	cmp	DWORD PTR _lpView$[ebp], -1
	jne	SHORT $LN4@fnDeclareV

; 495  :       lpViewOD = (LPVIEWOD) -1;

	mov	DWORD PTR _lpViewOD$[ebp], -1
	jmp	SHORT $LN3@fnDeclareV
$LN4@fnDeclareV:

; 496  :    else
; 497  :       lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax
$LN3@fnDeclareV:

; 498  : 
; 499  :    nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 500  :    if ( lpViewOD )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	je	$LN6@fnDeclareV

; 501  :    {
; 502  :    // if ( lpCurrentTask == zGETPTR( AnchorBlock->hMainTask ) )
; 503  :    // if ( lpViewOD != (LPVIEWOD) -1 && zstrcmp( lpViewOD->szName, "DOMAINT" ) == 0 )
; 504  :    //    nRC /= nRC;
; 505  : 
; 506  :       // Allocate a View Record.
; 507  :       hNewView = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10021					; 00002725H
	push	0
	push	1
	push	38					; 00000026H
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+114]
	push	edx
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hNewView$[ebp], eax

; 508  :                                    sizeof( ViewRecord ), 1, 0, iView );
; 509  :    // if ( hNewView == (zVIEW) 0x8310e4ca )
; 510  :    //    nRC /= nRC;
; 511  : 
; 512  :       lpNewView = zGETPTR( hNewView );

	mov	eax, DWORD PTR _hNewView$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNewView$[ebp], eax

; 513  :       if ( lpNewView )

	cmp	DWORD PTR _lpNewView$[ebp], 0
	je	SHORT $LN8@fnDeclareV

; 514  :       {
; 515  :       // LPAPP lpApp;
; 516  : 
; 517  :          lpNewView->hTask = hCurrentTask;

	mov	ecx, DWORD PTR _lpNewView$[ebp]
	mov	edx, DWORD PTR _hCurrentTask$[ebp]
	mov	DWORD PTR [ecx+14], edx

; 518  :          if ( lpViewOD == (LPVIEWOD) -1 )

	cmp	DWORD PTR _lpViewOD$[ebp], -1
	jne	SHORT $LN10@fnDeclareV

; 519  :             lpNewView->hViewOD = 0;

	mov	eax, DWORD PTR _lpNewView$[ebp]
	mov	DWORD PTR [eax+6], 0
	jmp	SHORT $LN11@fnDeclareV
$LN10@fnDeclareV:

; 520  :          else
; 521  :             lpNewView->hViewOD = zGETHNDL( lpViewOD );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpNewView$[ebp]
	mov	DWORD PTR [edx+6], eax
$LN11@fnDeclareV:

; 522  : 
; 523  : // can't|if ( lpView && lpView != (zVIEW) -1 && lpView->bApplicationView &&
; 524  : // do   |     fnGetApplicationForSubtask( &lpApp, lpView ) == 0 )
; 525  : // this |{
; 526  : // here!|   lpNewView->bApplicationView = TRUE; // indicate that scope is app
; 527  : // must |   lpNewView->hNextView = lpApp->hFirstView; // add view to app
; 528  : // do   |   lpApp->hFirstView = hNewView;
; 529  : // at   |}
; 530  : // caller|else
; 531  :          {
; 532  :             if ( hCurrentTask == AnchorBlock->hMainTask )

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _hCurrentTask$[ebp]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $LN12@fnDeclareV

; 533  :                zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4
$LN12@fnDeclareV:

; 534  : 
; 535  :             lpNewView->hNextView = lpCurrentTask->hFirstView;

	mov	edx, DWORD PTR _lpNewView$[ebp]
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+106]
	mov	DWORD PTR [edx+2], ecx

; 536  :             lpCurrentTask->hFirstView = hNewView;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR _hNewView$[ebp]
	mov	DWORD PTR [edx+106], eax

; 537  : 
; 538  :             if ( hCurrentTask == AnchorBlock->hMainTask )

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _hCurrentTask$[ebp]
	cmp	edx, DWORD PTR [ecx+106]
	jne	SHORT $LN13@fnDeclareV

; 539  :                zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN13@fnDeclareV:

; 540  :          }
; 541  :       }

	jmp	SHORT $LN9@fnDeclareV
$LN8@fnDeclareV:

; 542  :       else
; 543  :          nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN9@fnDeclareV:

; 544  :    }

	jmp	SHORT $LN7@fnDeclareV
$LN6@fnDeclareV:

; 545  :    else
; 546  :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx
$LN7@fnDeclareV:

; 547  : 
; 548  :    // Set return view.
; 549  :    *pvReturnView = lpNewView;

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR _lpNewView$[ebp]
	mov	DWORD PTR [edx], eax

; 550  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 551  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_fnDeclareView@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpApp$ = -52						; size = 4
_lpSubtask$ = -48					; size = 4
tv251 = -44						; size = 4
tv250 = -40						; size = 4
tv223 = -36						; size = 4
tv222 = -32						; size = 4
tv193 = -28						; size = 4
tv192 = -24						; size = 4
tv165 = -20						; size = 4
tv164 = -16						; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpViewName$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pvReturnView$ = 8					; size = 4
_pchReturnName$ = 12					; size = 4
_lpView$ = 16						; size = 4
_nLevel$ = 20						; size = 2
_SfGetNextNamedView@16 PROC

; 2428 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 2429 :    LPTASK       lpCurrentTask;
; 2430 :    LPSUBTASK    lpSubtask;
; 2431 :    LPVIEWNAME   lpViewName;
; 2432 :    LPAPP        lpApp;
; 2433 :    zSHORT       nRC;
; 2434 : 
; 2435 :    *pvReturnView = 0;      // initialize return view to null

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 2436 : 
; 2437 :    // If task not active or disabled, return zCALL_ERROR.
; 2438 :    if ( (lpCurrentTask = fnOperationCall( iSfGetNextNamedView, lpView, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	219					; 000000dbH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN10@SfGetNextN

; 2439 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfGetNextN
$LN10@SfGetNextN:

; 2440 : 
; 2441 :    if ( (nLevel == zLEVEL_SUBTASK) &&

	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 1
	jne	SHORT $LN11@SfGetNextN
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidSubtaskView
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN11@SfGetNextN

; 2442 :         (fnValidSubtaskView( lpCurrentTask, lpView )) == 0 )
; 2443 :    {
; 2444 :       fnOperationReturn( iSfGetNextNamedView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	219					; 000000dbH
	call	_fnOperationReturn
	add	esp, 8

; 2445 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfGetNextN
$LN11@SfGetNextN:

; 2446 :    }
; 2447 : 
; 2448 :    if ( (nLevel == zLEVEL_APPLICATION) &&

	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 4
	jne	SHORT $LN12@SfGetNextN
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidView
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN12@SfGetNextN

; 2449 :         (fnValidView( lpCurrentTask, lpView )) == 0 )
; 2450 :    {
; 2451 :       fnOperationReturn( iSfGetNextNamedView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	219					; 000000dbH
	call	_fnOperationReturn
	add	esp, 8

; 2452 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfGetNextN
$LN12@SfGetNextN:

; 2453 :    }
; 2454 : 
; 2455 :    // Check for valid scope.
; 2456 :    if ( nLevel != zLEVEL_SUBTASK     && nLevel != zLEVEL_TASK   &&
; 2457 :         nLevel != zLEVEL_APPLICATION && nLevel != zLEVEL_SYSTEM )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 1
	je	SHORT $LN13@SfGetNextN
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 2
	je	SHORT $LN13@SfGetNextN
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 4
	je	SHORT $LN13@SfGetNextN
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 8
	je	SHORT $LN13@SfGetNextN

; 2458 :    {
; 2459 :       //  "KZOEE110 - Invalid scope for View name"
; 2460 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 110, (zLONG) nLevel, 0, 0 );

	push	0
	push	0
	movsx	ecx, WORD PTR _nLevel$[ebp]
	push	ecx
	push	110					; 0000006eH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2461 :       fnOperationReturn( iSfGetNextNamedView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	219					; 000000dbH
	call	_fnOperationReturn
	add	esp, 8

; 2462 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfGetNextN
$LN13@SfGetNextN:

; 2463 :    }
; 2464 : 
; 2465 :    // Depending on the scope parameter, look in the appropriate
; 2466 :    // name chain for the name requested.
; 2467 :    lpViewName = 0;

	mov	DWORD PTR _lpViewName$[ebp], 0

; 2468 :    if ( pchReturnName && pchReturnName[ 0 ] )

	cmp	DWORD PTR _pchReturnName$[ebp], 0
	je	$LN14@SfGetNextN
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	$LN14@SfGetNextN

; 2469 :    {
; 2470 :       if ( nLevel == zLEVEL_SUBTASK )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 1
	jne	$LN15@SfGetNextN

; 2471 :       {
; 2472 :          // Look for the requested name in the subtask.
; 2473 :          lpSubtask  = zGETPTR( lpView->hSubtask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 2474 :          lpViewName = zGETPTR( lpSubtask->hFirstViewName );

	mov	eax, DWORD PTR _lpSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN2@SfGetNextN:

; 2475 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	$LN3@SfGetNextN

; 2476 :          {
; 2477 :             if ( zstrcmp( lpViewName->szName, pchReturnName ) == 0 )

	mov	edx, DWORD PTR _lpViewName$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN31@SfGetNextN
	mov	eax, DWORD PTR _pchReturnName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN32@SfGetNextN
$LN31@SfGetNextN:
	mov	edx, DWORD PTR _lpViewName$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN29@SfGetNextN
	mov	DWORD PTR tv164[ebp], 1
	jmp	SHORT $LN30@SfGetNextN
$LN29@SfGetNextN:
	mov	DWORD PTR tv164[ebp], -1
$LN30@SfGetNextN:
	mov	eax, DWORD PTR tv164[ebp]
	mov	DWORD PTR tv165[ebp], eax
$LN32@SfGetNextN:
	cmp	DWORD PTR tv165[ebp], 0
	jne	SHORT $LN17@SfGetNextN

; 2478 :             {
; 2479 :                nRC = zLEVEL_SUBTASK;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx

; 2480 :                lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2481 :                break;

	jmp	SHORT $LN3@SfGetNextN
$LN17@SfGetNextN:

; 2482 :             }
; 2483 : 
; 2484 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2485 :          }

	jmp	$LN2@SfGetNextN
$LN3@SfGetNextN:

; 2486 :       }

	jmp	$LN14@SfGetNextN
$LN15@SfGetNextN:

; 2487 :       else
; 2488 :       if ( nLevel == zLEVEL_TASK )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 2
	jne	$LN18@SfGetNextN

; 2489 :       {
; 2490 :          // Look for the requested name in the task.
; 2491 :          lpViewName = zGETPTR( lpCurrentTask->hFirstViewName );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+110]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN4@SfGetNextN:

; 2492 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	$LN5@SfGetNextN

; 2493 :          {
; 2494 :             if ( zstrcmp( lpViewName->szName, pchReturnName ) == 0 )

	mov	eax, DWORD PTR _lpViewName$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _pchReturnName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN35@SfGetNextN
	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewName$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv193[ebp], eax
	jmp	SHORT $LN36@SfGetNextN
$LN35@SfGetNextN:
	mov	eax, DWORD PTR _lpViewName$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _pchReturnName$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN33@SfGetNextN
	mov	DWORD PTR tv192[ebp], 1
	jmp	SHORT $LN34@SfGetNextN
$LN33@SfGetNextN:
	mov	DWORD PTR tv192[ebp], -1
$LN34@SfGetNextN:
	mov	ecx, DWORD PTR tv192[ebp]
	mov	DWORD PTR tv193[ebp], ecx
$LN36@SfGetNextN:
	cmp	DWORD PTR tv193[ebp], 0
	jne	SHORT $LN20@SfGetNextN

; 2495 :             {
; 2496 :                nRC = zLEVEL_TASK;

	mov	edx, 2
	mov	WORD PTR _nRC$[ebp], dx

; 2497 :                lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2498 :                break;

	jmp	SHORT $LN5@SfGetNextN
$LN20@SfGetNextN:

; 2499 :             }
; 2500 : 
; 2501 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2502 :          }

	jmp	$LN4@SfGetNextN
$LN5@SfGetNextN:

; 2503 :       }

	jmp	$LN14@SfGetNextN
$LN18@SfGetNextN:

; 2504 :       else
; 2505 :       if ( nLevel == zLEVEL_APPLICATION )

	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 4
	jne	$LN21@SfGetNextN

; 2506 :       {
; 2507 :          // Get the application from the subtask if the view is a subtask
; 2508 :          // view. Otherwise, get the application from the view object if
; 2509 :          // one is present. If all else fails, use the application from
; 2510 :          // the current task.
; 2511 :          fnGetApplicationForSubtask( &lpApp, lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	_fnGetApplicationForSubtask@8

; 2512 :          lpViewName = zGETPTR( lpApp->hFirstViewName );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR [ecx+1893]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN6@SfGetNextN:

; 2513 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	$LN7@SfGetNextN

; 2514 :          {
; 2515 :             if ( zstrcmp( lpViewName->szName, pchReturnName ) == 0 )

	mov	eax, DWORD PTR _lpViewName$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _pchReturnName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN39@SfGetNextN
	mov	ecx, DWORD PTR _pchReturnName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewName$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv223[ebp], eax
	jmp	SHORT $LN40@SfGetNextN
$LN39@SfGetNextN:
	mov	eax, DWORD PTR _lpViewName$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _pchReturnName$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN37@SfGetNextN
	mov	DWORD PTR tv222[ebp], 1
	jmp	SHORT $LN38@SfGetNextN
$LN37@SfGetNextN:
	mov	DWORD PTR tv222[ebp], -1
$LN38@SfGetNextN:
	mov	ecx, DWORD PTR tv222[ebp]
	mov	DWORD PTR tv223[ebp], ecx
$LN40@SfGetNextN:
	cmp	DWORD PTR tv223[ebp], 0
	jne	SHORT $LN23@SfGetNextN

; 2516 :             {
; 2517 :                nRC = zLEVEL_APPLICATION;

	mov	edx, 4
	mov	WORD PTR _nRC$[ebp], dx

; 2518 :                lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2519 :                break;

	jmp	SHORT $LN7@SfGetNextN
$LN23@SfGetNextN:

; 2520 :             }
; 2521 : 
; 2522 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2523 :          }

	jmp	$LN6@SfGetNextN
$LN7@SfGetNextN:

; 2524 :       }

	jmp	$LN14@SfGetNextN
$LN21@SfGetNextN:

; 2525 :       else
; 2526 :       if ( nLevel == zLEVEL_SYSTEM )

	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 8
	jne	$LN14@SfGetNextN

; 2527 :       {
; 2528 :          // Look for the requested name at the system level.
; 2529 :          lpViewName = zGETPTR( AnchorBlock->hFirstViewName );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1489]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN8@SfGetNextN:

; 2530 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	$LN14@SfGetNextN

; 2531 :          {
; 2532 :             if ( zstrcmp( lpViewName->szName, pchReturnName ) == 0 )

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _pchReturnName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN43@SfGetNextN
	mov	edx, DWORD PTR _pchReturnName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewName$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv251[ebp], eax
	jmp	SHORT $LN44@SfGetNextN
$LN43@SfGetNextN:
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _pchReturnName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN41@SfGetNextN
	mov	DWORD PTR tv250[ebp], 1
	jmp	SHORT $LN42@SfGetNextN
$LN41@SfGetNextN:
	mov	DWORD PTR tv250[ebp], -1
$LN42@SfGetNextN:
	mov	edx, DWORD PTR tv250[ebp]
	mov	DWORD PTR tv251[ebp], edx
$LN44@SfGetNextN:
	cmp	DWORD PTR tv251[ebp], 0
	jne	SHORT $LN25@SfGetNextN

; 2533 :             {
; 2534 :                nRC = zLEVEL_SYSTEM;

	mov	eax, 8
	mov	WORD PTR _nRC$[ebp], ax

; 2535 :                lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2536 :                break;

	jmp	SHORT $LN14@SfGetNextN
$LN25@SfGetNextN:

; 2537 :             }
; 2538 : 
; 2539 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2540 :          }

	jmp	$LN8@SfGetNextN
$LN14@SfGetNextN:

; 2541 :       }
; 2542 :    }
; 2543 : 
; 2544 :    // If an lpViewName was found, return the view and name.
; 2545 :    if ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN26@SfGetNextN

; 2546 :    {
; 2547 :       // Set the view to be returned.
; 2548 :       *pvReturnView = zGETPTR( lpViewName->hView );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [ecx], eax

; 2549 :       zstrcpy( pchReturnName, lpViewName->szName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _pchReturnName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2550 :    }

	jmp	SHORT $LN27@SfGetNextN
$LN26@SfGetNextN:

; 2551 :    else
; 2552 :    {
; 2553 :       pchReturnName[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchReturnName$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 2554 :       nRC = -1;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx
$LN27@SfGetNextN:

; 2555 :    }
; 2556 : 
; 2557 :    fnOperationReturn( iSfGetNextNamedView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	219					; 000000dbH
	call	_fnOperationReturn
	add	esp, 8

; 2558 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfGetNextN:

; 2559 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SfGetNextNamedView@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpApp$ = -20						; size = 4
_lpSubtask$ = -16					; size = 4
_lpViewName$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pvReturnView$ = 8					; size = 4
_pchReturnName$ = 12					; size = 4
_lpView$ = 16						; size = 4
_nLevel$ = 20						; size = 2
_SfGetFirstNamedView@16 PROC

; 2319 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2320 :    LPTASK       lpCurrentTask;
; 2321 :    LPSUBTASK    lpSubtask;
; 2322 :    LPVIEWNAME   lpViewName;
; 2323 :    LPAPP        lpApp;
; 2324 :    zSHORT       nRC;
; 2325 : 
; 2326 :    *pvReturnView = 0;      // initialize return view to NULL

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 2327 :    pchReturnName[ 0 ] = 0; // initialize return name

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchReturnName$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 2328 : 
; 2329 :    // If task not active or disabled, return zCALL_ERROR.
; 2330 :    if ( (lpCurrentTask = fnOperationCall( iSfGetFirstNamedView, lpView, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	218					; 000000daH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SfGetFirst

; 2331 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfGetFirst
$LN2@SfGetFirst:

; 2332 : 
; 2333 :    if ( (nLevel == zLEVEL_SUBTASK) &&

	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 1
	jne	SHORT $LN3@SfGetFirst
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidSubtaskView
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN3@SfGetFirst

; 2334 :         (fnValidSubtaskView( lpCurrentTask, lpView )) == 0 )
; 2335 :    {
; 2336 :       fnOperationReturn( iSfGetFirstNamedView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	218					; 000000daH
	call	_fnOperationReturn
	add	esp, 8

; 2337 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfGetFirst
$LN3@SfGetFirst:

; 2338 :    }
; 2339 : 
; 2340 :    if ( (nLevel == zLEVEL_APPLICATION) &&

	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 4
	jne	SHORT $LN4@SfGetFirst
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidView
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN4@SfGetFirst

; 2341 :         (fnValidView( lpCurrentTask, lpView )) == 0 )
; 2342 :    {
; 2343 :       fnOperationReturn( iSfGetFirstNamedView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	218					; 000000daH
	call	_fnOperationReturn
	add	esp, 8

; 2344 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfGetFirst
$LN4@SfGetFirst:

; 2345 :    }
; 2346 : 
; 2347 :    // Check for valid scope.
; 2348 :    if ( nLevel != zLEVEL_SUBTASK     && nLevel != zLEVEL_TASK   &&
; 2349 :         nLevel != zLEVEL_APPLICATION && nLevel != zLEVEL_SYSTEM )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 1
	je	SHORT $LN5@SfGetFirst
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 2
	je	SHORT $LN5@SfGetFirst
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 4
	je	SHORT $LN5@SfGetFirst
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 8
	je	SHORT $LN5@SfGetFirst

; 2350 :    {
; 2351 :       //  "KZOEE110 - Invalid scope for View name"
; 2352 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 110, (zLONG) nLevel, 0, 0 );

	push	0
	push	0
	movsx	ecx, WORD PTR _nLevel$[ebp]
	push	ecx
	push	110					; 0000006eH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2353 :       fnOperationReturn( iSfGetFirstNamedView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	218					; 000000daH
	call	_fnOperationReturn
	add	esp, 8

; 2354 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfGetFirst
$LN5@SfGetFirst:

; 2355 :    }
; 2356 : 
; 2357 :    // Depending on the scope parameter, look in the appropriate
; 2358 :    // name chain for the name requested.
; 2359 :    lpViewName = 0;

	mov	DWORD PTR _lpViewName$[ebp], 0

; 2360 :    if ( nLevel == zLEVEL_SUBTASK )

	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 1
	jne	SHORT $LN6@SfGetFirst

; 2361 :    {
; 2362 :       // Look for the requested name in the subtask.
; 2363 :       lpSubtask = zGETPTR( lpView->hSubtask );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 2364 :       lpViewName = zGETPTR( lpSubtask->hFirstViewName );

	mov	edx, DWORD PTR _lpSubtask$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2365 :       nRC = zLEVEL_SUBTASK;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx

; 2366 :    }

	jmp	$LN7@SfGetFirst
$LN6@SfGetFirst:

; 2367 :    else
; 2368 :    if ( nLevel == zLEVEL_TASK )

	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 2
	jne	SHORT $LN8@SfGetFirst

; 2369 :    {
; 2370 :       // Look for the requested name in the task.
; 2371 :       lpViewName = zGETPTR( lpCurrentTask->hFirstViewName );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+110]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2372 :       nRC = zLEVEL_TASK;

	mov	edx, 2
	mov	WORD PTR _nRC$[ebp], dx

; 2373 :    }

	jmp	SHORT $LN7@SfGetFirst
$LN8@SfGetFirst:

; 2374 :    else
; 2375 :    if ( nLevel == zLEVEL_APPLICATION )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 4
	jne	SHORT $LN10@SfGetFirst

; 2376 :    {
; 2377 :       // Get the application from the subtask if the view is a subtask
; 2378 :       // view. Otherwise, get the application from the view object if
; 2379 :       // one is present. If all else fails, use the application from
; 2380 :       // the current task.
; 2381 : 
; 2382 :       fnGetApplicationForSubtask( &lpApp, lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpApp$[ebp]
	push	edx
	call	_fnGetApplicationForSubtask@8

; 2383 :       lpViewName = zGETPTR( lpApp->hFirstViewName );

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR [eax+1893]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2384 :       nRC = zLEVEL_APPLICATION;

	mov	edx, 4
	mov	WORD PTR _nRC$[ebp], dx

; 2385 :    }

	jmp	SHORT $LN7@SfGetFirst
$LN10@SfGetFirst:

; 2386 :    else
; 2387 :    if ( nLevel == zLEVEL_SYSTEM )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 8
	jne	SHORT $LN7@SfGetFirst

; 2388 :    {
; 2389 :       // Look for the requested name at the system level.
; 2390 :       lpViewName = zGETPTR( AnchorBlock->hFirstViewName );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+1489]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2391 :       nRC = zLEVEL_SYSTEM;

	mov	eax, 8
	mov	WORD PTR _nRC$[ebp], ax
$LN7@SfGetFirst:

; 2392 :    }
; 2393 : 
; 2394 :    // If an lpViewName was found, return the view and name.
; 2395 :    if ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN13@SfGetFirst

; 2396 :    {
; 2397 :       // Set the view to be returned
; 2398 :       *pvReturnView = zGETPTR( lpViewName->hView );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [ecx], eax

; 2399 :       zstrcpy( pchReturnName, lpViewName->szName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _pchReturnName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 2400 :    }

	jmp	SHORT $LN14@SfGetFirst
$LN13@SfGetFirst:

; 2401 :    else
; 2402 :       nRC = -1;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx
$LN14@SfGetFirst:

; 2403 : 
; 2404 :    fnOperationReturn( iSfGetFirstNamedView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	218					; 000000daH
	call	_fnOperationReturn
	add	esp, 8

; 2405 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfGetFirst:

; 2406 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SfGetFirstNamedView@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_SfLockView@4 PROC

; 3456 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3457 :    LPTASK      lpCurrentTask;
; 3458 : 
; 3459 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 3460 :    if ( (lpCurrentTask = fnOperationCall( iSfLockView, lpView,
; 3461 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	214					; 000000d6H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SfLockView

; 3462 :    {
; 3463 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfLockView
$LN2@SfLockView:

; 3464 :    }
; 3465 : 
; 3466 :    // Mark the view as being locked.
; 3467 :    lpView->bViewLocked = TRUE;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 32					; 00000020H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+30], edx

; 3468 : 
; 3469 :    // If execution has fallen this far then everything must have worked.
; 3470 :    fnOperationReturn( iSfLockView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	214					; 000000d6H
	call	_fnOperationReturn
	add	esp, 8

; 3471 :    return( 0 );

	xor	eax, eax
$LN1@SfLockView:

; 3472 : 
; 3473 : }  // SfLockView

	mov	esp, ebp
	pop	ebp
	ret	4
_SfLockView@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_hView$1 = -64						; size = 4
_lpTask$2 = -60						; size = 4
_lpApp$3 = -56						; size = 4
_lpTask$4 = -52						; size = 4
_lpViewOD$5 = -48					; size = 4
_lpViewOD$6 = -44					; size = 4
_lpMainTask$7 = -40					; size = 4
_lpApp$8 = -36						; size = 4
tv82 = -32						; size = 4
tv78 = -28						; size = 4
tv77 = -24						; size = 4
_i$ = -20						; size = 4
_plpFirstView$ = -16					; size = 4
_lpSearchView$9 = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_szDebug$10 = -4					; size = 2
_lpView$ = 8						; size = 4
_lpAppQualView$ = 12					; size = 4
_nScope$ = 16						; size = 2
_SfTransferView@12 PROC

; 3290 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H

; 3291 :    LPTASK      lpCurrentTask;
; 3292 :    zPVIEW      plpFirstView;
; 3293 :    int         i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 3294 :    i = 1 / i;  // this should never be called ... dks 2006.07.10

	mov	eax, 1
	cdq
	idiv	DWORD PTR _i$[ebp]
	mov	DWORD PTR _i$[ebp], eax

; 3295 : 
; 3296 : #if 1
; 3297 :    if ( lpView && lpAppQualView && lpAppQualView->hTask != lpView->hTask )

	cmp	DWORD PTR _lpView$[ebp], 0
	je	$LN4@SfTransfer
	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	$LN4@SfTransfer
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [eax+14]
	cmp	edx, DWORD PTR [ecx+14]
	je	$LN4@SfTransfer

; 3298 :    {
; 3299 :       LPVIEWOD    lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$6[ebp], eax

; 3300 :       TraceLine( "SfTransferView trying to transfer view (0x%08x %s) from Task: "

	movsx	edx, WORD PTR _nScope$[ebp]
	cmp	edx, 4
	jne	SHORT $LN23@SfTransfer
	mov	DWORD PTR tv78[ebp], OFFSET $SG14455
	jmp	SHORT $LN24@SfTransfer
$LN23@SfTransfer:
	movsx	eax, WORD PTR _nScope$[ebp]
	cmp	eax, 8
	jne	SHORT $LN21@SfTransfer
	mov	DWORD PTR tv77[ebp], OFFSET $SG14456
	jmp	SHORT $LN22@SfTransfer
$LN21@SfTransfer:
	mov	DWORD PTR tv77[ebp], OFFSET $SG14457
$LN22@SfTransfer:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv78[ebp], ecx
$LN24@SfTransfer:
	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	je	SHORT $LN25@SfTransfer
	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR tv82[ebp], eax
	jmp	SHORT $LN26@SfTransfer
$LN25@SfTransfer:
	mov	DWORD PTR tv82[ebp], 0
$LN26@SfTransfer:
	mov	ecx, DWORD PTR tv78[ebp]
	push	ecx
	mov	edx, DWORD PTR tv82[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$6[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	OFFSET $SG14458
	call	_TraceLine
	add	esp, 24					; 00000018H
$LN4@SfTransfer:

; 3301 :                     "0x%08x to Task: 0x%08x at Scope: %s",
; 3302 :                  lpView, lpViewOD->szName, lpView->hTask,
; 3303 :                  lpAppQualView ? lpAppQualView->hTask : 0,
; 3304 :                  nScope == zLEVEL_APPLICATION ? "APPLICATION" :
; 3305 :                  nScope == zLEVEL_SYSTEM ? "SYSTEM" : "SCOPE UNKNOWN" );
; 3306 :    }
; 3307 : #endif
; 3308 : 
; 3309 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 3310 :    if ( (lpCurrentTask = fnOperationCall( iSfTransferView, lpView,
; 3311 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	213					; 000000d5H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN5@SfTransfer

; 3312 :    {
; 3313 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfTransfer
$LN5@SfTransfer:

; 3314 :    }
; 3315 : 
; 3316 :    // Verify validity of lpAppQualView if it was supplied.
; 3317 :    if ( (lpAppQualView || nScope == zLEVEL_APPLICATION) &&

	cmp	DWORD PTR _lpAppQualView$[ebp], 0
	jne	SHORT $LN7@SfTransfer
	movsx	edx, WORD PTR _nScope$[ebp]
	cmp	edx, 4
	jne	SHORT $LN6@SfTransfer
$LN7@SfTransfer:
	mov	eax, DWORD PTR _lpAppQualView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidView
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN6@SfTransfer

; 3318 :         fnValidView( lpCurrentTask, lpAppQualView ) == 0 )
; 3319 :    {
; 3320 :       fnOperationReturn( iSfTransferView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	213					; 000000d5H
	call	_fnOperationReturn
	add	esp, 8

; 3321 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfTransfer
$LN6@SfTransfer:

; 3322 :    }
; 3323 : 
; 3324 :    // Check validity of nScope.
; 3325 :    if ( nScope != zLEVEL_APPLICATION && nScope != zLEVEL_SYSTEM )

	movsx	ecx, WORD PTR _nScope$[ebp]
	cmp	ecx, 4
	je	SHORT $LN8@SfTransfer
	movsx	edx, WORD PTR _nScope$[ebp]
	cmp	edx, 8
	je	SHORT $LN8@SfTransfer

; 3326 :    {
; 3327 :       // Invalid scope parm passed.
; 3328 :       // "KZOEE110 - Invalid level for View name"
; 3329 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 110, (zLONG) nScope, 0, 0 );

	push	0
	push	0
	movsx	eax, WORD PTR _nScope$[ebp]
	push	eax
	push	110					; 0000006eH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3330 :       fnOperationReturn( iSfTransferView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	213					; 000000d5H
	call	_fnOperationReturn
	add	esp, 8

; 3331 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfTransfer
$LN8@SfTransfer:

; 3332 :    }
; 3333 : 
; 3334 :    // If view is a subtask (hSubtask has been set), then transfer is
; 3335 :    // invalid--return zCALL_ERROR.
; 3336 :    if ( lpView->hSubtask )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+18], 0
	je	SHORT $LN9@SfTransfer

; 3337 :    {
; 3338 :       // "KZOEE100 - Invalid View, view is a Subtask View"
; 3339 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 100, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	100					; 00000064H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3340 :       fnOperationReturn( iSfTransferView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	213					; 000000d5H
	call	_fnOperationReturn
	add	esp, 8

; 3341 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfTransfer
$LN9@SfTransfer:

; 3342 :    }
; 3343 : 
; 3344 :    // View cannot be connected to a valid object instance.  Check to see if
; 3345 :    // the cursor pointer points to anything--if it does, then the view has an
; 3346 :    // object instance and cannot be transferred.
; 3347 :    if ( lpView->hViewCsr )

	mov	edx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [edx+10], 0
	je	SHORT $LN10@SfTransfer

; 3348 :    {
; 3349 :       LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$5[ebp], eax

; 3350 : 
; 3351 :       // "KZOEE113 - Invalid View, view contains an instance"
; 3352 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 113, 0, lpViewOD->szName, 0 );

	push	0
	mov	edx, DWORD PTR _lpViewOD$5[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	0
	push	113					; 00000071H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3353 :       fnOperationReturn( iSfTransferView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	213					; 000000d5H
	call	_fnOperationReturn
	add	esp, 8

; 3354 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfTransfer
$LN10@SfTransfer:

; 3355 :    }
; 3356 : 
; 3357 :    // We have validated everything ... for sure the level is APPLICATION or
; 3358 :    // SYSTEM when we get here.
; 3359 : 
; 3360 :    // Remove view from task or application.  First set the pointer to point
; 3361 :    // to the lpFirstView pointer in either the application structure or the
; 3362 :    // task structure depending on lpView->bApplicationView.
; 3363 :    if ( lpView->bApplicationView )

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN11@SfTransfer

; 3364 :    {
; 3365 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$4[ebp], eax

; 3366 :       LPAPP  lpApp  = zGETPTR( lpTask->hApp );

	mov	ecx, DWORD PTR _lpTask$4[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$3[ebp], eax

; 3367 : 
; 3368 :       plpFirstView = &(lpApp->hFirstView);

	mov	eax, DWORD PTR _lpApp$3[ebp]
	add	eax, 1889				; 00000761H
	mov	DWORD PTR _plpFirstView$[ebp], eax

; 3369 :    }

	jmp	SHORT $LN12@SfTransfer
$LN11@SfTransfer:

; 3370 :    else
; 3371 :    {
; 3372 :       LPTASK lpTask = zGETPTR( lpView->hTask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax

; 3373 : 
; 3374 :       plpFirstView = &(lpTask->hFirstView);

	mov	eax, DWORD PTR _lpTask$2[ebp]
	add	eax, 106				; 0000006aH
	mov	DWORD PTR _plpFirstView$[ebp], eax
$LN12@SfTransfer:

; 3375 :    }
; 3376 : 
; 3377 :    // Remove lpView from the view chain.
; 3378 :    if ( *plpFirstView == zGETHNDL( lpView ) )

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _plpFirstView$[ebp]
	cmp	DWORD PTR [edx], eax
	jne	SHORT $LN13@SfTransfer

; 3379 :       *plpFirstView = lpView->hNextView;

	mov	eax, DWORD PTR _plpFirstView$[ebp]
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN14@SfTransfer
$LN13@SfTransfer:

; 3380 :    else
; 3381 :    {
; 3382 :       zVIEW  lpSearchView;
; 3383 :       zVIEW  hView = zGETHNDL( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hView$1[ebp], eax

; 3384 : 
; 3385 :       lpSearchView = zGETPTR( *plpFirstView );

	mov	ecx, DWORD PTR _plpFirstView$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchView$9[ebp], eax
$LN2@SfTransfer:

; 3386 :       while ( lpSearchView && lpSearchView->hNextView != hView )   // DKS 2003.12.17

	cmp	DWORD PTR _lpSearchView$9[ebp], 0
	je	SHORT $LN3@SfTransfer
	mov	eax, DWORD PTR _lpSearchView$9[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hView$1[ebp]
	je	SHORT $LN3@SfTransfer

; 3387 :          lpSearchView = zGETPTR( lpSearchView->hNextView );

	mov	edx, DWORD PTR _lpSearchView$9[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearchView$9[ebp], eax
	jmp	SHORT $LN2@SfTransfer
$LN3@SfTransfer:

; 3388 : 
; 3389 :       if ( lpSearchView )

	cmp	DWORD PTR _lpSearchView$9[ebp], 0
	je	SHORT $LN14@SfTransfer

; 3390 :          lpSearchView->hNextView = lpView->hNextView;

	mov	ecx, DWORD PTR _lpSearchView$9[ebp]
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+2]
	mov	DWORD PTR [ecx+2], eax
$LN14@SfTransfer:

; 3391 :    }
; 3392 : 
; 3393 :    // Add view to application object or system task.  If scope is an
; 3394 :    // application, then find the target application from the AppQualView via
; 3395 :    // the View object definition.
; 3396 :    if ( nScope == zLEVEL_APPLICATION )

	movsx	ecx, WORD PTR _nScope$[ebp]
	cmp	ecx, 4
	jne	SHORT $LN16@SfTransfer

; 3397 :    {
; 3398 :       // If the app qual view has a subtask, then move the source view to
; 3399 :       // application pointed to by the subtask.  If the app qual view doesn't
; 3400 :       // have a subtask, then find the application through the app qual view
; 3401 :       // object definition.
; 3402 :       LPAPP lpApp;
; 3403 : 
; 3404 :       fnGetApplicationForSubtask( &lpApp, lpAppQualView );

	mov	edx, DWORD PTR _lpAppQualView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpApp$8[ebp]
	push	eax
	call	_fnGetApplicationForSubtask@8

; 3405 : 
; 3406 :       lpView->hNextView = lpApp->hFirstView;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR _lpApp$8[ebp]
	mov	eax, DWORD PTR [edx+1889]
	mov	DWORD PTR [ecx+2], eax

; 3407 :       lpApp->hFirstView = zGETHNDL( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpApp$8[ebp]
	mov	DWORD PTR [edx+1889], eax

; 3408 :       lpView->hTask = AnchorBlock->hMainTask;  // view is now part of main  // don't do this ... dks 2004.10.14

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+106]
	mov	DWORD PTR [eax+14], edx

; 3409 :       lpView->bApplicationView = TRUE;         // indicate that scope is app

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 8
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+30], ecx

; 3410 :    }

	jmp	SHORT $LN17@SfTransfer
$LN16@SfTransfer:

; 3411 :    else
; 3412 : // if ( nScope == zLEVEL_SYSTEM )  must be true
; 3413 :    {
; 3414 :       LPTASK lpMainTask = zGETPTR( AnchorBlock->hMainTask );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpMainTask$7[ebp], eax

; 3415 : 
; 3416 :       lpView->hNextView = lpMainTask->hFirstView;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR _lpMainTask$7[ebp]
	mov	ecx, DWORD PTR [eax+106]
	mov	DWORD PTR [edx+2], ecx

; 3417 :       lpMainTask->hFirstView = zGETHNDL( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpMainTask$7[ebp]
	mov	DWORD PTR [ecx+106], eax

; 3418 :       lpView->hTask = AnchorBlock->hMainTask;  // view is now part of main

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+106]
	mov	DWORD PTR [edx+14], ecx

; 3419 :       lpView->bApplicationView = FALSE;        // indicate that scope is sys

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	and	eax, -9					; fffffff7H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax
$LN17@SfTransfer:

; 3420 :    }
; 3421 : 
; 3422 :    if ( lpView->hNextView == zGETHNDL( lpView ) )

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+2], eax
	jne	SHORT $LN18@SfTransfer

; 3423 :    {
; 3424 :       zCHAR szDebug[ 2 ];
; 3425 : 
; 3426 :       SysReadZeidonIni( -1, "[Debug]", "BombZDr", szDebug );

	lea	edx, DWORD PTR _szDebug$10[ebp]
	push	edx
	push	OFFSET $SG14473
	push	OFFSET $SG14474
	push	-1
	call	_SysReadZeidonIni@16

; 3427 :       if ( szDebug[ 0 ] == 'Y' )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szDebug$10[ebp+ecx]
	cmp	edx, 89					; 00000059H
	jne	SHORT $LN18@SfTransfer

; 3428 :          SysMessageBox( 0, "Houston ... we have a problem", "Recursive view", -1 );

	push	-1
	push	OFFSET $SG14476
	push	OFFSET $SG14477
	push	0
	call	_SysMessageBox@16
$LN18@SfTransfer:

; 3429 :    }
; 3430 : 
; 3431 :    // If execution has fallen this far, then everything must have worked.
; 3432 :    fnOperationReturn( iSfTransferView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	213					; 000000d5H
	call	_fnOperationReturn
	add	esp, 8

; 3433 :    return( 0 );

	xor	eax, eax
$LN1@SfTransfer:

; 3434 : }  // SfTransferView

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_SfTransferView@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpTask$ = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_cpcUserId$ = 12					; size = 4
_SfSetUserIdForTask@8 PROC

; 3211 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3212 :    LPTASK    lpTask;
; 3213 : 
; 3214 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 3215 :    if ( (lpTask = fnOperationCall( iSfSetUserIdForTask, lpTaskView,
; 3216 :                                    zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	push	227					; 000000e3H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@SfSetUserI

; 3217 :    {
; 3218 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfSetUserI
$LN2@SfSetUserI:

; 3219 :    }
; 3220 : 
; 3221 :    lpTask->szUserId[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	BYTE PTR [eax+edx+244], 0

; 3222 :    zstrncat( lpTask->szUserId, cpcUserId, 33 );

	push	33					; 00000021H
	mov	ecx, DWORD PTR _cpcUserId$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	add	edx, 244				; 000000f4H
	push	edx
	call	DWORD PTR __imp__strncat
	add	esp, 12					; 0000000cH

; 3223 : 
; 3224 :    fnOperationReturn( iSfSetUserIdForTask, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	227					; 000000e3H
	call	_fnOperationReturn
	add	esp, 8

; 3225 :    return( 0 );

	xor	eax, eax
$LN1@SfSetUserI:

; 3226 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SfSetUserIdForTask@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpTask$ = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_pchUserId$ = 12					; size = 4
_SfGetUserIdForTask@8 PROC

; 3247 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 3248 :    LPTASK    lpTask;
; 3249 : 
; 3250 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 3251 :    if ( (lpTask = fnOperationCall( iSfGetUserIdForTask, lpTaskView,
; 3252 :                                    zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	push	226					; 000000e2H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@SfGetUserI

; 3253 :    {
; 3254 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfGetUserI
$LN2@SfGetUserI:

; 3255 :    }
; 3256 : 
; 3257 :    zstrcpy( pchUserId, lpTask->szUserId );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	add	ecx, 244				; 000000f4H
	push	ecx
	mov	edx, DWORD PTR _pchUserId$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 3258 : 
; 3259 :    fnOperationReturn( iSfGetUserIdForTask, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	226					; 000000e2H
	call	_fnOperationReturn
	add	esp, 8

; 3260 :    return( 0 );

	xor	eax, eax
$LN1@SfGetUserI:

; 3261 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SfGetUserIdForTask@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpApp$ = -12						; size = 4
_lpTask$ = -8						; size = 4
_nRC$ = -4						; size = 2
_lpTaskView$ = 8					; size = 4
_lFlags$ = 12						; size = 4
_SfSetApplicationTask@8 PROC

; 3161 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3162 :    LPAPP     lpApp;
; 3163 :    LPTASK    lpTask;
; 3164 :    zSHORT    nRC;
; 3165 : 
; 3166 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 3167 :    if ( lFlags != 0 ||

	cmp	DWORD PTR _lFlags$[ebp], 0
	jne	SHORT $LN3@SfSetAppli
	push	1
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	push	225					; 000000e1H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpTask$[ebp], eax
	cmp	DWORD PTR _lpTask$[ebp], 0
	jne	SHORT $LN2@SfSetAppli
$LN3@SfSetAppli:

; 3168 :         (lpTask = fnOperationCall( iSfSetApplicationTask, lpTaskView,
; 3169 :                                    zVALID_VIEW )) == 0 )
; 3170 :    {
; 3171 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfSetAppli
$LN2@SfSetAppli:

; 3172 :    }
; 3173 : 
; 3174 :    lpApp = zGETPTR( lpTask->hApp );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 3175 :    if ( lpApp->hApplicationTask == 0 )

	mov	eax, DWORD PTR _lpApp$[ebp]
	cmp	DWORD PTR [eax+1901], 0
	jne	SHORT $LN4@SfSetAppli

; 3176 :    {
; 3177 :       TraceLine( "SfSetApplicationTask for App: %s   Task: 0x%08x",

	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 6
	push	eax
	push	OFFSET $SG14403
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 3178 :                  lpApp->szName, lpTaskView->hTask );
; 3179 :       lpApp->hApplicationTask = lpTaskView->hTask;

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR [ecx+1901], eax

; 3180 :       lpTask->bApplicationTask = TRUE;

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+443]
	or	edx, 8192				; 00002000H
	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	DWORD PTR [eax+443], edx

; 3181 :       nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 3182 :    }

	jmp	SHORT $LN5@SfSetAppli
$LN4@SfSetAppli:

; 3183 :    else
; 3184 :    {
; 3185 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN5@SfSetAppli:

; 3186 :    }
; 3187 : 
; 3188 :    fnOperationReturn( iSfSetApplicationTask, lpTask );

	mov	eax, DWORD PTR _lpTask$[ebp]
	push	eax
	push	225					; 000000e1H
	call	_fnOperationReturn
	add	esp, 8

; 3189 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfSetAppli:

; 3190 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SfSetApplicationTask@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpSubtask$ = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpNextSubtask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pvReturnSubtask$ = 8					; size = 4
_lpSubtaskView$ = 12					; size = 4
_SfGetNextSubtaskView@8 PROC

; 3110 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3111 :    LPTASK      lpCurrentTask;
; 3112 :    LPSUBTASK   lpNextSubtask;
; 3113 :    LPSUBTASK   lpSubtask;
; 3114 :    zSHORT      nRC;
; 3115 : 
; 3116 :    *pvReturnSubtask = 0;

	mov	eax, DWORD PTR _pvReturnSubtask$[ebp]
	mov	DWORD PTR [eax], 0

; 3117 : 
; 3118 :    // If task not active or disabled, or subtask view invalid, return zCALL_ERROR.
; 3119 :    if ( (lpCurrentTask = fnOperationCall( iSfGetNextSubtaskView, lpSubtaskView,
; 3120 :                                           zVALID_SUBTASK_VIEW )) == 0 )

	push	3
	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	push	ecx
	push	210					; 000000d2H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SfGetNextS

; 3121 :    {
; 3122 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfGetNextS
$LN2@SfGetNextS:

; 3123 :    }
; 3124 : 
; 3125 :    // Get next subtask view based on the current subtask.
; 3126 :    lpSubtask     = zGETPTR( lpSubtaskView->hSubtask );

	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 3127 :    lpNextSubtask = zGETPTR( lpSubtask->hNextSubtask );

	mov	ecx, DWORD PTR _lpSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextSubtask$[ebp], eax

; 3128 :    if ( lpNextSubtask )

	cmp	DWORD PTR _lpNextSubtask$[ebp], 0
	je	SHORT $LN3@SfGetNextS

; 3129 :    {
; 3130 :       nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 3131 :       *pvReturnSubtask = zGETPTR( lpNextSubtask->hSubtaskView );

	mov	ecx, DWORD PTR _lpNextSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _pvReturnSubtask$[ebp]
	mov	DWORD PTR [ecx], eax

; 3132 :    }

	jmp	SHORT $LN4@SfGetNextS
$LN3@SfGetNextS:

; 3133 :    else
; 3134 :    {
; 3135 :       nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
$LN4@SfGetNextS:

; 3136 :    }
; 3137 : 
; 3138 :    fnOperationReturn( iSfGetNextSubtaskView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	210					; 000000d2H
	call	_fnOperationReturn
	add	esp, 8

; 3139 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfGetNextS:

; 3140 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SfGetNextSubtaskView@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpSubtask$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pvReturnSubtask$ = 8					; size = 4
_vTaskView$ = 12					; size = 4
_SfGetFirstSubtaskView@8 PROC

; 3065 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3066 :    LPTASK      lpCurrentTask;
; 3067 :    LPSUBTASK   lpSubtask;
; 3068 :    zSHORT      nRC;
; 3069 : 
; 3070 :    *pvReturnSubtask = 0;

	mov	eax, DWORD PTR _pvReturnSubtask$[ebp]
	mov	DWORD PTR [eax], 0

; 3071 : 
; 3072 :    // If task not active or disabled, return zCALL_ERROR.
; 3073 :    if ( (lpCurrentTask = fnOperationCall( iSfGetFirstSubtaskView, vTaskView, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _vTaskView$[ebp]
	push	ecx
	push	209					; 000000d1H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SfGetFirst

; 3074 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfGetFirst
$LN2@SfGetFirst:

; 3075 : 
; 3076 :    // Get first subtask.
; 3077 :    lpSubtask = zGETPTR( lpCurrentTask->hFirstSubtask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 3078 :    if ( lpSubtask )

	cmp	DWORD PTR _lpSubtask$[ebp], 0
	je	SHORT $LN3@SfGetFirst

; 3079 :    {
; 3080 :       nRC = 0;

	xor	ecx, ecx
	mov	WORD PTR _nRC$[ebp], cx

; 3081 :       *pvReturnSubtask = zGETPTR( lpSubtask->hSubtaskView );

	mov	edx, DWORD PTR _lpSubtask$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _pvReturnSubtask$[ebp]
	mov	DWORD PTR [ecx], eax

; 3082 :    }

	jmp	SHORT $LN4@SfGetFirst
$LN3@SfGetFirst:

; 3083 :    else
; 3084 :    {
; 3085 :       nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
$LN4@SfGetFirst:

; 3086 :    }
; 3087 : 
; 3088 :    fnOperationReturn( iSfGetFirstSubtaskView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	209					; 000000d1H
	call	_fnOperationReturn
	add	esp, 8

; 3089 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfGetFirst:

; 3090 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SfGetFirstSubtaskView@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpSubtask$1 = -12					; size = 4
_lpViewOD$2 = -8					; size = 4
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lpCurrentSubtaskView$ = 12				; size = 4
_SfSetSubtaskView@8 PROC

; 1466 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1467 :    LPTASK      lpCurrentTask;
; 1468 : 
; 1469 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 1470 :    if ( (lpCurrentTask = fnOperationCall( iSetSubtaskView, lpView,
; 1471 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	207					; 000000cfH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SfSetSubta

; 1472 :    {
; 1473 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfSetSubta
$LN2@SfSetSubta:

; 1474 :    }
; 1475 : 
; 1476 :    if ( (fnValidSubtaskView( lpCurrentTask, lpCurrentSubtaskView )) == 0 )

	mov	ecx, DWORD PTR _lpCurrentSubtaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidSubtaskView
	add	esp, 8
	cwde
	test	eax, eax
	jne	SHORT $LN3@SfSetSubta

; 1477 :    {
; 1478 :       fnOperationReturn( iSetSubtaskView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	207					; 000000cfH
	call	_fnOperationReturn
	add	esp, 8

; 1479 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfSetSubta
$LN3@SfSetSubta:

; 1480 :    }
; 1481 : 
; 1482 :    if ( lpView->hTask != lpCurrentSubtaskView->hTask )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR _lpCurrentSubtaskView$[ebp]
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+14]
	je	SHORT $LN4@SfSetSubta

; 1483 :    {
; 1484 :       //  "KZOEE111 - Attempt to set subtask view with a view from "
; 1485 :       //  "           another task"
; 1486 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 111, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	111					; 0000006fH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1487 :       fnOperationReturn( iSetSubtaskView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	207					; 000000cfH
	call	_fnOperationReturn
	add	esp, 8

; 1488 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfSetSubta
$LN4@SfSetSubta:

; 1489 :    }
; 1490 : 
; 1491 :    if ( lpView->bApplicationView )

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 3
	and	eax, 1
	je	SHORT $LN5@SfSetSubta

; 1492 :    {
; 1493 :       LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$2[ebp], eax

; 1494 : 
; 1495 :       //  "KZOEE112 - Attempt to set subtask view attached to an application"
; 1496 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 112, 0, lpViewOD->szName, 0 );

	push	0
	mov	eax, DWORD PTR _lpViewOD$2[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	push	0
	push	112					; 00000070H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1497 :       fnOperationReturn( iSetSubtaskView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	207					; 000000cfH
	call	_fnOperationReturn
	add	esp, 8

; 1498 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfSetSubta
$LN5@SfSetSubta:

; 1499 :    }
; 1500 : 
; 1501 :    if ( lpView != lpCurrentSubtaskView )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	ecx, DWORD PTR _lpCurrentSubtaskView$[ebp]
	je	$LN6@SfSetSubta

; 1502 :    {
; 1503 :       LPSUBTASK lpSubtask;
; 1504 : 
; 1505 :       if ( lpView->hSubtask )

	mov	edx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $LN7@SfSetSubta

; 1506 :       {
; 1507 :          //  "KZOEE100 - Invalid View, view is already a Subtask View"
; 1508 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 100, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	100					; 00000064H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1509 :          fnOperationReturn( iSetSubtaskView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	207					; 000000cfH
	call	_fnOperationReturn
	add	esp, 8

; 1510 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SfSetSubta
$LN7@SfSetSubta:

; 1511 :       }
; 1512 : 
; 1513 :       lpView->hSubtask = lpCurrentSubtaskView->hSubtask;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR _lpCurrentSubtaskView$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	mov	DWORD PTR [eax+18], edx

; 1514 :       lpView->bViewLocked = TRUE;  // Subtask Views get locked automatically

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+30], ecx

; 1515 :       lpCurrentSubtaskView->hSubtask = 0;

	mov	eax, DWORD PTR _lpCurrentSubtaskView$[ebp]
	mov	DWORD PTR [eax+18], 0

; 1516 :       lpCurrentSubtaskView->bViewLocked = 0; // Unlock view, no longer subtask

	mov	ecx, DWORD PTR _lpCurrentSubtaskView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	and	edx, -33				; ffffffdfH
	mov	eax, DWORD PTR _lpCurrentSubtaskView$[ebp]
	mov	DWORD PTR [eax+30], edx

; 1517 :       lpSubtask = zGETPTR( lpView->hSubtask );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$1[ebp], eax

; 1518 :       lpSubtask->hSubtaskView = zGETHNDL( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpSubtask$1[ebp]
	mov	DWORD PTR [ecx+14], eax

; 1519 : 
; 1520 :       // If the view has no ViewOD associated with it, then drop the view.
; 1521 :       if ( lpCurrentSubtaskView->hViewOD == 0 )

	mov	edx, DWORD PTR _lpCurrentSubtaskView$[ebp]
	cmp	DWORD PTR [edx+6], 0
	jne	SHORT $LN6@SfSetSubta

; 1522 :          fnDropView( lpCurrentSubtaskView );

	mov	eax, DWORD PTR _lpCurrentSubtaskView$[ebp]
	push	eax
	call	_fnDropView@4
$LN6@SfSetSubta:

; 1523 :    }
; 1524 : 
; 1525 :    fnOperationReturn( iSetSubtaskView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	207					; 000000cfH
	call	_fnOperationReturn
	add	esp, 8

; 1526 :    return( 0 );

	xor	eax, eax
$LN1@SfSetSubta:

; 1527 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SfSetSubtaskView@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_ResetViewPositions@4 PROC

; 2616 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2617 :    LPTASK  lpCurrentTask;
; 2618 :    zSHORT  nRC;
; 2619 : 
; 2620 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 2621 :    if ( (lpCurrentTask = fnOperationCall( iResetViewPositions, lpView,
; 2622 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	221					; 000000ddH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@ResetViewP

; 2623 :    {
; 2624 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@ResetViewP
$LN2@ResetViewP:

; 2625 :    }
; 2626 : 
; 2627 :    // Call fnResetView to reset the view without resetting select sets
; 2628 :    nRC = fnResetView( lpView, 1 );

	push	1
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetView
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 2629 : 
; 2630 :    // We're done, return success
; 2631 :    fnOperationReturn( iResetViewPositions, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	221					; 000000ddH
	call	_fnOperationReturn
	add	esp, 8

; 2632 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@ResetViewP:

; 2633 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_ResetViewPositions@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_ResetView@4 PROC

; 2579 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2580 :    LPTASK  lpCurrentTask;
; 2581 :    zSHORT  nRC;
; 2582 : 
; 2583 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 2584 :    if ( (lpCurrentTask = fnOperationCall( iResetView, lpView,
; 2585 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	211					; 000000d3H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@ResetView

; 2586 :    {
; 2587 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@ResetView
$LN2@ResetView:

; 2588 :    }
; 2589 : 
; 2590 :    // Call fnResetView to reset the view.
; 2591 :    nRC = fnResetView( lpView, 0 );

	push	0
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetView
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 2592 : 
; 2593 :    // We're done, return success
; 2594 :    fnOperationReturn( iResetView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	211					; 000000d3H
	call	_fnOperationReturn
	add	esp, 8

; 2595 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@ResetView:

; 2596 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_ResetView@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpViewParentEntityInstance$ = -20			; size = 4
_lpViewSubobject$ = -16					; size = 4
_lpViewCsr$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_ResetViewFromSubobjectWithoutError@4 PROC

; 2785 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2786 :    LPTASK            lpCurrentTask;
; 2787 :    LPVIEWCSR         lpViewCsr;
; 2788 :    LPVIEWSUBOBJECT   lpViewSubobject;
; 2789 :    LPENTITYINSTANCE  lpViewParentEntityInstance;
; 2790 :    zSHORT            nRC;
; 2791 : 
; 2792 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 2793 :    if ( (lpCurrentTask = fnOperationCall( iResetViewFromSubobject, lpView,
; 2794 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	203					; 000000cbH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@ResetViewF

; 2795 :    {
; 2796 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ResetViewF
$LN2@ResetViewF:

; 2797 :    }
; 2798 : 
; 2799 :    // Get the ViewCsr for the view
; 2800 :    lpViewCsr       = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2801 :    lpViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$[ebp], eax

; 2802 : 
; 2803 :    // Check to make sure that the subobject entity is not already the
; 2804 :    // root of the view
; 2805 :    if ( lpViewSubobject == 0 )

	cmp	DWORD PTR _lpViewSubobject$[ebp], 0
	jne	SHORT $LN3@ResetViewF

; 2806 :    {
; 2807 :       fnOperationReturn( iResetViewFromSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	203					; 000000cbH
	call	_fnOperationReturn
	add	esp, 8

; 2808 :       return( 1 );

	mov	eax, 1
	jmp	SHORT $LN1@ResetViewF
$LN3@ResetViewF:

; 2809 :    }
; 2810 : 
; 2811 :    lpViewParentEntityInstance = zGETPTR( lpViewCsr->hViewParentEntityInstance );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewParentEntityInstance$[ebp], eax

; 2812 :    if ( lpViewParentEntityInstance->u.nInd.bHidden )

	mov	edx, DWORD PTR _lpViewParentEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN4@ResetViewF

; 2813 :    {
; 2814 :       //  "KZOEE273 - Parent Entity instance for View deleted"
; 2815 :    // fnIssueCoreError( lpCurrentTask, lpView, 8, 273, 0,
; 2816 :    //                   fnEntityNameFromInstance( lpViewParentEntityInstance ),
; 2817 :    //                   0 );
; 2818 :       fnOperationReturn( iResetViewFromSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	203					; 000000cbH
	call	_fnOperationReturn
	add	esp, 8

; 2819 :       return( -1 );

	or	eax, -1
	jmp	SHORT $LN1@ResetViewF
$LN4@ResetViewF:

; 2820 :    }
; 2821 : 
; 2822 :    // If we're in hierarchical mode, then reset is not allowed
; 2823 :    if ( lpViewCsr->hHierRootEntityInstance )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN5@ResetViewF

; 2824 :    {
; 2825 :       //  "KZOEE264 - Invalid Operation for Hierarchical processing"
; 2826 :    // fnIssueCoreError( lpCurrentTask, lpView, 8, 264, 0, 0, 0 );
; 2827 :       fnOperationReturn( iResetViewFromSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	203					; 000000cbH
	call	_fnOperationReturn
	add	esp, 8

; 2828 :       return( -2 );

	mov	eax, -2					; fffffffeH
	jmp	SHORT $LN1@ResetViewF
$LN5@ResetViewF:

; 2829 :    }
; 2830 : 
; 2831 :    // OK subobject is in-hand, reset from the subobject to the
; 2832 :    // previous subobject level.
; 2833 :    nRC = fnResetViewFromSubobject( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnResetViewFromSubobject
	add	esp, 4
	mov	WORD PTR _nRC$[ebp], ax

; 2834 : 
; 2835 :    fnOperationReturn( iResetViewFromSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	203					; 000000cbH
	call	_fnOperationReturn
	add	esp, 8

; 2836 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@ResetViewF:

; 2837 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_ResetViewFromSubobjectWithoutError@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpView$ = 8						; size = 4
_ResetViewFromSubobjectTop@4 PROC

; 2930 : {

	push	ebp
	mov	ebp, esp
$LN2@ResetViewF:

; 2931 :    while ( ResetViewFromSubobjectWithoutError( lpView ) == 0 )

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_ResetViewFromSubobjectWithoutError@4
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN3@ResetViewF

; 2932 :    {
; 2933 :    }

	jmp	SHORT $LN2@ResetViewF
$LN3@ResetViewF:

; 2934 :    return( 0 );

	xor	eax, eax

; 2935 : }

	pop	ebp
	ret	4
_ResetViewFromSubobjectTop@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpViewSubobject$ = -20					; size = 4
_lpViewParentEntityInstance$ = -16			; size = 4
_lpViewCsr$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_ResetViewFromSubobject@4 PROC

; 2860 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2861 :    LPTASK            lpCurrentTask;
; 2862 :    LPVIEWCSR         lpViewCsr;
; 2863 :    LPVIEWSUBOBJECT   lpViewSubobject;
; 2864 :    LPENTITYINSTANCE  lpViewParentEntityInstance;
; 2865 :    zSHORT            nRC;
; 2866 : 
; 2867 :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 2868 :    if ( (lpCurrentTask = fnOperationCall( iResetViewFromSubobject, lpView,
; 2869 :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	203					; 000000cbH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@ResetViewF

; 2870 :    {
; 2871 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ResetViewF
$LN2@ResetViewF:

; 2872 :    }
; 2873 : 
; 2874 :    // Get the ViewCsr for the view
; 2875 :    lpViewCsr       = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2876 :    lpViewSubobject = zGETPTR( lpViewCsr->hFirstViewSubobject );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewSubobject$[ebp], eax

; 2877 : 
; 2878 :    // Check to make sure that the subobject entity is not already the
; 2879 :    // root of the view
; 2880 :    if ( lpViewSubobject == 0 )

	cmp	DWORD PTR _lpViewSubobject$[ebp], 0
	jne	SHORT $LN3@ResetViewF

; 2881 :    {
; 2882 :       fnOperationReturn( iResetViewFromSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	203					; 000000cbH
	call	_fnOperationReturn
	add	esp, 8

; 2883 :       return( 1 );

	mov	eax, 1
	jmp	$LN1@ResetViewF
$LN3@ResetViewF:

; 2884 :    }
; 2885 : 
; 2886 :    lpViewParentEntityInstance = zGETPTR( lpViewCsr->hViewParentEntityInstance );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+38]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewParentEntityInstance$[ebp], eax

; 2887 :    if ( lpViewParentEntityInstance->u.nInd.bHidden )

	mov	edx, DWORD PTR _lpViewParentEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN4@ResetViewF

; 2888 :    {
; 2889 :       //  "KZOEE273 - Parent Entity instance for View deleted"
; 2890 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 273, 0,

	push	0
	mov	ecx, DWORD PTR _lpViewParentEntityInstance$[ebp]
	push	ecx
	call	_fnEntityNameFromInstance@4
	push	eax
	push	0
	push	273					; 00000111H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2891 :                         fnEntityNameFromInstance( lpViewParentEntityInstance ),
; 2892 :                         0 );
; 2893 :       fnOperationReturn( iResetViewFromSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	203					; 000000cbH
	call	_fnOperationReturn
	add	esp, 8

; 2894 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@ResetViewF
$LN4@ResetViewF:

; 2895 :    }
; 2896 : 
; 2897 :    // If we're in hierarchical mode, then reset is not allowed
; 2898 :    if ( lpViewCsr->hHierRootEntityInstance )

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN5@ResetViewF

; 2899 :    {
; 2900 :       //  "KZOEE264 - Invalid Operation for Hierarchical processing"
; 2901 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 264, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	264					; 00000108H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2902 :       fnOperationReturn( iResetViewFromSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	203					; 000000cbH
	call	_fnOperationReturn
	add	esp, 8

; 2903 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@ResetViewF
$LN5@ResetViewF:

; 2904 :    }
; 2905 : 
; 2906 :    // OK subobject is in-hand, reset from the subobject to the
; 2907 :    // previous subobject level.
; 2908 :    nRC = fnResetViewFromSubobject( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_fnResetViewFromSubobject
	add	esp, 4
	mov	WORD PTR _nRC$[ebp], ax

; 2909 : 
; 2910 :    fnOperationReturn( iResetViewFromSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	203					; 000000cbH
	call	_fnOperationReturn
	add	esp, 8

; 2911 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@ResetViewF:

; 2912 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_ResetViewFromSubobject@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpEntityInstance$ = -36				; size = 4
_lpViewOD$1 = -32					; size = 4
_lpViewOI$2 = -28					; size = 4
_lpViewEntity$ = -24					; size = 4
_lpViewCsr$ = -20					; size = 4
_lpViewRootParentCsr$ = -16				; size = 4
_lpViewEntityCsr$ = -12					; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcSubobjectEntityName$ = 12				; size = 4
_SetViewToSubobject@8 PROC

; 2659 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H

; 2660 :    LPTASK            lpCurrentTask;
; 2661 :    LPVIEWCSR         lpViewCsr;
; 2662 :    LPVIEWENTITY      lpViewEntity;
; 2663 :    LPVIEWENTITYCSR   lpViewRootParentCsr;
; 2664 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 2665 :    LPENTITYINSTANCE  lpEntityInstance;
; 2666 :    zSHORT            nRC;
; 2667 : 
; 2668 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 2669 :    if ( (lpCurrentTask = fnOperationCall( iSetViewToSubobject, lpView,
; 2670 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	202					; 000000caH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SetViewToS

; 2671 :    {
; 2672 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetViewToS
$LN2@SetViewToS:

; 2673 :    }
; 2674 : 
; 2675 :    // Get the ViewCsr for the view
; 2676 :    lpViewCsr = zGETPTR( lpView->hViewCsr );

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 2677 : 
; 2678 :    // Validate that the entity exists
; 2679 :    if ( (lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpView,
; 2680 :                                            cpcSubobjectEntityName, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _cpcSubobjectEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax
	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN3@SetViewToS

; 2681 :    {
; 2682 :       fnOperationReturn( iSetViewToSubobject, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	202					; 000000caH
	call	_fnOperationReturn
	add	esp, 8

; 2683 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetViewToS
$LN3@SetViewToS:

; 2684 :    }
; 2685 : 
; 2686 :    // Check to make sure that the subobject entity is not the root
; 2687 :    // root of the view object definition
; 2688 :    if ( zGETPTR( lpViewCsr->hFirstOD_EntityCsr ) == lpViewEntityCsr )

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	jne	SHORT $LN4@SetViewToS

; 2689 :    {
; 2690 :       LPVIEWOI lpViewOI = zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$2[ebp], eax

; 2691 :       LPVIEWOD lpViewOD = zGETPTR( lpViewOI->hViewOD );

	mov	edx, DWORD PTR _lpViewOI$2[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$1[ebp], eax

; 2692 : 
; 2693 :       //  "KZOEE271 - Subobject Entity is root of View Object Definition"
; 2694 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 271, 0,

	mov	ecx, DWORD PTR _lpViewOD$1[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	271					; 0000010fH
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2695 :                         fnEntityNameFromCsr( lpViewEntityCsr ),
; 2696 :                         lpViewOD->szName );
; 2697 :       fnOperationReturn( iSetViewToSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	202					; 000000caH
	call	_fnOperationReturn
	add	esp, 8

; 2698 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetViewToS
$LN4@SetViewToS:

; 2699 :    }
; 2700 : 
; 2701 :    // Check to make sure that the subobject entity is not already the
; 2702 :    // root of the view, if so return a 1
; 2703 :    if ( zGETPTR( lpViewCsr->hRootViewEntityCsr ) == lpViewEntityCsr )

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	jne	SHORT $LN5@SetViewToS

; 2704 :    {
; 2705 :       fnOperationReturn( iSetViewToSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	202					; 000000caH
	call	_fnOperationReturn
	add	esp, 8

; 2706 :       return( 1 );

	mov	eax, 1
	jmp	$LN1@SetViewToS
$LN5@SetViewToS:

; 2707 :    }
; 2708 : 
; 2709 :    // Check to make sure that there is a parent entity instance for
; 2710 :    // the new root of the view
; 2711 :    if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	cmp	DWORD PTR [eax+26], 1
	jne	SHORT $LN6@SetViewToS

; 2712 :       fnEstablishCursorForView( lpViewEntityCsr );

	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	call	_fnEstablishCursorForView
	add	esp, 4
$LN6@SetViewToS:

; 2713 : 
; 2714 :    lpViewRootParentCsr = zGETPTR( lpViewEntityCsr->hParent );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewRootParentCsr$[ebp], eax

; 2715 : 
; 2716 :    // We double check that the parent cursor does not need establishing
; 2717 :    // because create entity ( through another view ) might mark the
; 2718 :    // parent only as needing to be established.
; 2719 :    if ( lpViewRootParentCsr->hEntityInstance == UNSET_CSR )

	mov	ecx, DWORD PTR _lpViewRootParentCsr$[ebp]
	cmp	DWORD PTR [ecx+26], 1
	jne	SHORT $LN7@SetViewToS

; 2720 :       fnEstablishCursorForView( lpViewRootParentCsr );

	mov	edx, DWORD PTR _lpViewRootParentCsr$[ebp]
	push	edx
	call	_fnEstablishCursorForView
	add	esp, 4
$LN7@SetViewToS:

; 2721 : 
; 2722 :    if ( lpViewRootParentCsr->hEntityInstance == 0 )

	mov	eax, DWORD PTR _lpViewRootParentCsr$[ebp]
	cmp	DWORD PTR [eax+26], 0
	jne	SHORT $LN8@SetViewToS

; 2723 :    {
; 2724 :       //  "KZOEE272 - Subobject Parent Cursor is NULL"
; 2725 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 272, 0,

	mov	ecx, DWORD PTR _lpViewRootParentCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	272					; 00000110H
	push	8
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2726 :                         fnEntityNameFromCsr( lpViewEntityCsr ),
; 2727 :                         fnEntityNameFromCsr( lpViewRootParentCsr ) );
; 2728 :       fnOperationReturn( iSetViewToSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	202					; 000000caH
	call	_fnOperationReturn
	add	esp, 8

; 2729 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetViewToS
$LN8@SetViewToS:

; 2730 :    }
; 2731 : 
; 2732 :    // Make sure the parent cursor is defined
; 2733 :    lpEntityInstance = zGETPTR( lpViewRootParentCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewRootParentCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2734 :    if ( lpEntityInstance->u.nInd.bHidden )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN9@SetViewToS

; 2735 :    {
; 2736 :       //  "KZOEE273 - Parent Entity instance for View deleted"
; 2737 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 273, 0,

	push	0
	mov	ecx, DWORD PTR _lpViewRootParentCsr$[ebp]
	push	ecx
	call	_fnEntityNameFromCsr@4
	push	eax
	push	0
	push	273					; 00000111H
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2738 :                         fnEntityNameFromCsr( lpViewRootParentCsr ), 0 );
; 2739 :       fnOperationReturn( iSetViewToSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	202					; 000000caH
	call	_fnOperationReturn
	add	esp, 8

; 2740 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetViewToS
$LN9@SetViewToS:

; 2741 :    }
; 2742 : 
; 2743 :    // If we're in hierarchical mode, then reset is not allowed
; 2744 :    if ( lpViewCsr->hHierRootEntityInstance &&

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN10@SetViewToS
	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	edx, DWORD PTR [eax+26]
	cmp	edx, DWORD PTR [ecx+26]
	jne	SHORT $LN11@SetViewToS
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	jne	SHORT $LN10@SetViewToS
$LN11@SetViewToS:

; 2745 :         (lpViewCsr->hHierEntityInstance != lpViewEntityCsr->hEntityInstance ||
; 2746 :          lpViewEntity->bRecursive == FALSE) )
; 2747 : 
; 2748 :    {
; 2749 :       // "KZOEE266 - Invalid Operation for Hierarchical cursor position"
; 2750 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 266, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	266					; 0000010aH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2751 :       fnOperationReturn( iSetViewToSubobject, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	202					; 000000caH
	call	_fnOperationReturn
	add	esp, 8

; 2752 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetViewToS
$LN10@SetViewToS:

; 2753 :    }
; 2754 : 
; 2755 :    // Call fnSetViewToSubobject to do the rest
; 2756 :    nRC = fnSetViewToSubobject( lpView, lpViewEntity, lpViewEntityCsr );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH
	mov	WORD PTR _nRC$[ebp], ax

; 2757 : 
; 2758 :    fnOperationReturn( iSetViewToSubobject, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	202					; 000000caH
	call	_fnOperationReturn
	add	esp, 8

; 2759 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetViewToS:

; 2760 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SetViewToSubobject@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpViewOD$ = -4						; size = 4
_cpcMsg$ = 8						; size = 4
_lpView$ = 12						; size = 4
_DropViewTrace@8 PROC

; 2959 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2960 :    LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 2961 : //xif ( zstrcmp( lpViewOD->szName, "TZRPSRCO" ) == 0 )
; 2962 : //x{
; 2963 :       TraceLine( "DropView %s: 0x%08x   LOD: %s", cpcMsg, lpView, lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcMsg$[ebp]
	push	ecx
	push	OFFSET $SG14341
	call	_TraceLine
	add	esp, 16					; 00000010H

; 2964 : //x}
; 2965 : 
; 2966 :    return( DropView( lpView ) );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_DropView@4

; 2967 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_DropViewTrace@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpFirstViewCsr$1 = -28					; size = 4
_lpViewCsr$2 = -24					; size = 4
_lpViewOD$3 = -20					; size = 4
_lpViewOI$4 = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_nRC$ = -8						; size = 2
_nState$5 = -4						; size = 2
_lpView$ = 8						; size = 4
_DropView@4 PROC

; 2971 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2972 :    LPTASK      lpCurrentTask;
; 2973 :    zSHORT      nRC;
; 2974 : 
; 2975 : #ifdef DEBUG_VIEW
; 2976 : 
; 2977 :    zLONG  k;
; 2978 : 
; 2979 :    if ( lpView == 0 )
; 2980 :    {
; 2981 :       LPVIEWOD lpViewOD;
; 2982 : 
; 2983 :       TraceLine( "DropView Reporting View Usage ===============================> High Water Mark: %d", g_lHighWaterView );
; 2984 :       for ( k = 0; k < g_lHighWaterView; k++ )
; 2985 :       {
; 2986 :          if ( g_pvView[ k ] )
; 2987 :          {
; 2988 :             lpViewOD = zGETPTR( g_pvView[ k ] );
; 2989 :             TraceLine( "== %06d ============> View: 0x%08x   LOD: %s",
; 2990 :                        k, g_pvView[ k ], lpViewOD->szName );
; 2991 :          }
; 2992 :       }
; 2993 : 
; 2994 :    // g_lHighWaterView = -1;
; 2995 :       return( 0 );
; 2996 :    }
; 2997 : 
; 2998 : #endif
; 2999 : 
; 3000 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 3001 :    if ( (lpCurrentTask = fnOperationCall( iDropView, lpView,
; 3002 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	212					; 000000d4H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@DropView

; 3003 :    {
; 3004 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DropView
$LN2@DropView:

; 3005 :    }
; 3006 : 
; 3007 :    if ( lpView->hSubtask )

	mov	ecx, DWORD PTR _lpView$[ebp]
	cmp	DWORD PTR [ecx+18], 0
	je	SHORT $LN3@DropView

; 3008 :    {
; 3009 :       //  "KZOEE108 - Attempt to drop Subtask View"
; 3010 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 108, 0, 0, 0 );

	push	0
	push	0
	push	0
	push	108					; 0000006cH
	push	8
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 3011 :       nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 3012 :    }

	jmp	$LN4@DropView
$LN3@DropView:

; 3013 :    else
; 3014 :    {
; 3015 : #ifdef __ACTIVATE_CONSTRAINTS__
; 3016 :       LPVIEWOD lpViewOD = zGETPTR( lpView->hViewOD );

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$3[ebp], eax

; 3017 : 
; 3018 :       // If we have a constraint for Dropping the OI, we need to
; 3019 :       // determine if we are the last view for this OI.  If so,
; 3020 :       // call the constraint operation.
; 3021 :       // Note: We drop the view no matter what the constraint operation
; 3022 :       // returns, so we don't check the return code.
; 3023 :       if ( lpViewOD->bDropOIConstraint )

	mov	ecx, DWORD PTR _lpViewOD$3[ebp]
	mov	edx, DWORD PTR [ecx+240]
	shr	edx, 6
	and	edx, 1
	je	$LN5@DropView

; 3024 :       {
; 3025 :          LPVIEWCSR lpViewCsr      = zGETPTR( lpView->hViewCsr );

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$2[ebp], eax

; 3026 :          LPVIEWOI  lpViewOI       = zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$2[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$4[ebp], eax

; 3027 :          LPVIEWCSR lpFirstViewCsr = zGETPTR( lpViewOI->hFirstViewCsr );

	mov	ecx, DWORD PTR _lpViewOI$4[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpFirstViewCsr$1[ebp], eax

; 3028 : 
; 3029 :          if ( lpFirstViewCsr->hNextViewCsr == 0 )

	mov	eax, DWORD PTR _lpFirstViewCsr$1[ebp]
	cmp	DWORD PTR [eax+2], 0
	jne	SHORT $LN5@DropView

; 3030 :          {
; 3031 :             zSHORT nState = 0;

	xor	ecx, ecx
	mov	WORD PTR _nState$5[ebp], cx

; 3032 : 
; 3033 :             if ( lpCurrentTask->bShutdown )

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN7@DropView

; 3034 :                nState += zOCE_STATE_SHUTDOWN;

	movsx	ecx, WORD PTR _nState$5[ebp]
	add	ecx, 2
	mov	WORD PTR _nState$5[ebp], cx
$LN7@DropView:

; 3035 : 
; 3036 :             fnInvokeOCEOperation( lpView, lpCurrentTask,

	movzx	edx, WORD PTR _nState$5[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	_fnInvokeOCEOperation
	add	esp, 16					; 00000010H

; 3037 :                                   zOCE_DROPOI, nState );
; 3038 :             lpViewOI->bDropConstraintInvoked = TRUE;

	mov	edx, DWORD PTR _lpViewOI$4[ebp]
	mov	eax, DWORD PTR [edx+36]
	or	eax, 64					; 00000040H
	mov	ecx, DWORD PTR _lpViewOI$4[ebp]
	mov	DWORD PTR [ecx+36], eax
$LN5@DropView:

; 3039 :          }
; 3040 :       }
; 3041 : #endif
; 3042 :       nRC = fnDropView( lpView ); // blew on this line 2006.07.03 dks1

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_fnDropView@4
	mov	WORD PTR _nRC$[ebp], ax
$LN4@DropView:

; 3043 :    }
; 3044 : 
; 3045 :    fnOperationReturn( iDropView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	212					; 000000d4H
	call	_fnOperationReturn
	add	esp, 8

; 3046 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@DropView:

; 3047 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_DropView@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpApp$ = -24						; size = 4
_lpSubtask$ = -20					; size = 4
_hView$ = -16						; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpViewName$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pchReturnName$ = 8					; size = 4
_lpView$ = 12						; size = 4
_lpSubtaskView$ = 16					; size = 4
_nLevel$ = 20						; size = 2
_GetNameForView@16 PROC

; 1331 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1332 :    LPTASK      lpCurrentTask;
; 1333 :    LPSUBTASK   lpSubtask;
; 1334 :    LPVIEWNAME  lpViewName;
; 1335 :    zPVOID      hView = zGETHNDL( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hView$[ebp], eax

; 1336 :    LPAPP       lpApp;
; 1337 :    zSHORT      nRC;
; 1338 : 
; 1339 :    // Clear out pchReturnName
; 1340 :    pchReturnName[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchReturnName$[ebp]
	mov	BYTE PTR [eax+edx], 0

; 1341 : 
; 1342 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 1343 :    if ( (lpCurrentTask = fnOperationCall( iGetNameForView, lpView,
; 1344 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	208					; 000000d0H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN10@GetNameFor

; 1345 :    {
; 1346 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetNameFor
$LN10@GetNameFor:

; 1347 :    }
; 1348 : 
; 1349 :    if ( (nLevel == zLEVEL_SUBTASK || lpSubtaskView) &&

	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 1
	je	SHORT $LN12@GetNameFor
	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	je	SHORT $LN11@GetNameFor
$LN12@GetNameFor:
	mov	eax, DWORD PTR _lpSubtaskView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidSubtaskView
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN11@GetNameFor

; 1350 :         (fnValidSubtaskView( lpCurrentTask, lpSubtaskView )) == 0 )
; 1351 :    {
; 1352 :       fnOperationReturn( iGetNameForView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	208					; 000000d0H
	call	_fnOperationReturn
	add	esp, 8

; 1353 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetNameFor
$LN11@GetNameFor:

; 1354 :    }
; 1355 : 
; 1356 :    // Check for valid scope.
; 1357 :    if ( nLevel != zLEVEL_SUBTASK     && nLevel != zLEVEL_TASK   &&
; 1358 :         nLevel != zLEVEL_APPLICATION && nLevel != zLEVEL_SYSTEM &&

	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 1
	je	SHORT $LN13@GetNameFor
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 2
	je	SHORT $LN13@GetNameFor
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 4
	je	SHORT $LN13@GetNameFor
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 8
	je	SHORT $LN13@GetNameFor
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 15					; 0000000fH
	je	SHORT $LN13@GetNameFor

; 1359 :         nLevel != zLEVEL_ANY )
; 1360 :    {
; 1361 :       // "KZOEE110 - Invalid scope for View name"
; 1362 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 110, (zLONG) nLevel, 0, 0 );

	push	0
	push	0
	movsx	eax, WORD PTR _nLevel$[ebp]
	push	eax
	push	110					; 0000006eH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1363 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN13@GetNameFor:

; 1364 :    }
; 1365 : 
; 1366 :    // Depending on the scope parameter, check the appropriate
; 1367 :    // name chain for the view.  If nRC is set to a non-zero value, then the
; 1368 :    // view has been found and no further checking needs to be done.
; 1369 :    nRC = -1;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx

; 1370 :    if ( nLevel == zLEVEL_SUBTASK || (nLevel == zLEVEL_ANY && lpSubtaskView) )

	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 1
	je	SHORT $LN15@GetNameFor
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN14@GetNameFor
	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	je	SHORT $LN14@GetNameFor
$LN15@GetNameFor:

; 1371 :    {
; 1372 :       // Look for a named view in the subtask.
; 1373 :       lpSubtask = zGETPTR( lpSubtaskView->hSubtask );

	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 1374 :       lpViewName = zGETPTR( lpSubtask->hFirstViewName );

	mov	eax, DWORD PTR _lpSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN2@GetNameFor:

; 1375 :       while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN14@GetNameFor

; 1376 :       {
; 1377 :          if ( lpViewName->hView == hView )

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+2]
	cmp	eax, DWORD PTR _hView$[ebp]
	jne	SHORT $LN16@GetNameFor

; 1378 :          {
; 1379 :             nRC = zLEVEL_SUBTASK;

	mov	ecx, 1
	mov	WORD PTR _nRC$[ebp], cx

; 1380 :             break;

	jmp	SHORT $LN14@GetNameFor
$LN16@GetNameFor:

; 1381 :          }
; 1382 : 
; 1383 :          lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1384 :       }

	jmp	SHORT $LN2@GetNameFor
$LN14@GetNameFor:

; 1385 :    }
; 1386 : 
; 1387 :    if ( (nLevel == zLEVEL_TASK || nLevel == zLEVEL_ANY) && nRC < 0 )

	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 2
	je	SHORT $LN18@GetNameFor
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN17@GetNameFor
$LN18@GetNameFor:
	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jge	SHORT $LN17@GetNameFor

; 1388 :    {
; 1389 :       // Look for the view in the task names
; 1390 :       lpViewName = zGETPTR( lpCurrentTask->hFirstViewName );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	edx, DWORD PTR [ecx+110]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN4@GetNameFor:

; 1391 :       while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN17@GetNameFor

; 1392 :       {
; 1393 :          if ( lpViewName->hView == hView )

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN19@GetNameFor

; 1394 :          {
; 1395 :             nRC = zLEVEL_TASK;

	mov	edx, 2
	mov	WORD PTR _nRC$[ebp], dx

; 1396 :             break;

	jmp	SHORT $LN17@GetNameFor
$LN19@GetNameFor:

; 1397 :          }
; 1398 : 
; 1399 :          lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1400 :       }

	jmp	SHORT $LN4@GetNameFor
$LN17@GetNameFor:

; 1401 :    }
; 1402 : 
; 1403 :    if ( (nLevel == zLEVEL_APPLICATION || nLevel == zLEVEL_ANY) && nRC < 0 )

	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 4
	je	SHORT $LN21@GetNameFor
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN20@GetNameFor
$LN21@GetNameFor:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN20@GetNameFor

; 1404 :    {
; 1405 :       // Look for the view at the application level.
; 1406 :       fnGetApplicationForSubtask( &lpApp, lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	_fnGetApplicationForSubtask@8

; 1407 :       lpViewName = zGETPTR( lpApp->hFirstViewName );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR [ecx+1893]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN6@GetNameFor:

; 1408 :       while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN20@GetNameFor

; 1409 :       {
; 1410 :          if ( lpViewName->hView == hView )

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN22@GetNameFor

; 1411 :          {
; 1412 :             nRC = zLEVEL_APPLICATION;

	mov	edx, 4
	mov	WORD PTR _nRC$[ebp], dx

; 1413 :             break;

	jmp	SHORT $LN20@GetNameFor
$LN22@GetNameFor:

; 1414 :          }
; 1415 : 
; 1416 :          lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1417 :       }

	jmp	SHORT $LN6@GetNameFor
$LN20@GetNameFor:

; 1418 :    }
; 1419 : 
; 1420 :    if ( (nLevel == zLEVEL_SYSTEM || nLevel == zLEVEL_ANY) && nRC < 0 )

	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 8
	je	SHORT $LN24@GetNameFor
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN23@GetNameFor
$LN24@GetNameFor:
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	SHORT $LN23@GetNameFor

; 1421 :    {
; 1422 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 1423 : 
; 1424 :       // First, see if the name exists at the system level
; 1425 :       lpViewName = zGETPTR( AnchorBlock->hFirstViewName );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1489]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN8@GetNameFor:

; 1426 :       while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN9@GetNameFor

; 1427 :       {
; 1428 :          if ( lpViewName->hView == hView )

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN25@GetNameFor

; 1429 :          {
; 1430 :             nRC = zLEVEL_SYSTEM;

	mov	eax, 8
	mov	WORD PTR _nRC$[ebp], ax

; 1431 :             break;

	jmp	SHORT $LN9@GetNameFor
$LN25@GetNameFor:

; 1432 :          }
; 1433 : 
; 1434 :          lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1435 :       }

	jmp	SHORT $LN8@GetNameFor
$LN9@GetNameFor:

; 1436 : 
; 1437 :       zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN23@GetNameFor:

; 1438 :    }
; 1439 : 
; 1440 :    // If a name search was done, then see if the name was found.
; 1441 :    // If so, return the name in pchReturnName
; 1442 :    if ( nRC > 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jle	SHORT $LN26@GetNameFor

; 1443 :       zstrcpy( pchReturnName, lpViewName->szName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	mov	edx, DWORD PTR _pchReturnName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN26@GetNameFor:

; 1444 : 
; 1445 :    fnOperationReturn( iGetNameForView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	208					; 000000d0H
	call	_fnOperationReturn
	add	esp, 8

; 1446 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetNameFor:

; 1447 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_GetNameForView@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpTempView$1 = -80					; size = 4
tv341 = -76						; size = 4
tv340 = -72						; size = 4
_lpApp$ = -68						; size = 4
_lpTempView$2 = -64					; size = 4
tv298 = -60						; size = 4
tv297 = -56						; size = 4
_lpTempView$3 = -52					; size = 4
tv254 = -48						; size = 4
tv253 = -44						; size = 4
_lpSubtask$ = -40					; size = 4
_lpTempView$4 = -36					; size = 4
tv208 = -32						; size = 4
tv207 = -28						; size = 4
_lpTask$5 = -24						; size = 4
_hView$ = -20						; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpPrevViewName$ = -12					; size = 4
_lpViewName$ = -8					; size = 4
_nRC$ = -4						; size = 2
_lpView$ = 8						; size = 4
_cpcName$ = 12						; size = 4
_lpSubtaskView$ = 16					; size = 4
_nLevel$ = 20						; size = 2
_DropNameForView@16 PROC

; 1059 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 1060 :    LPTASK      lpCurrentTask;
; 1061 :    LPSUBTASK   lpSubtask;
; 1062 :    LPVIEWNAME  lpViewName;
; 1063 :    LPVIEWNAME  lpPrevViewName;
; 1064 :    LPAPP       lpApp;
; 1065 :    zPVOID      hView = zGETHNDL( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hView$[ebp], eax

; 1066 :    zSHORT      nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 1067 : 
; 1068 : #if 1
; 1069 :    if ( lpSubtaskView == 0 )

	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	jne	SHORT $LN13@DropNameFo

; 1070 :    {
; 1071 :       if ( g_vDefaultTaskView )

	cmp	DWORD PTR _g_vDefaultTaskView, 0
	je	SHORT $LN15@DropNameFo

; 1072 :          lpSubtaskView = g_vDefaultTaskView;

	mov	edx, DWORD PTR _g_vDefaultTaskView
	mov	DWORD PTR _lpSubtaskView$[ebp], edx
$LN15@DropNameFo:

; 1073 :    }

	jmp	$LN14@DropNameFo
$LN13@DropNameFo:

; 1074 :    else
; 1075 :    if ( g_vDefaultTaskView && nLevel == zLEVEL_TASK )

	cmp	DWORD PTR _g_vDefaultTaskView, 0
	je	$LN14@DropNameFo
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 2
	jne	$LN14@DropNameFo

; 1076 :    {
; 1077 :       if ( lpSubtaskView->hTask != g_vDefaultTaskView->hTask )

	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	mov	edx, DWORD PTR _g_vDefaultTaskView
	mov	eax, DWORD PTR [ecx+14]
	cmp	eax, DWORD PTR [edx+14]
	je	$LN14@DropNameFo

; 1078 :       {
; 1079 :          lpCurrentTask = zGETPTR( lpSubtaskView->hTask );

	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 1080 :          if ( lpCurrentTask && lpCurrentTask->bTransientTask )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $LN18@DropNameFo
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN18@DropNameFo

; 1081 :          {
; 1082 :             TraceLine( "DropNameForView sending in view for TRANSIENT task: %d (0x%08x)  "

	mov	edx, DWORD PTR _g_vDefaultTaskView
	mov	eax, DWORD PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _g_vDefaultTaskView
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR _lpSubtaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	push	OFFSET $SG13713
	call	_TraceLine
	add	esp, 20					; 00000014H

; 1083 :                          "should be for task: %d (0x%08x) ... WILL NOT RESET TASK VIEW",
; 1084 :                        lpSubtaskView->hTask, lpSubtaskView->hTask,
; 1085 :                        g_vDefaultTaskView->hTask, g_vDefaultTaskView->hTask );
; 1086 :          }

	jmp	SHORT $LN14@DropNameFo
$LN18@DropNameFo:

; 1087 :          else
; 1088 :          {
; 1089 :          // SysMessageBox( 0, "Zeidon OE", "DropNameForView now RESETTING TASK VIEW", 0 );
; 1090 :             if ( g_nOE_TraceWarning )

	movsx	ecx, WORD PTR _g_nOE_TraceWarning
	test	ecx, ecx
	je	SHORT $LN20@DropNameFo

; 1091 :             {
; 1092 :                TraceLine( "DropNameForView sending in view for task: %d (0x%08x)  "

	mov	edx, DWORD PTR _g_vDefaultTaskView
	mov	eax, DWORD PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _g_vDefaultTaskView
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR _lpSubtaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	push	OFFSET $SG13715
	call	_TraceLine
	add	esp, 20					; 00000014H
$LN20@DropNameFo:

; 1093 :                             "should be for task: %d (0x%08x) ... RESETTING TASK VIEW",
; 1094 :                           lpSubtaskView->hTask, lpSubtaskView->hTask,
; 1095 :                           g_vDefaultTaskView->hTask, g_vDefaultTaskView->hTask );
; 1096 :             }
; 1097 : 
; 1098 :             lpSubtaskView = g_vDefaultTaskView;

	mov	ecx, DWORD PTR _g_vDefaultTaskView
	mov	DWORD PTR _lpSubtaskView$[ebp], ecx
$LN14@DropNameFo:

; 1099 :          }
; 1100 :       }
; 1101 :    }
; 1102 : #endif
; 1103 : 
; 1104 :    // If task not active or disabled, return zCALL_ERROR.
; 1105 :    if ( (lpCurrentTask = fnOperationCall( iDropNameForView, lpView, zVALID_VIEW )) == 0 )

	push	1
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	push	205					; 000000cdH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@DropNameFo

; 1106 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@DropNameFo
$LN4@DropNameFo:

; 1107 : 
; 1108 :    do  // begin purist's goto
; 1109 :    {
; 1110 :       // Check for valid scope.
; 1111 :       if ( nLevel != zLEVEL_SUBTASK     && nLevel != zLEVEL_TASK   &&
; 1112 :            nLevel != zLEVEL_APPLICATION && nLevel != zLEVEL_SYSTEM &&

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 1
	je	SHORT $LN22@DropNameFo
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 2
	je	SHORT $LN22@DropNameFo
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 4
	je	SHORT $LN22@DropNameFo
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 8
	je	SHORT $LN22@DropNameFo
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 15					; 0000000fH
	je	SHORT $LN22@DropNameFo

; 1113 :            nLevel != zLEVEL_ANY )
; 1114 :       {
; 1115 :          TraceLineS( "DropNameForView Invalid scope for View name: ", cpcName );

	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	push	OFFSET $SG13718
	call	_TraceLineS@8

; 1116 :          //  "KZOEE110 - Invalid scope for View name"
; 1117 :          fnIssueCoreError( lpCurrentTask, lpSubtaskView, 8, 110, (zLONG) nLevel, 0, 0 );

	push	0
	push	0
	movsx	eax, WORD PTR _nLevel$[ebp]
	push	eax
	push	110					; 0000006eH
	push	8
	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1118 :       // fnOperationReturn( iDropNameForView, lpCurrentTask );
; 1119 :          break;

	jmp	$LN3@DropNameFo
$LN22@DropNameFo:

; 1120 :       }
; 1121 : 
; 1122 :       if ( cpcName == 0 || cpcName[ 0 ] == 0 ||

	cmp	DWORD PTR _cpcName$[ebp], 0
	je	SHORT $LN24@DropNameFo
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN24@DropNameFo
	mov	ecx, DWORD PTR _cpcName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	eax, 64					; 00000040H
	jbe	SHORT $LN23@DropNameFo
$LN24@DropNameFo:

; 1123 :            zstrlen( cpcName ) > zZEIDON_NAME_LTH * 2 )
; 1124 :       {
; 1125 :          TraceLineS( "DropNameForView Length Error: ", cpcName );

	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	push	OFFSET $SG13721
	call	_TraceLineS@8

; 1126 :          fnIssueCoreError( lpCurrentTask, lpSubtaskView, 8, 450, 0, cpcName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcName$[ebp]
	push	eax
	push	0
	push	450					; 000001c2H
	push	8
	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1127 :       // fnOperationReturn( iDropNameForView, lpCurrentTask );
; 1128 :          break;

	jmp	$LN3@DropNameFo
$LN23@DropNameFo:

; 1129 :       }
; 1130 : 
; 1131 :    // if ( fnValidView( lpCurrentTask, lpView ) == 0 )
; 1132 :    // {
; 1133 :    //    fnOperationReturn( iDropNameForView, lpCurrentTask );
; 1134 :    //    return( zCALL_ERROR );
; 1135 :    // }
; 1136 : 
; 1137 :       // If user wants a subtask view make sure subtask is OK.
; 1138 :       if ( nLevel == zLEVEL_SUBTASK &&

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 1
	jne	SHORT $LN25@DropNameFo
	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidSubtaskView
	add	esp, 8
	cwde
	test	eax, eax
	jne	SHORT $LN25@DropNameFo

; 1139 :            fnValidSubtaskView( lpCurrentTask, lpSubtaskView ) == 0 )
; 1140 :       {
; 1141 :          TraceLineS( "DropNameForView Invalid Subtask view for Name: ", cpcName );

	mov	ecx, DWORD PTR _cpcName$[ebp]
	push	ecx
	push	OFFSET $SG13723
	call	_TraceLineS@8

; 1142 :          break;  // view invalid

	jmp	$LN3@DropNameFo
$LN25@DropNameFo:

; 1143 :       }
; 1144 : 
; 1145 :       // Depending on the scope parameter, look in the appropriate
; 1146 :       // name chain for the name being dropped.
; 1147 :       nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 1148 :       if ( nLevel == zLEVEL_SUBTASK )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 1
	jne	$LN26@DropNameFo

; 1149 :       {
; 1150 :          // Look for the name in the subtask.
; 1151 :          lpSubtask = zGETPTR( lpSubtaskView->hSubtask );

	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 1152 :          lpPrevViewName = 0;

	mov	DWORD PTR _lpPrevViewName$[ebp], 0

; 1153 :          lpViewName = zGETPTR( lpSubtask->hFirstViewName );

	mov	eax, DWORD PTR _lpSubtask$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN5@DropNameFo:

; 1154 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN6@DropNameFo

; 1155 :          {
; 1156 :             if ( zstrcmp( lpViewName->szName, cpcName ) == 0 )

	mov	edx, DWORD PTR _lpViewName$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _cpcName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN62@DropNameFo
	mov	eax, DWORD PTR _cpcName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv208[ebp], eax
	jmp	SHORT $LN63@DropNameFo
$LN62@DropNameFo:
	mov	edx, DWORD PTR _lpViewName$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _cpcName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN60@DropNameFo
	mov	DWORD PTR tv207[ebp], 1
	jmp	SHORT $LN61@DropNameFo
$LN60@DropNameFo:
	mov	DWORD PTR tv207[ebp], -1
$LN61@DropNameFo:
	mov	eax, DWORD PTR tv207[ebp]
	mov	DWORD PTR tv208[ebp], eax
$LN63@DropNameFo:
	cmp	DWORD PTR tv208[ebp], 0
	jne	SHORT $LN28@DropNameFo

; 1157 :                break;

	jmp	SHORT $LN6@DropNameFo
$LN28@DropNameFo:

; 1158 : 
; 1159 :             lpPrevViewName = lpViewName;

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR _lpPrevViewName$[ebp], ecx

; 1160 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1161 :          }

	jmp	SHORT $LN5@DropNameFo
$LN6@DropNameFo:

; 1162 : 
; 1163 :          // If the view name was found, remove the view from the subtask
; 1164 :          // chain and free up its storage.
; 1165 :          if ( lpViewName && (lpView == 0 || lpViewName->hView == hView) )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN29@DropNameFo
	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN31@DropNameFo
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN29@DropNameFo
$LN31@DropNameFo:

; 1166 :          {
; 1167 :             zVIEW lpTempView = zGETPTR( lpViewName->hView );

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempView$4[ebp], eax

; 1168 : 
; 1169 :             lpTempView->nViewNames--;

	mov	edx, DWORD PTR _lpTempView$4[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpTempView$4[ebp]
	mov	WORD PTR [ecx+22], ax

; 1170 :             if ( lpPrevViewName )

	cmp	DWORD PTR _lpPrevViewName$[ebp], 0
	je	SHORT $LN32@DropNameFo

; 1171 :                lpPrevViewName->hNextViewName = lpViewName->hNextViewName;

	mov	edx, DWORD PTR _lpPrevViewName$[ebp]
	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR [edx+6], ecx
	jmp	SHORT $LN33@DropNameFo
$LN32@DropNameFo:

; 1172 :             else
; 1173 :                lpSubtask->hFirstViewName = lpViewName->hNextViewName;

	mov	edx, DWORD PTR _lpSubtask$[ebp]
	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR [edx+18], ecx
$LN33@DropNameFo:

; 1174 : 
; 1175 :             fnFreeDataspace( lpViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 1176 :          }

	jmp	SHORT $LN30@DropNameFo
$LN29@DropNameFo:

; 1177 :          else
; 1178 :          {
; 1179 :             nRC = 1;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax
$LN30@DropNameFo:

; 1180 :          }
; 1181 :       }

	jmp	$LN2@DropNameFo
$LN26@DropNameFo:

; 1182 :       else
; 1183 :       if ( nLevel == zLEVEL_TASK )

	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 2
	jne	$LN34@DropNameFo

; 1184 :       {
; 1185 :          LPTASK     lpTask;
; 1186 : 
; 1187 :          // Look for the requested name in the task.  If a subtask view was
; 1188 :          // supplied use the task represented by the view.
; 1189 :          if ( lpSubtaskView )

	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	je	SHORT $LN36@DropNameFo

; 1190 :             lpTask = zGETPTR( lpSubtaskView->hTask );

	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$5[ebp], eax
	jmp	SHORT $LN37@DropNameFo
$LN36@DropNameFo:

; 1191 :          else
; 1192 :             lpTask = lpCurrentTask;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpTask$5[ebp], ecx
$LN37@DropNameFo:

; 1193 : 
; 1194 :          // Look for the name in the task.
; 1195 :          lpPrevViewName = 0;

	mov	DWORD PTR _lpPrevViewName$[ebp], 0

; 1196 :          lpViewName = zGETPTR( lpTask->hFirstViewName );

	mov	edx, DWORD PTR _lpTask$5[ebp]
	mov	eax, DWORD PTR [edx+110]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN7@DropNameFo:

; 1197 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN8@DropNameFo

; 1198 :          {
; 1199 :             if ( zstrcmp( lpViewName->szName, cpcName ) == 0 )

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _cpcName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN66@DropNameFo
	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewName$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv254[ebp], eax
	jmp	SHORT $LN67@DropNameFo
$LN66@DropNameFo:
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _cpcName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN64@DropNameFo
	mov	DWORD PTR tv253[ebp], 1
	jmp	SHORT $LN65@DropNameFo
$LN64@DropNameFo:
	mov	DWORD PTR tv253[ebp], -1
$LN65@DropNameFo:
	mov	edx, DWORD PTR tv253[ebp]
	mov	DWORD PTR tv254[ebp], edx
$LN67@DropNameFo:
	cmp	DWORD PTR tv254[ebp], 0
	jne	SHORT $LN38@DropNameFo

; 1200 :                break;

	jmp	SHORT $LN8@DropNameFo
$LN38@DropNameFo:

; 1201 : 
; 1202 :             lpPrevViewName = lpViewName;

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR _lpPrevViewName$[ebp], eax

; 1203 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1204 :          }

	jmp	SHORT $LN7@DropNameFo
$LN8@DropNameFo:

; 1205 : 
; 1206 :          // If the view name was found, remove the view from the task
; 1207 :          // chain and free up its storage.
; 1208 :          if ( lpViewName && (lpView == 0 || lpViewName->hView == hView) )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN39@DropNameFo
	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN41@DropNameFo
	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN39@DropNameFo
$LN41@DropNameFo:

; 1209 :          {
; 1210 :             zVIEW lpTempView = zGETPTR( lpViewName->hView );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempView$3[ebp], eax

; 1211 : 
; 1212 :             lpTempView->nViewNames--;

	mov	ecx, DWORD PTR _lpTempView$3[ebp]
	mov	dx, WORD PTR [ecx+22]
	sub	dx, 1
	mov	eax, DWORD PTR _lpTempView$3[ebp]
	mov	WORD PTR [eax+22], dx

; 1213 :             if ( lpPrevViewName )

	cmp	DWORD PTR _lpPrevViewName$[ebp], 0
	je	SHORT $LN42@DropNameFo

; 1214 :                lpPrevViewName->hNextViewName = lpViewName->hNextViewName;

	mov	ecx, DWORD PTR _lpPrevViewName$[ebp]
	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR [ecx+6], eax
	jmp	SHORT $LN43@DropNameFo
$LN42@DropNameFo:

; 1215 :             else
; 1216 :                lpTask->hFirstViewName = lpViewName->hNextViewName;

	mov	ecx, DWORD PTR _lpTask$5[ebp]
	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR [ecx+110], eax
$LN43@DropNameFo:

; 1217 : 
; 1218 :             fnFreeDataspace( lpViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 1219 :          }

	jmp	SHORT $LN40@DropNameFo
$LN39@DropNameFo:

; 1220 :          else
; 1221 :             nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
$LN40@DropNameFo:

; 1222 :       }

	jmp	$LN2@DropNameFo
$LN34@DropNameFo:

; 1223 :       else
; 1224 :       if ( nLevel == zLEVEL_APPLICATION )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 4
	jne	$LN44@DropNameFo

; 1225 :       {
; 1226 :          // Look for the name at the application level.
; 1227 :          // The application level is determined by the view being named.
; 1228 :          // If the view being named is a subtask view, then the application
; 1229 :          // is the application for the subtask. Otherwise, if the view has
; 1230 :          // a ViewOD, the application is the app for the ViewOD. If all
; 1231 :          // else fails, we will use the application associated with the
; 1232 :          // task.
; 1233 :          fnGetApplicationForSubtask( &lpApp, lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpApp$[ebp]
	push	edx
	call	_fnGetApplicationForSubtask@8

; 1234 :          lpPrevViewName = 0;

	mov	DWORD PTR _lpPrevViewName$[ebp], 0

; 1235 :          lpViewName = zGETPTR( lpApp->hFirstViewName );

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR [eax+1893]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN9@DropNameFo:

; 1236 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN10@DropNameFo

; 1237 :          {
; 1238 :             if ( zstrcmp( lpViewName->szName, cpcName ) == 0 )

	mov	edx, DWORD PTR _lpViewName$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _cpcName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN70@DropNameFo
	mov	eax, DWORD PTR _cpcName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv298[ebp], eax
	jmp	SHORT $LN71@DropNameFo
$LN70@DropNameFo:
	mov	edx, DWORD PTR _lpViewName$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _cpcName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN68@DropNameFo
	mov	DWORD PTR tv297[ebp], 1
	jmp	SHORT $LN69@DropNameFo
$LN68@DropNameFo:
	mov	DWORD PTR tv297[ebp], -1
$LN69@DropNameFo:
	mov	eax, DWORD PTR tv297[ebp]
	mov	DWORD PTR tv298[ebp], eax
$LN71@DropNameFo:
	cmp	DWORD PTR tv298[ebp], 0
	jne	SHORT $LN46@DropNameFo

; 1239 :                break;

	jmp	SHORT $LN10@DropNameFo
$LN46@DropNameFo:

; 1240 : 
; 1241 :             lpPrevViewName = lpViewName;

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR _lpPrevViewName$[ebp], ecx

; 1242 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1243 :          }

	jmp	SHORT $LN9@DropNameFo
$LN10@DropNameFo:

; 1244 : 
; 1245 :          // If the view name was found, remove the view from the application
; 1246 :          // chain and free up its storage
; 1247 :          if ( lpViewName && (lpView == 0 || lpViewName->hView == hView) )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN47@DropNameFo
	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN49@DropNameFo
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	cmp	edx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN47@DropNameFo
$LN49@DropNameFo:

; 1248 :          {
; 1249 :             zVIEW lpTempView = zGETPTR( lpViewName->hView );

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempView$2[ebp], eax

; 1250 : 
; 1251 :             lpTempView->nViewNames--;

	mov	edx, DWORD PTR _lpTempView$2[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpTempView$2[ebp]
	mov	WORD PTR [ecx+22], ax

; 1252 :             if ( lpPrevViewName )

	cmp	DWORD PTR _lpPrevViewName$[ebp], 0
	je	SHORT $LN50@DropNameFo

; 1253 :                lpPrevViewName->hNextViewName = lpViewName->hNextViewName;

	mov	edx, DWORD PTR _lpPrevViewName$[ebp]
	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR [edx+6], ecx
	jmp	SHORT $LN51@DropNameFo
$LN50@DropNameFo:

; 1254 :             else
; 1255 :                lpApp->hFirstViewName = lpViewName->hNextViewName;

	mov	edx, DWORD PTR _lpApp$[ebp]
	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	DWORD PTR [edx+1893], ecx
$LN51@DropNameFo:

; 1256 : 
; 1257 :             fnFreeDataspace( lpViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	push	edx
	call	_fnFreeDataspace
	add	esp, 4

; 1258 :          }

	jmp	SHORT $LN48@DropNameFo
$LN47@DropNameFo:

; 1259 :          else
; 1260 :             nRC = 1;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax
$LN48@DropNameFo:

; 1261 :       }

	jmp	$LN2@DropNameFo
$LN44@DropNameFo:

; 1262 :       else
; 1263 :       if ( nLevel == zLEVEL_SYSTEM )

	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 8
	jne	$LN2@DropNameFo

; 1264 :       {
; 1265 :          zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 1266 : 
; 1267 :          // First, see if the name exists at the system level.
; 1268 :          lpPrevViewName = 0;

	mov	DWORD PTR _lpPrevViewName$[ebp], 0

; 1269 :          lpViewName = zGETPTR( AnchorBlock->hFirstViewName );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1489]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN11@DropNameFo:

; 1270 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN12@DropNameFo

; 1271 :          {
; 1272 :             if ( zstrcmp( lpViewName->szName, cpcName ) == 0 )

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _cpcName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN74@DropNameFo
	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewName$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv341[ebp], eax
	jmp	SHORT $LN75@DropNameFo
$LN74@DropNameFo:
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _cpcName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN72@DropNameFo
	mov	DWORD PTR tv340[ebp], 1
	jmp	SHORT $LN73@DropNameFo
$LN72@DropNameFo:
	mov	DWORD PTR tv340[ebp], -1
$LN73@DropNameFo:
	mov	edx, DWORD PTR tv340[ebp]
	mov	DWORD PTR tv341[ebp], edx
$LN75@DropNameFo:
	cmp	DWORD PTR tv341[ebp], 0
	jne	SHORT $LN53@DropNameFo

; 1273 :                break;

	jmp	SHORT $LN12@DropNameFo
$LN53@DropNameFo:

; 1274 : 
; 1275 :             lpPrevViewName = lpViewName;

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR _lpPrevViewName$[ebp], eax

; 1276 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1277 :          }

	jmp	SHORT $LN11@DropNameFo
$LN12@DropNameFo:

; 1278 : 
; 1279 :          // If the view name was found, remove the view from the system
; 1280 :          // chain and free up its storage.
; 1281 :          if ( lpViewName && (lpView == 0 || lpViewName->hView == hView) )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN54@DropNameFo
	cmp	DWORD PTR _lpView$[ebp], 0
	je	SHORT $LN56@DropNameFo
	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	cmp	ecx, DWORD PTR _hView$[ebp]
	jne	SHORT $LN54@DropNameFo
$LN56@DropNameFo:

; 1282 :          {
; 1283 :             zVIEW lpTempView = zGETPTR( lpViewName->hView );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempView$1[ebp], eax

; 1284 : 
; 1285 :             lpTempView->nViewNames--;

	mov	ecx, DWORD PTR _lpTempView$1[ebp]
	mov	dx, WORD PTR [ecx+22]
	sub	dx, 1
	mov	eax, DWORD PTR _lpTempView$1[ebp]
	mov	WORD PTR [eax+22], dx

; 1286 :             if ( lpPrevViewName )

	cmp	DWORD PTR _lpPrevViewName$[ebp], 0
	je	SHORT $LN57@DropNameFo

; 1287 :                lpPrevViewName->hNextViewName = lpViewName->hNextViewName;

	mov	ecx, DWORD PTR _lpPrevViewName$[ebp]
	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR [ecx+6], eax
	jmp	SHORT $LN58@DropNameFo
$LN57@DropNameFo:

; 1288 :             else
; 1289 :                AnchorBlock->hFirstViewName = lpViewName->hNextViewName;

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	mov	DWORD PTR [ecx+1489], eax
$LN58@DropNameFo:

; 1290 : 
; 1291 :             fnFreeDataspace( lpViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	push	ecx
	call	_fnFreeDataspace
	add	esp, 4

; 1292 :          }

	jmp	SHORT $LN55@DropNameFo
$LN54@DropNameFo:

; 1293 :          else
; 1294 :             nRC = 1;

	mov	edx, 1
	mov	WORD PTR _nRC$[ebp], dx
$LN55@DropNameFo:

; 1295 : 
; 1296 :          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN2@DropNameFo:

; 1297 :       }
; 1298 : 
; 1299 :    } while ( FALSE );  // end of purist's goto

	xor	eax, eax
	jne	$LN4@DropNameFo
$LN3@DropNameFo:

; 1300 : 
; 1301 :    fnOperationReturn( iDropNameForView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	205					; 000000cdH
	call	_fnOperationReturn
	add	esp, 8

; 1302 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@DropNameFo:

; 1303 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_DropNameForView@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpTempView$1 = -80					; size = 4
tv457 = -76						; size = 4
tv456 = -72						; size = 4
_lpTempView$2 = -68					; size = 4
tv387 = -64						; size = 4
tv386 = -60						; size = 4
_lpTempView$3 = -56					; size = 4
tv316 = -52						; size = 4
tv315 = -48						; size = 4
_lpTempView$4 = -44					; size = 4
tv253 = -40						; size = 4
tv252 = -36						; size = 4
_lpApp$ = -32						; size = 4
_lpSubtask$ = -28					; size = 4
_lpTask$ = -24						; size = 4
_hViewName$ = -20					; size = 4
_lpCurrentTask$ = -16					; size = 4
_lpViewName$ = -12					; size = 4
_nRC$ = -8						; size = 2
_bAutoDrop$ = -1					; size = 1
_lpView$ = 8						; size = 4
_cpcName$ = 12						; size = 4
_lpSubtaskView$ = 16					; size = 4
_nLevel$ = 20						; size = 2
_SetNameForView@16 PROC

; 1630 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H

; 1631 :    LPTASK      lpCurrentTask;
; 1632 :    LPTASK      lpTask;
; 1633 :    LPSUBTASK   lpSubtask;
; 1634 :    LPVIEWNAME  lpViewName;
; 1635 :    zPVOID      hViewName;
; 1636 :    LPAPP       lpApp;
; 1637 :    zBOOL       bAutoDrop;
; 1638 :    zSHORT      nRC;
; 1639 : 
; 1640 : #if 1
; 1641 :    if ( lpSubtaskView == 0 )

	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	jne	SHORT $LN10@SetNameFor

; 1642 :    {
; 1643 :       if ( g_vDefaultTaskView )

	cmp	DWORD PTR _g_vDefaultTaskView, 0
	je	SHORT $LN12@SetNameFor

; 1644 :          lpSubtaskView = g_vDefaultTaskView;  // must be called from Driver

	mov	eax, DWORD PTR _g_vDefaultTaskView
	mov	DWORD PTR _lpSubtaskView$[ebp], eax
	jmp	SHORT $LN13@SetNameFor
$LN12@SetNameFor:

; 1645 :       else
; 1646 :          lpSubtaskView = lpView;  // must be called from JSP

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR _lpSubtaskView$[ebp], ecx
$LN13@SetNameFor:

; 1647 :    }

	jmp	$LN11@SetNameFor
$LN10@SetNameFor:

; 1648 :    else
; 1649 :    if ( g_vDefaultTaskView && nLevel == zLEVEL_TASK )

	cmp	DWORD PTR _g_vDefaultTaskView, 0
	je	$LN11@SetNameFor
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 2
	jne	$LN11@SetNameFor

; 1650 :    {
; 1651 :       if ( lpSubtaskView->hTask != g_vDefaultTaskView->hTask )

	mov	eax, DWORD PTR _lpSubtaskView$[ebp]
	mov	ecx, DWORD PTR _g_vDefaultTaskView
	mov	edx, DWORD PTR [eax+14]
	cmp	edx, DWORD PTR [ecx+14]
	je	$LN11@SetNameFor

; 1652 :       {
; 1653 :          lpCurrentTask = zGETPTR( lpSubtaskView->hTask );

	mov	eax, DWORD PTR _lpSubtaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 1654 :          if ( lpCurrentTask && lpCurrentTask->bTransientTask )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $LN16@SetNameFor
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	shr	eax, 10					; 0000000aH
	and	eax, 1
	je	SHORT $LN16@SetNameFor

; 1655 :          {
; 1656 :             TraceLine( "SetNameForView sending in view for TRANSIENT task: %d (0x%08x)  "

	mov	ecx, DWORD PTR _g_vDefaultTaskView
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR _g_vDefaultTaskView
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	push	OFFSET $SG13947
	call	_TraceLine
	add	esp, 20					; 00000014H

; 1657 :                          "should be for task: %d (0x%08x) ... WILL NOT RESET TASK VIEW",
; 1658 :                        lpSubtaskView->hTask, lpSubtaskView->hTask,
; 1659 :                        g_vDefaultTaskView->hTask, g_vDefaultTaskView->hTask );
; 1660 :          }

	jmp	SHORT $LN11@SetNameFor
$LN16@SetNameFor:

; 1661 :          else
; 1662 :          {
; 1663 :          // SysMessageBox( 0, "Zeidon OE", "SetNameForView now RESETTING TASK VIEW", 0 );
; 1664 :             if ( g_nOE_TraceWarning )

	movsx	eax, WORD PTR _g_nOE_TraceWarning
	test	eax, eax
	je	SHORT $LN18@SetNameFor

; 1665 :             {
; 1666 :                TraceLine( "SetNameForView sending in view for task: %d (0x%08x)  "

	mov	ecx, DWORD PTR _g_vDefaultTaskView
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR _g_vDefaultTaskView
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	push	OFFSET $SG13949
	call	_TraceLine
	add	esp, 20					; 00000014H
$LN18@SetNameFor:

; 1667 :                             "should be for task: %d (0x%08x) ... RESETTING TASK VIEW",
; 1668 :                           lpSubtaskView->hTask, lpSubtaskView->hTask,
; 1669 :                           g_vDefaultTaskView->hTask, g_vDefaultTaskView->hTask );
; 1670 :             }
; 1671 : 
; 1672 :             lpSubtaskView = g_vDefaultTaskView;

	mov	eax, DWORD PTR _g_vDefaultTaskView
	mov	DWORD PTR _lpSubtaskView$[ebp], eax
$LN11@SetNameFor:

; 1673 :          }
; 1674 :       }
; 1675 :    }
; 1676 : #endif
; 1677 : 
; 1678 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 1679 :    if ( (lpCurrentTask = fnOperationCall( iSetNameForView, lpView,
; 1680 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	204					; 000000ccH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN19@SetNameFor

; 1681 :    {
; 1682 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetNameFor
$LN19@SetNameFor:

; 1683 :    }
; 1684 : 
; 1685 :    if ( zstrlen( cpcName ) > zZEIDON_NAME_LTH * 2 )

	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	cmp	eax, 64					; 00000040H
	jbe	SHORT $LN20@SetNameFor

; 1686 :    {
; 1687 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 450, 0, cpcName, 0 );

	push	0
	mov	eax, DWORD PTR _cpcName$[ebp]
	push	eax
	push	0
	push	450					; 000001c2H
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1688 :       fnOperationReturn( iSetNameForView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	204					; 000000ccH
	call	_fnOperationReturn
	add	esp, 8

; 1689 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetNameFor
$LN20@SetNameFor:

; 1690 :    }
; 1691 : 
; 1692 : #if 0
; 1693 : // if ( zstrcmp( cpcName, "vERD_LPLR" ) == 0 )
; 1694 :    if ( cpcName[ 0 ] != '_' )
; 1695 :    TraceLine( "SetNameForView (0x%08x) %s   Task: 0x%08x   Level: %s",
; 1696 :               lpView, cpcName,
; 1697 :               lpSubtaskView ? lpSubtaskView->hTask : lpView->hTask,
; 1698 :               nLevel & 1 ? "SUBTASK" : nLevel & 2 ? "TASK" : nLevel & 4 ?
; 1699 :                 "APPLICATION" : nLevel & 8 ? "SYSTEM" : "UNKNOWN" );
; 1700 : #endif
; 1701 : 
; 1702 :    if ( (nLevel & zLEVEL_SUBTASK) &&

	movsx	ecx, WORD PTR _nLevel$[ebp]
	and	ecx, 1
	je	SHORT $LN21@SetNameFor
	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidSubtaskView
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN21@SetNameFor

; 1703 :         (fnValidSubtaskView( lpCurrentTask, lpSubtaskView )) == 0 )
; 1704 :    {
; 1705 :       TraceLineS( "(vm) Invalid subtask -- name = ", cpcName );

	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	push	OFFSET $SG13953
	call	_TraceLineS@8

; 1706 :       fnOperationReturn( iSetNameForView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	204					; 000000ccH
	call	_fnOperationReturn
	add	esp, 8

; 1707 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetNameFor
$LN21@SetNameFor:

; 1708 :    }
; 1709 : 
; 1710 :    if ( (nLevel & zLEVEL_APPLICATION) || lpSubtaskView )

	movsx	ecx, WORD PTR _nLevel$[ebp]
	and	ecx, 4
	jne	SHORT $LN24@SetNameFor
	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	je	$LN22@SetNameFor
$LN24@SetNameFor:

; 1711 :    {
; 1712 :       // If level is application but lpSubtaskView is not specified, then
; 1713 :       // use the lpView.
; 1714 :       if ( lpSubtaskView == 0 )

	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	jne	SHORT $LN25@SetNameFor

; 1715 :          lpSubtaskView = lpView;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR _lpSubtaskView$[ebp], edx
$LN25@SetNameFor:

; 1716 : 
; 1717 :       // Since we are using the passed view in SetNameForView, we should
; 1718 :       // probably use the task of the passed view as the task on which to
; 1719 :       // hang the name.
; 1720 :       lpTask = zGETPTR( lpSubtaskView->hTask );

	mov	eax, DWORD PTR _lpSubtaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax

; 1721 :       if ( (nLevel & zLEVEL_APPLICATION) &&
; 1722 :            lpView->bApplicationView == FALSE &&
; 1723 :            lpTask->bApplicationTask == FALSE &&

	movsx	edx, WORD PTR _nLevel$[ebp]
	and	edx, 4
	je	SHORT $LN26@SetNameFor
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 3
	and	ecx, 1
	jne	SHORT $LN26@SetNameFor
	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+443]
	shr	eax, 13					; 0000000dH
	and	eax, 1
	jne	SHORT $LN26@SetNameFor
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [ecx+14]
	cmp	eax, DWORD PTR [edx+106]
	je	SHORT $LN26@SetNameFor

; 1724 :            lpView->hTask != AnchorBlock->hMainTask )
; 1725 :       {
; 1726 :       // static zSHORT k = 0;
; 1727 :       // zCHAR szDebug[ 2 ];
; 1728 : 
; 1729 :          TraceLineS( "(vm) Naming non-application level view at the application level: ",

	mov	ecx, DWORD PTR _cpcName$[ebp]
	push	ecx
	push	OFFSET $SG13959
	call	_TraceLineS@8
$LN26@SetNameFor:

; 1730 :                      cpcName );
; 1731 : 
; 1732 :       // SysReadZeidonIni( -1, "[Debug]", "BombZDr", szDebug );
; 1733 :       // if ( szDebug[ 0 ] == 'Y' )
; 1734 :       // {
; 1735 :       //    k /= k;
; 1736 :       //    k++;
; 1737 :       // }
; 1738 :       }
; 1739 : 
; 1740 :       if ( fnValidView( lpCurrentTask, lpSubtaskView ) == 0 )

	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidView
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN27@SetNameFor

; 1741 :       {
; 1742 :          TraceLineS( "(vm) Invalid view -- name = ", cpcName );

	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	push	OFFSET $SG13961
	call	_TraceLineS@8

; 1743 :          fnOperationReturn( iSetNameForView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	204					; 000000ccH
	call	_fnOperationReturn
	add	esp, 8

; 1744 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SetNameFor
$LN27@SetNameFor:

; 1745 :       }
; 1746 :    }

	jmp	SHORT $LN23@SetNameFor
$LN22@SetNameFor:

; 1747 :    else
; 1748 :       lpTask = lpCurrentTask;

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpTask$[ebp], ecx
$LN23@SetNameFor:

; 1749 : 
; 1750 :    if ( nLevel & zNAME_AUTODROP )

	movsx	edx, WORD PTR _nLevel$[ebp]
	and	edx, 64					; 00000040H
	je	SHORT $LN28@SetNameFor

; 1751 :    {
; 1752 :       bAutoDrop = TRUE;

	mov	BYTE PTR _bAutoDrop$[ebp], 1

; 1753 :       nLevel -= zNAME_AUTODROP;

	movsx	eax, WORD PTR _nLevel$[ebp]
	sub	eax, 64					; 00000040H
	mov	WORD PTR _nLevel$[ebp], ax

; 1754 :    }

	jmp	SHORT $LN29@SetNameFor
$LN28@SetNameFor:

; 1755 :    else
; 1756 :       bAutoDrop = 0;

	mov	BYTE PTR _bAutoDrop$[ebp], 0
$LN29@SetNameFor:

; 1757 : 
; 1758 :    // Check for valid scope.
; 1759 :    if ( (nLevel & zLEVEL_SUBTASK) == 0     && (nLevel & zLEVEL_TASK) == 0   &&
; 1760 :         (nLevel & zLEVEL_APPLICATION) == 0 && (nLevel & zLEVEL_SYSTEM) == 0 &&

	movsx	ecx, WORD PTR _nLevel$[ebp]
	and	ecx, 1
	jne	SHORT $LN30@SetNameFor
	movsx	edx, WORD PTR _nLevel$[ebp]
	and	edx, 2
	jne	SHORT $LN30@SetNameFor
	movsx	eax, WORD PTR _nLevel$[ebp]
	and	eax, 4
	jne	SHORT $LN30@SetNameFor
	movsx	ecx, WORD PTR _nLevel$[ebp]
	and	ecx, 8
	jne	SHORT $LN30@SetNameFor
	movsx	edx, WORD PTR _nLevel$[ebp]
	and	edx, 15					; 0000000fH
	jne	SHORT $LN30@SetNameFor

; 1761 :         (nLevel & zLEVEL_ANY) == 0 )
; 1762 :    {
; 1763 :       //  "KZOEE110 - Invalid scope for View name"
; 1764 :       fnIssueCoreError( lpCurrentTask, lpView, 8, 110, (zLONG) nLevel, 0, 0 );

	push	0
	push	0
	movsx	eax, WORD PTR _nLevel$[ebp]
	push	eax
	push	110					; 0000006eH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1765 :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 1766 :       TraceLineS( "(vm) Invalid scoping level -- name = ", cpcName );

	mov	ecx, DWORD PTR _cpcName$[ebp]
	push	ecx
	push	OFFSET $SG13965
	call	_TraceLineS@8
$LN30@SetNameFor:

; 1767 :    }
; 1768 : 
; 1769 :    // Depending on the scope parameter, check the appropriate name chain
; 1770 :    // for the name being created.
; 1771 :    nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 1772 :    if ( cpcName && cpcName[ 0 ] )

	cmp	DWORD PTR _cpcName$[ebp], 0
	je	$LN31@SetNameFor
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	$LN31@SetNameFor

; 1773 :    {
; 1774 :       if ( nLevel == zLEVEL_SUBTASK )

	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 1
	jne	$LN32@SetNameFor

; 1775 :       {
; 1776 :          // First, see if the name exists in the subtask.
; 1777 :          lpSubtask = zGETPTR( lpSubtaskView->hSubtask );

	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 1778 :          lpViewName = zGETPTR( lpSubtask->hFirstViewName );

	mov	ecx, DWORD PTR _lpSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN2@SetNameFor:

; 1779 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN3@SetNameFor

; 1780 :          {
; 1781 :             if ( zstrcmp( lpViewName->szName, cpcName ) == 0 )

	mov	eax, DWORD PTR _lpViewName$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _cpcName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN64@SetNameFor
	mov	ecx, DWORD PTR _cpcName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewName$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv253[ebp], eax
	jmp	SHORT $LN65@SetNameFor
$LN64@SetNameFor:
	mov	eax, DWORD PTR _lpViewName$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _cpcName$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN62@SetNameFor
	mov	DWORD PTR tv252[ebp], 1
	jmp	SHORT $LN63@SetNameFor
$LN62@SetNameFor:
	mov	DWORD PTR tv252[ebp], -1
$LN63@SetNameFor:
	mov	ecx, DWORD PTR tv252[ebp]
	mov	DWORD PTR tv253[ebp], ecx
$LN65@SetNameFor:
	cmp	DWORD PTR tv253[ebp], 0
	jne	SHORT $LN34@SetNameFor

; 1782 :                break;

	jmp	SHORT $LN3@SetNameFor
$LN34@SetNameFor:

; 1783 : 
; 1784 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1785 :          }

	jmp	SHORT $LN2@SetNameFor
$LN3@SetNameFor:

; 1786 : 
; 1787 :          // If the view name was found, change it to point to the view
; 1788 :          // just passed in.
; 1789 :          if ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN35@SetNameFor

; 1790 :          {
; 1791 :             zVIEW lpTempView = zGETPTR( lpViewName->hView );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempView$4[ebp], eax

; 1792 : 
; 1793 :             lpTempView->nViewNames--;

	mov	eax, DWORD PTR _lpTempView$4[ebp]
	mov	cx, WORD PTR [eax+22]
	sub	cx, 1
	mov	edx, DWORD PTR _lpTempView$4[ebp]
	mov	WORD PTR [edx+22], cx

; 1794 :             lpViewName->hView = zGETHNDL( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR [ecx+2], eax

; 1795 :             lpView->nViewNames++;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	ax, WORD PTR [edx+22]
	add	ax, 1
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [ecx+22], ax

; 1796 :          }

	jmp	$LN36@SetNameFor
$LN35@SetNameFor:

; 1797 :          else
; 1798 :          {
; 1799 :             hViewName = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10022					; 00002726H
	push	0
	push	0
	push	75					; 0000004bH
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hViewName$[ebp], eax

; 1800 :                                           sizeof( ViewNameRecord ), 0, 0,
; 1801 :                                           iViewName );
; 1802 :             lpViewName = zGETPTR( hViewName );

	mov	ecx, DWORD PTR _hViewName$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1803 :             if ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN37@SetNameFor

; 1804 :             {
; 1805 :                zstrcpy( lpViewName->szName, cpcName );

	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewName$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcpy
	add	esp, 8

; 1806 :                lpViewName->hView = zGETHNDL( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR [edx+2], eax

; 1807 :                lpView->nViewNames++;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	cx, WORD PTR [eax+22]
	add	cx, 1
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [edx+22], cx

; 1808 :                lpViewName->hNextViewName = lpSubtask->hFirstViewName;

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR _lpSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+18]
	mov	DWORD PTR [eax+6], edx

; 1809 :                lpSubtask->hFirstViewName = hViewName;

	mov	eax, DWORD PTR _lpSubtask$[ebp]
	mov	ecx, DWORD PTR _hViewName$[ebp]
	mov	DWORD PTR [eax+18], ecx

; 1810 :             }

	jmp	SHORT $LN36@SetNameFor
$LN37@SetNameFor:

; 1811 :             else
; 1812 :                nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN36@SetNameFor:

; 1813 :          }
; 1814 :       }

	jmp	$LN33@SetNameFor
$LN32@SetNameFor:

; 1815 :       else
; 1816 :       if ( nLevel == zLEVEL_TASK )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 2
	jne	$LN39@SetNameFor

; 1817 :       {
; 1818 :          // First, see if the name exists in the task.
; 1819 :          lpViewName = zGETPTR( lpTask->hFirstViewName );

	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+110]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN4@SetNameFor:

; 1820 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN5@SetNameFor

; 1821 :          {
; 1822 :             if ( zstrcmp( lpViewName->szName, cpcName ) == 0 )

	mov	eax, DWORD PTR _lpViewName$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _cpcName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN68@SetNameFor
	mov	ecx, DWORD PTR _cpcName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewName$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv316[ebp], eax
	jmp	SHORT $LN69@SetNameFor
$LN68@SetNameFor:
	mov	eax, DWORD PTR _lpViewName$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _cpcName$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN66@SetNameFor
	mov	DWORD PTR tv315[ebp], 1
	jmp	SHORT $LN67@SetNameFor
$LN66@SetNameFor:
	mov	DWORD PTR tv315[ebp], -1
$LN67@SetNameFor:
	mov	ecx, DWORD PTR tv315[ebp]
	mov	DWORD PTR tv316[ebp], ecx
$LN69@SetNameFor:
	cmp	DWORD PTR tv316[ebp], 0
	jne	SHORT $LN41@SetNameFor

; 1823 :                break;

	jmp	SHORT $LN5@SetNameFor
$LN41@SetNameFor:

; 1824 : 
; 1825 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1826 :          }

	jmp	SHORT $LN4@SetNameFor
$LN5@SetNameFor:

; 1827 : 
; 1828 :          // If the view name was found, change it to point to the view
; 1829 :          // just passed in.
; 1830 :          if ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN42@SetNameFor

; 1831 :          {
; 1832 :             zVIEW lpTempView = zGETPTR( lpViewName->hView );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempView$3[ebp], eax

; 1833 : 
; 1834 :             lpTempView->nViewNames--;

	mov	eax, DWORD PTR _lpTempView$3[ebp]
	mov	cx, WORD PTR [eax+22]
	sub	cx, 1
	mov	edx, DWORD PTR _lpTempView$3[ebp]
	mov	WORD PTR [edx+22], cx

; 1835 :             lpViewName->hView = zGETHNDL( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR [ecx+2], eax

; 1836 :             lpView->nViewNames++;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	ax, WORD PTR [edx+22]
	add	ax, 1
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [ecx+22], ax

; 1837 :             lpView->bTaskNamed = TRUE;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	eax, 1
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 1838 :          }

	jmp	$LN43@SetNameFor
$LN42@SetNameFor:

; 1839 :          else
; 1840 :          {
; 1841 :             hViewName = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10022					; 00002726H
	push	0
	push	0
	push	75					; 0000004bH
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hViewName$[ebp], eax

; 1842 :                                           sizeof( ViewNameRecord ), 0, 0,
; 1843 :                                           iViewName );
; 1844 :             lpViewName = zGETPTR( hViewName );

	mov	ecx, DWORD PTR _hViewName$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1845 :             if ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN44@SetNameFor

; 1846 :             {
; 1847 :                zstrcpy( lpViewName->szName, cpcName );

	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewName$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcpy
	add	esp, 8

; 1848 :                lpViewName->hView = zGETHNDL( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR [edx+2], eax

; 1849 :                lpView->nViewNames++;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	cx, WORD PTR [eax+22]
	add	cx, 1
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [edx+22], cx

; 1850 :                lpView->bTaskNamed = TRUE;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 1
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+30], ecx

; 1851 :                lpViewName->hNextViewName = lpTask->hFirstViewName;

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR _lpTask$[ebp]
	mov	edx, DWORD PTR [ecx+110]
	mov	DWORD PTR [eax+6], edx

; 1852 :                lpTask->hFirstViewName = hViewName;

	mov	eax, DWORD PTR _lpTask$[ebp]
	mov	ecx, DWORD PTR _hViewName$[ebp]
	mov	DWORD PTR [eax+110], ecx

; 1853 :             }

	jmp	SHORT $LN43@SetNameFor
$LN44@SetNameFor:

; 1854 :             else
; 1855 :                nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN43@SetNameFor:

; 1856 :          }
; 1857 :       }

	jmp	$LN33@SetNameFor
$LN39@SetNameFor:

; 1858 :       else
; 1859 :       if ( nLevel == zLEVEL_APPLICATION )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 4
	jne	$LN46@SetNameFor

; 1860 :       {
; 1861 :          // First, see if the name exists at the application level.
; 1862 :          // The application level is determined by the view being named.
; 1863 :          // If the view being named is a subtask view, then the application
; 1864 :          // is the application for the subtask. Otherwise, if the view has a
; 1865 :          // ViewOD, the application is the app for the ViewOD. If all else
; 1866 :          // fails, we will use the application associated with the task.
; 1867 : 
; 1868 :          fnGetApplicationForSubtask( &lpApp, lpSubtaskView );

	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpApp$[ebp]
	push	edx
	call	_fnGetApplicationForSubtask@8

; 1869 :          lpViewName = zGETPTR( lpApp->hFirstViewName );

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR [eax+1893]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN6@SetNameFor:

; 1870 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN7@SetNameFor

; 1871 :          {
; 1872 :             if ( zstrcmp( lpViewName->szName, cpcName ) == 0 )

	mov	edx, DWORD PTR _lpViewName$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _cpcName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN72@SetNameFor
	mov	eax, DWORD PTR _cpcName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv387[ebp], eax
	jmp	SHORT $LN73@SetNameFor
$LN72@SetNameFor:
	mov	edx, DWORD PTR _lpViewName$[ebp]
	movsx	eax, BYTE PTR [edx+10]
	mov	ecx, DWORD PTR _cpcName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN70@SetNameFor
	mov	DWORD PTR tv386[ebp], 1
	jmp	SHORT $LN71@SetNameFor
$LN70@SetNameFor:
	mov	DWORD PTR tv386[ebp], -1
$LN71@SetNameFor:
	mov	eax, DWORD PTR tv386[ebp]
	mov	DWORD PTR tv387[ebp], eax
$LN73@SetNameFor:
	cmp	DWORD PTR tv387[ebp], 0
	jne	SHORT $LN48@SetNameFor

; 1873 :                break;

	jmp	SHORT $LN7@SetNameFor
$LN48@SetNameFor:

; 1874 : 
; 1875 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1876 :          }

	jmp	SHORT $LN6@SetNameFor
$LN7@SetNameFor:

; 1877 : 
; 1878 :          // If the view name was found, change it to point to the view
; 1879 :          // just passed in
; 1880 :          if ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN49@SetNameFor

; 1881 :          {
; 1882 :             zVIEW lpTempView = zGETPTR( lpViewName->hView );

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempView$2[ebp], eax

; 1883 : 
; 1884 :             lpTempView->nViewNames--;

	mov	edx, DWORD PTR _lpTempView$2[ebp]
	mov	ax, WORD PTR [edx+22]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpTempView$2[ebp]
	mov	WORD PTR [ecx+22], ax

; 1885 :             lpViewName->hView = zGETHNDL( lpView );

	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR [ecx+2], eax

; 1886 :             lpView->nViewNames++;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	ax, WORD PTR [edx+22]
	add	ax, 1
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [ecx+22], ax

; 1887 :             lpView->bApplicationNamed = TRUE;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	eax, 2
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 1888 :          }

	jmp	$LN50@SetNameFor
$LN49@SetNameFor:

; 1889 :          else
; 1890 :          {
; 1891 :             hViewName = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10022					; 00002726H
	push	0
	push	0
	push	75					; 0000004bH
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hViewName$[ebp], eax

; 1892 :                                           sizeof( ViewNameRecord ), 0, 0,
; 1893 :                                           iViewName );
; 1894 :             lpViewName = zGETPTR( hViewName );

	mov	ecx, DWORD PTR _hViewName$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1895 :             if ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN51@SetNameFor

; 1896 :             {
; 1897 :                zstrcpy( lpViewName->szName, cpcName );

	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewName$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcpy
	add	esp, 8

; 1898 :                lpViewName->hView = zGETHNDL( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR [edx+2], eax

; 1899 :                lpView->nViewNames++;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	cx, WORD PTR [eax+22]
	add	cx, 1
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [edx+22], cx

; 1900 :                lpView->bApplicationNamed = TRUE;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 2
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+30], ecx

; 1901 :                lpViewName->hNextViewName = lpApp->hFirstViewName;

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR [ecx+1893]
	mov	DWORD PTR [eax+6], edx

; 1902 :                lpApp->hFirstViewName = hViewName;

	mov	eax, DWORD PTR _lpApp$[ebp]
	mov	ecx, DWORD PTR _hViewName$[ebp]
	mov	DWORD PTR [eax+1893], ecx

; 1903 :             }

	jmp	SHORT $LN50@SetNameFor
$LN51@SetNameFor:

; 1904 :             else
; 1905 :                nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN50@SetNameFor:

; 1906 :          }
; 1907 :       }

	jmp	$LN33@SetNameFor
$LN46@SetNameFor:

; 1908 :       else
; 1909 :       if ( nLevel == zLEVEL_SYSTEM )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 8
	jne	$LN53@SetNameFor

; 1910 :       {
; 1911 :          zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 1912 : 
; 1913 :          // First, see if the name exists at the system level
; 1914 :          lpViewName = zGETPTR( AnchorBlock->hFirstViewName );

	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+1489]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN8@SetNameFor:

; 1915 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN9@SetNameFor

; 1916 :          {
; 1917 :             if ( zstrcmp( lpViewName->szName, cpcName ) == 0 )

	mov	eax, DWORD PTR _lpViewName$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _cpcName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN76@SetNameFor
	mov	ecx, DWORD PTR _cpcName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewName$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv457[ebp], eax
	jmp	SHORT $LN77@SetNameFor
$LN76@SetNameFor:
	mov	eax, DWORD PTR _lpViewName$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _cpcName$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN74@SetNameFor
	mov	DWORD PTR tv456[ebp], 1
	jmp	SHORT $LN75@SetNameFor
$LN74@SetNameFor:
	mov	DWORD PTR tv456[ebp], -1
$LN75@SetNameFor:
	mov	ecx, DWORD PTR tv456[ebp]
	mov	DWORD PTR tv457[ebp], ecx
$LN77@SetNameFor:
	cmp	DWORD PTR tv457[ebp], 0
	jne	SHORT $LN55@SetNameFor

; 1918 :                break;

	jmp	SHORT $LN9@SetNameFor
$LN55@SetNameFor:

; 1919 : 
; 1920 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1921 :          }

	jmp	SHORT $LN8@SetNameFor
$LN9@SetNameFor:

; 1922 : 
; 1923 :          // If the view name was found, change it to point to the view
; 1924 :          // just passed in
; 1925 :          if ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN56@SetNameFor

; 1926 :          {
; 1927 :             zVIEW lpTempView = zGETPTR( lpViewName->hView );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTempView$1[ebp], eax

; 1928 : 
; 1929 :             lpTempView->nViewNames--;

	mov	eax, DWORD PTR _lpTempView$1[ebp]
	mov	cx, WORD PTR [eax+22]
	sub	cx, 1
	mov	edx, DWORD PTR _lpTempView$1[ebp]
	mov	WORD PTR [edx+22], cx

; 1930 :             lpViewName->hView = zGETHNDL( lpView );

	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetHndl
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR [ecx+2], eax

; 1931 :             lpView->nViewNames++;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	ax, WORD PTR [edx+22]
	add	ax, 1
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [ecx+22], ax

; 1932 :             lpView->bSystemNamed = TRUE;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	eax, 4
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax

; 1933 :          }

	jmp	$LN57@SetNameFor
$LN56@SetNameFor:

; 1934 :          else
; 1935 :          {
; 1936 :             hViewName = fnAllocDataspace( AnchorBlock->hMainFirstDataHeader,

	push	10022					; 00002726H
	push	0
	push	0
	push	75					; 0000004bH
	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+114]
	push	eax
	call	_fnAllocDataspace
	add	esp, 20					; 00000014H
	mov	DWORD PTR _hViewName$[ebp], eax

; 1937 :                                           sizeof( ViewNameRecord ), 0, 0,
; 1938 :                                           iViewName );
; 1939 :             lpViewName = zGETPTR( hViewName );

	mov	ecx, DWORD PTR _hViewName$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 1940 :             if ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN58@SetNameFor

; 1941 :             {
; 1942 :                zstrcpy( lpViewName->szName, cpcName );

	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewName$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcpy
	add	esp, 8

; 1943 :                lpViewName->hView = zGETHNDL( lpView );

	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	DWORD PTR [edx+2], eax

; 1944 :                lpView->nViewNames++;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	cx, WORD PTR [eax+22]
	add	cx, 1
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [edx+22], cx

; 1945 :                lpView->bSystemNamed = TRUE;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 4
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+30], ecx

; 1946 :                lpViewName->hNextViewName = AnchorBlock->hFirstViewName;

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR _AnchorBlock
	mov	edx, DWORD PTR [ecx+1489]
	mov	DWORD PTR [eax+6], edx

; 1947 :                AnchorBlock->hFirstViewName = hViewName;

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR _hViewName$[ebp]
	mov	DWORD PTR [eax+1489], ecx

; 1948 :             }

	jmp	SHORT $LN57@SetNameFor
$LN58@SetNameFor:

; 1949 :             else
; 1950 :                nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN57@SetNameFor:

; 1951 :          }
; 1952 : 
; 1953 :          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4

; 1954 :       }

	jmp	SHORT $LN33@SetNameFor
$LN53@SetNameFor:

; 1955 :       else
; 1956 :       {
; 1957 :          //  "KZOEE110 - Invalid scope for View name"
; 1958 :          fnIssueCoreError( lpCurrentTask, lpView, 8, 110, (zLONG) nLevel, 0, 0 );

	push	0
	push	0
	movsx	eax, WORD PTR _nLevel$[ebp]
	push	eax
	push	110					; 0000006eH
	push	8
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 1959 :          lpViewName = 0;

	mov	DWORD PTR _lpViewName$[ebp], 0

; 1960 :          nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax
$LN33@SetNameFor:

; 1961 :       }
; 1962 : 
; 1963 :       // Now that the name has been created, increment the autodrop
; 1964 :       // counter if autodrop was specified
; 1965 :       if ( bAutoDrop && lpViewName )

	movzx	ecx, BYTE PTR _bAutoDrop$[ebp]
	test	ecx, ecx
	je	SHORT $LN31@SetNameFor
	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN31@SetNameFor

; 1966 :       {
; 1967 :          lpView->nAutoDropNames++;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	ax, WORD PTR [edx+24]
	add	ax, 1
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	WORD PTR [ecx+24], ax
$LN31@SetNameFor:

; 1968 :       }
; 1969 :    }
; 1970 : 
; 1971 :    fnOperationReturn( iSetNameForView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	204					; 000000ccH
	call	_fnOperationReturn
	add	esp, 8

; 1972 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetNameFor:

; 1973 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_SetNameForView@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_vSubtask$ = -120					; size = 4
_lpApp$ = -116						; size = 4
_lpSubtask$ = -112					; size = 4
tv453 = -108						; size = 4
tv400 = -104						; size = 4
tv452 = -100						; size = 4
tv450 = -96						; size = 4
tv448 = -92						; size = 4
tv414 = -88						; size = 4
tv399 = -84						; size = 4
tv397 = -80						; size = 4
tv395 = -76						; size = 4
tv393 = -72						; size = 4
tv380 = -68						; size = 4
tv379 = -64						; size = 4
_lpTask$1 = -60						; size = 4
tv346 = -56						; size = 4
tv345 = -52						; size = 4
tv316 = -48						; size = 4
tv315 = -44						; size = 4
tv287 = -40						; size = 4
tv286 = -36						; size = 4
_lpTask$2 = -32						; size = 4
tv251 = -28						; size = 4
tv250 = -24						; size = 4
_hCurrentTask$ = -20					; size = 4
_lpVName$3 = -16					; size = 4
_lpCurrentTask$ = -12					; size = 4
_lpViewName$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pvReturnView$ = 8					; size = 4
_cpcName$ = 12						; size = 4
_lpSubtaskView$ = 16					; size = 4
_nLevel$ = 20						; size = 2
_GetViewByName@16 PROC

; 2010 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H

; 2011 :    LPTASK      lpCurrentTask;
; 2012 :    LPTASK      hCurrentTask;
; 2013 :    zVIEW       vSubtask;
; 2014 :    LPSUBTASK   lpSubtask;
; 2015 :    LPVIEWNAME  lpViewName;
; 2016 :    LPAPP       lpApp;
; 2017 :    zSHORT      nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 2018 : 
; 2019 :    *pvReturnView = 0;  // initialize return view to NULL

	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [ecx], 0

; 2020 : 
; 2021 :    vSubtask = lpSubtaskView;

	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	mov	DWORD PTR _vSubtask$[ebp], edx

; 2022 : 
; 2023 :    if ( lpSubtaskView )

	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	je	SHORT $LN14@GetViewByN

; 2024 :       hCurrentTask = lpSubtaskView->hTask;

	mov	eax, DWORD PTR _lpSubtaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	mov	DWORD PTR _hCurrentTask$[ebp], ecx
	jmp	SHORT $LN15@GetViewByN
$LN14@GetViewByN:

; 2025 :    else
; 2026 :       hCurrentTask = 0;

	mov	DWORD PTR _hCurrentTask$[ebp], 0
$LN15@GetViewByN:

; 2027 : 
; 2028 : #if 1
; 2029 :    if ( lpSubtaskView == 0 )

	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	jne	SHORT $LN16@GetViewByN

; 2030 :    {
; 2031 :       if ( g_vDefaultTaskView )

	cmp	DWORD PTR _g_vDefaultTaskView, 0
	je	SHORT $LN18@GetViewByN

; 2032 :          lpSubtaskView = g_vDefaultTaskView;

	mov	edx, DWORD PTR _g_vDefaultTaskView
	mov	DWORD PTR _lpSubtaskView$[ebp], edx
	jmp	SHORT $LN19@GetViewByN
$LN18@GetViewByN:

; 2033 :       else
; 2034 :          SysMessageBox( 0, "OE Error", "GetViewByName now requires a valid view", -1 );

	push	-1
	push	OFFSET $SG14077
	push	OFFSET $SG14078
	push	0
	call	_SysMessageBox@16
$LN19@GetViewByN:

; 2035 :    }

	jmp	$LN17@GetViewByN
$LN16@GetViewByN:

; 2036 :    else
; 2037 :    if ( g_vDefaultTaskView && nLevel == zLEVEL_TASK )

	cmp	DWORD PTR _g_vDefaultTaskView, 0
	je	$LN17@GetViewByN
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 2
	jne	$LN17@GetViewByN

; 2038 :    {
; 2039 :       if ( lpSubtaskView->hTask != g_vDefaultTaskView->hTask )

	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	mov	edx, DWORD PTR _g_vDefaultTaskView
	mov	eax, DWORD PTR [ecx+14]
	cmp	eax, DWORD PTR [edx+14]
	je	$LN17@GetViewByN

; 2040 :       {
; 2041 :          lpCurrentTask = zGETPTR( lpSubtaskView->hTask );

	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpCurrentTask$[ebp], eax

; 2042 :          if ( lpCurrentTask && lpCurrentTask->bTransientTask )

	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	je	SHORT $LN22@GetViewByN
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	mov	ecx, DWORD PTR [eax+443]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN22@GetViewByN

; 2043 :          {
; 2044 :             TraceLine( "GetViewByName sending in view for TRANSIENT task: %d (0x%08x)  "

	mov	edx, DWORD PTR _g_vDefaultTaskView
	mov	eax, DWORD PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _g_vDefaultTaskView
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR _lpSubtaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	push	OFFSET $SG14083
	call	_TraceLine
	add	esp, 20					; 00000014H

; 2045 :                          "should be for task: %d (0x%08x) ... WILL NOT RESET TASK VIEW",
; 2046 :                        lpSubtaskView->hTask, lpSubtaskView->hTask,
; 2047 :                        g_vDefaultTaskView->hTask, g_vDefaultTaskView->hTask );
; 2048 :          }

	jmp	SHORT $LN17@GetViewByN
$LN22@GetViewByN:

; 2049 :          else
; 2050 :          {
; 2051 :          // SysMessageBox( 0, "Zeidon OE", "GetViewByName now RESETTING TASK VIEW", 0 );
; 2052 :             if ( g_nOE_TraceWarning )

	movsx	ecx, WORD PTR _g_nOE_TraceWarning
	test	ecx, ecx
	je	SHORT $LN24@GetViewByN

; 2053 :             {
; 2054 :                TraceLine( "GetViewByName sending in view for task: %d (0x%08x)  "

	mov	edx, DWORD PTR _g_vDefaultTaskView
	mov	eax, DWORD PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _g_vDefaultTaskView
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	mov	eax, DWORD PTR _lpSubtaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	push	OFFSET $SG14085
	call	_TraceLine
	add	esp, 20					; 00000014H
$LN24@GetViewByN:

; 2055 :                             "should be for task: %d (0x%08x) ... RESETTING TASK VIEW",
; 2056 :                           lpSubtaskView->hTask, lpSubtaskView->hTask,
; 2057 :                           g_vDefaultTaskView->hTask, g_vDefaultTaskView->hTask );
; 2058 :             }
; 2059 : 
; 2060 :             lpSubtaskView = g_vDefaultTaskView;

	mov	ecx, DWORD PTR _g_vDefaultTaskView
	mov	DWORD PTR _lpSubtaskView$[ebp], ecx
$LN17@GetViewByN:

; 2061 :          }
; 2062 :       }
; 2063 :    }
; 2064 : #endif
; 2065 : 
; 2066 :    // If task not active or disabled, return zCALL_ERROR.
; 2067 :    if ( (lpCurrentTask = fnOperationCall( iGetViewByName, lpSubtaskView, 0 )) == 0 )

	push	0
	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	push	edx
	push	206					; 000000ceH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN4@GetViewByN

; 2068 :    {
; 2069 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@GetViewByN
$LN4@GetViewByN:

; 2070 :    }
; 2071 : 
; 2072 : // if ( zstrcmp( cpcName, "vERD_LPLR" ) == 0 )
; 2073 : // TraceLine( "GetViewByName for: %s   Task: %d (0x%08x)   CurrentTask %d (0x%08x)",
; 2074 : //            cpcName, lpSubtaskView->hTask, lpSubtaskView->hTask,
; 2075 : //            zGETHNDL( lpCurrentTask ), zGETHNDL( lpCurrentTask ) );
; 2076 : 
; 2077 :    do  // begin purist's goto
; 2078 :    {
; 2079 :       // Check for valid scope.
; 2080 :       if ( nLevel != zLEVEL_SUBTASK     && nLevel != zLEVEL_TASK   &&
; 2081 :            nLevel != zLEVEL_APPLICATION && nLevel != zLEVEL_SYSTEM &&

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 1
	je	SHORT $LN26@GetViewByN
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 2
	je	SHORT $LN26@GetViewByN
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 4
	je	SHORT $LN26@GetViewByN
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 8
	je	SHORT $LN26@GetViewByN
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 15					; 0000000fH
	je	SHORT $LN26@GetViewByN

; 2082 :            nLevel != zLEVEL_ANY )
; 2083 :       {
; 2084 :          TraceLineS( "GetViewByName Invalid scope for View name: ", cpcName );

	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	push	OFFSET $SG14088
	call	_TraceLineS@8

; 2085 :          //  "KZOEE110 - Invalid scope for View name"
; 2086 :          fnIssueCoreError( lpCurrentTask, lpSubtaskView, 8, 110, (zLONG) nLevel, 0, 0 );

	push	0
	push	0
	movsx	eax, WORD PTR _nLevel$[ebp]
	push	eax
	push	110					; 0000006eH
	push	8
	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2087 :       // fnOperationReturn( iGetViewByName, lpCurrentTask );
; 2088 :          break;

	jmp	$LN3@GetViewByN
$LN26@GetViewByN:

; 2089 :       }
; 2090 : 
; 2091 :       if ( cpcName == 0 || cpcName[ 0 ] == 0 ||

	cmp	DWORD PTR _cpcName$[ebp], 0
	je	SHORT $LN28@GetViewByN
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _cpcName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	SHORT $LN28@GetViewByN
	mov	ecx, DWORD PTR _cpcName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	eax, 64					; 00000040H
	jbe	SHORT $LN27@GetViewByN
$LN28@GetViewByN:

; 2092 :            zstrlen( cpcName ) > zZEIDON_NAME_LTH * 2 )
; 2093 :       {
; 2094 :          if ( cpcName && cpcName[ 0 ] )

	cmp	DWORD PTR _cpcName$[ebp], 0
	je	SHORT $LN29@GetViewByN
	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _cpcName$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN29@GetViewByN

; 2095 :          {
; 2096 :             TraceLineS( "GetViewByName Length Error: ", cpcName );

	mov	eax, DWORD PTR _cpcName$[ebp]
	push	eax
	push	OFFSET $SG14093
	call	_TraceLineS@8

; 2097 :             fnIssueCoreError( lpCurrentTask, lpSubtaskView, 8, 450, 0, cpcName, 0 );

	push	0
	mov	ecx, DWORD PTR _cpcName$[ebp]
	push	ecx
	push	0
	push	450					; 000001c2H
	push	8
	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2098 :          }

	jmp	SHORT $LN30@GetViewByN
$LN29@GetViewByN:

; 2099 :          else
; 2100 :          {
; 2101 :             TraceLineS( "GetViewByName - Empty name", "" );

	push	OFFSET $SG14094
	push	OFFSET $SG14095
	call	_TraceLineS@8
$LN30@GetViewByN:

; 2102 :          }
; 2103 : 
; 2104 :       // fnOperationReturn( iGetViewByName, lpCurrentTask );
; 2105 :          break;

	jmp	$LN3@GetViewByN
$LN27@GetViewByN:

; 2106 :       }
; 2107 : 
; 2108 :       // If user wants a subtask view make sure subtask is OK.
; 2109 :       if ( nLevel == zLEVEL_SUBTASK &&

	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 1
	jne	SHORT $LN31@GetViewByN
	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidSubtaskView
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN31@GetViewByN

; 2110 :            fnValidSubtaskView( lpCurrentTask, lpSubtaskView ) == 0 )
; 2111 :       {
; 2112 :          TraceLineS( "GetViewByName Invalid Subtask view for Name: ", cpcName );

	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	push	OFFSET $SG14097
	call	_TraceLineS@8

; 2113 :          break;  // view invalid

	jmp	$LN3@GetViewByN
$LN31@GetViewByN:

; 2114 :       }
; 2115 : 
; 2116 :       // If user specified ANY and specified a view make sure it's OK.
; 2117 :       if ( nLevel == zLEVEL_ANY &&

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 15					; 0000000fH
	jne	SHORT $LN32@GetViewByN
	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidSubtaskView
	add	esp, 8
	cwde
	test	eax, eax
	jne	SHORT $LN32@GetViewByN

; 2118 :            fnValidSubtaskView( lpCurrentTask, lpSubtaskView ) == 0 )
; 2119 :       {
; 2120 :          TraceLineS( "GetViewByName Invalid view for Name: ", cpcName );

	mov	ecx, DWORD PTR _cpcName$[ebp]
	push	ecx
	push	OFFSET $SG14099
	call	_TraceLineS@8

; 2121 :          break;  // view invalid

	jmp	$LN3@GetViewByN
$LN32@GetViewByN:

; 2122 :       }
; 2123 : 
; 2124 :       if ( nLevel == zLEVEL_APPLICATION || lpSubtaskView )

	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 4
	je	SHORT $LN34@GetViewByN
	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	je	SHORT $LN33@GetViewByN
$LN34@GetViewByN:

; 2125 :       {
; 2126 :          // If lpSubtaskView is not a subtask view, check to see if it's a
; 2127 :          // valid view.  (If lpSubtaskView is null, we know it's an invalid
; 2128 :          // view but we'll still call fnValidView to show the error message).
; 2129 :          if ( lpSubtaskView && lpSubtaskView->hSubtask == 0 )

	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	je	SHORT $LN35@GetViewByN
	mov	eax, DWORD PTR _lpSubtaskView$[ebp]
	cmp	DWORD PTR [eax+18], 0
	jne	SHORT $LN35@GetViewByN

; 2130 :          {
; 2131 :             if ( fnValidView( lpCurrentTask, lpSubtaskView ) == 0 )

	mov	ecx, DWORD PTR _lpSubtaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidView
	add	esp, 8
	cwde
	test	eax, eax
	jne	SHORT $LN37@GetViewByN

; 2132 :             {
; 2133 :                TraceLineS( "GetViewByName Invalid Subtask (null) for Name: ", cpcName );

	mov	ecx, DWORD PTR _cpcName$[ebp]
	push	ecx
	push	OFFSET $SG14105
	call	_TraceLineS@8

; 2134 :                break;  // view invalid

	jmp	$LN3@GetViewByN
$LN37@GetViewByN:

; 2135 :             }
; 2136 :          }

	jmp	SHORT $LN33@GetViewByN
$LN35@GetViewByN:

; 2137 :          else
; 2138 :          // lpSubtaskView is a subtask view--check for validity.
; 2139 :          if ( fnValidSubtaskView( lpCurrentTask, lpSubtaskView ) == 0 )

	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	call	_fnValidSubtaskView
	add	esp, 8
	movsx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN33@GetViewByN

; 2140 :          {
; 2141 :             TraceLineS( "GetViewByName Invalid Subtask view for Name: ", cpcName );

	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	push	OFFSET $SG14107
	call	_TraceLineS@8

; 2142 :             break;  // view invalid

	jmp	$LN3@GetViewByN
$LN33@GetViewByN:

; 2143 :          }
; 2144 :       }
; 2145 : 
; 2146 :       // Depending on the scope parameter, look in the appropriate name chain
; 2147 :       // for the name requested.
; 2148 :       nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax

; 2149 :       lpViewName = 0;

	mov	DWORD PTR _lpViewName$[ebp], 0

; 2150 :       if ( nLevel == zLEVEL_SUBTASK || (nLevel == zLEVEL_ANY && lpSubtaskView) )

	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 1
	je	SHORT $LN40@GetViewByN
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 15					; 0000000fH
	jne	$LN39@GetViewByN
	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	je	$LN39@GetViewByN
$LN40@GetViewByN:

; 2151 :       {
; 2152 :          // Look for the requested name in the subtask
; 2153 :          lpSubtask = zGETPTR( lpSubtaskView->hSubtask );

	mov	eax, DWORD PTR _lpSubtaskView$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSubtask$[ebp], eax

; 2154 :          lpViewName = zGETPTR( lpSubtask->hFirstViewName );

	mov	edx, DWORD PTR _lpSubtask$[ebp]
	mov	eax, DWORD PTR [edx+18]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN5@GetViewByN:

; 2155 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN39@GetViewByN

; 2156 :          {
; 2157 :             if ( zstrcmp( lpViewName->szName, cpcName ) == 0 )

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _cpcName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN59@GetViewByN
	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewName$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv251[ebp], eax
	jmp	SHORT $LN60@GetViewByN
$LN59@GetViewByN:
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _cpcName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN57@GetViewByN
	mov	DWORD PTR tv250[ebp], 1
	jmp	SHORT $LN58@GetViewByN
$LN57@GetViewByN:
	mov	DWORD PTR tv250[ebp], -1
$LN58@GetViewByN:
	mov	edx, DWORD PTR tv250[ebp]
	mov	DWORD PTR tv251[ebp], edx
$LN60@GetViewByN:
	cmp	DWORD PTR tv251[ebp], 0
	jne	SHORT $LN41@GetViewByN

; 2158 :             {
; 2159 :                nRC = zLEVEL_SUBTASK;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 2160 :             // TraceLineS( "GetViewByName SUBTASK: ", cpcName );
; 2161 :                break;

	jmp	SHORT $LN39@GetViewByN
$LN41@GetViewByN:

; 2162 :             }
; 2163 : 
; 2164 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2165 :          }

	jmp	SHORT $LN5@GetViewByN
$LN39@GetViewByN:

; 2166 :       }
; 2167 : 
; 2168 :       if ( nLevel == zLEVEL_TASK || (nLevel == zLEVEL_ANY && nRC < 0) )

	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 2
	je	SHORT $LN43@GetViewByN
	movsx	ecx, WORD PTR _nLevel$[ebp]
	cmp	ecx, 15					; 0000000fH
	jne	$LN42@GetViewByN
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jge	$LN42@GetViewByN
$LN43@GetViewByN:

; 2169 :       {
; 2170 :          LPTASK     lpTask;
; 2171 :          LPVIEWNAME lpVName;  // debugging only
; 2172 : 
; 2173 :          // Look for the requested name in the task.  If a subtask view was
; 2174 :          // supplied use the task represented by the view.
; 2175 :          if ( lpSubtaskView )

	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	je	SHORT $LN44@GetViewByN

; 2176 :             lpTask = zGETPTR( lpSubtaskView->hTask );

	mov	eax, DWORD PTR _lpSubtaskView$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax
	jmp	SHORT $LN45@GetViewByN
$LN44@GetViewByN:

; 2177 :          else
; 2178 :             lpTask = lpCurrentTask;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpTask$2[ebp], edx
$LN45@GetViewByN:

; 2179 : 
; 2180 :       // TraceLineS( "GetViewByName looking for Task Level view by name: ",
; 2181 :       //             cpcName );
; 2182 :          for ( lpVName = zGETPTR( lpTask->hFirstViewName );

	mov	eax, DWORD PTR _lpTask$2[ebp]
	mov	ecx, DWORD PTR [eax+110]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVName$3[ebp], eax
	jmp	SHORT $LN9@GetViewByN
$LN7@GetViewByN:

; 2184 :                lpVName = zGETPTR( lpVName->hNextViewName ) )

	mov	edx, DWORD PTR _lpVName$3[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpVName$3[ebp], eax
$LN9@GetViewByN:

; 2183 :                lpVName;

	cmp	DWORD PTR _lpVName$3[ebp], 0
	je	SHORT $LN42@GetViewByN

; 2185 :          {
; 2186 :          // if ( zstrcmp( cpcName, "vERD_LPLR" ) == 0 )
; 2187 :          // TraceLine( "GetViewByName at Task Level 0x%08x ViewName: %s",
; 2188 :          //            zGETHNDL( lpTask ), lpVName->szName );
; 2189 : 
; 2190 :             if ( zstrcmp( lpVName->szName, cpcName ) == 0 )

	mov	ecx, DWORD PTR _lpVName$3[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _cpcName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN63@GetViewByN
	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpVName$3[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv287[ebp], eax
	jmp	SHORT $LN64@GetViewByN
$LN63@GetViewByN:
	mov	ecx, DWORD PTR _lpVName$3[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _cpcName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN61@GetViewByN
	mov	DWORD PTR tv286[ebp], 1
	jmp	SHORT $LN62@GetViewByN
$LN61@GetViewByN:
	mov	DWORD PTR tv286[ebp], -1
$LN62@GetViewByN:
	mov	edx, DWORD PTR tv286[ebp]
	mov	DWORD PTR tv287[ebp], edx
$LN64@GetViewByN:
	cmp	DWORD PTR tv287[ebp], 0
	jne	SHORT $LN46@GetViewByN

; 2191 :             {
; 2192 :                nRC = zLEVEL_TASK;

	mov	eax, 2
	mov	WORD PTR _nRC$[ebp], ax

; 2193 :             // TraceLineS( "GetViewByName TASK found: ", cpcName );
; 2194 :                lpViewName = lpVName;  // debugging only

	mov	ecx, DWORD PTR _lpVName$3[ebp]
	mov	DWORD PTR _lpViewName$[ebp], ecx

; 2195 :                break; // omitted for debugging only

	jmp	SHORT $LN42@GetViewByN
$LN46@GetViewByN:

; 2196 :             }
; 2197 :          }

	jmp	$LN7@GetViewByN
$LN42@GetViewByN:

; 2198 :       }
; 2199 : 
; 2200 :       if ( nLevel == zLEVEL_APPLICATION ||

	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 4
	je	SHORT $LN48@GetViewByN
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 15					; 0000000fH
	jne	$LN47@GetViewByN
	cmp	DWORD PTR _lpSubtaskView$[ebp], 0
	je	$LN47@GetViewByN
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	$LN47@GetViewByN
$LN48@GetViewByN:

; 2201 :            (nLevel == zLEVEL_ANY && lpSubtaskView && nRC < 0) )
; 2202 :       {
; 2203 :          // Get the application from the subtask if the view is a subtask
; 2204 :          // view. Otherwise, get the application from the view object if
; 2205 :          // one is present. If all else fails, use the application from
; 2206 :          // the current task.
; 2207 :          fnGetApplicationForSubtask( &lpApp, lpSubtaskView );

	mov	edx, DWORD PTR _lpSubtaskView$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpApp$[ebp]
	push	eax
	call	_fnGetApplicationForSubtask@8

; 2208 :          lpViewName = zGETPTR( lpApp->hFirstViewName );

	mov	ecx, DWORD PTR _lpApp$[ebp]
	mov	edx, DWORD PTR [ecx+1893]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN10@GetViewByN:

; 2209 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN47@GetViewByN

; 2210 :          {
; 2211 :             if ( zstrcmp( lpViewName->szName, cpcName ) == 0 )

	mov	eax, DWORD PTR _lpViewName$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _cpcName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN67@GetViewByN
	mov	ecx, DWORD PTR _cpcName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewName$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv316[ebp], eax
	jmp	SHORT $LN68@GetViewByN
$LN67@GetViewByN:
	mov	eax, DWORD PTR _lpViewName$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _cpcName$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN65@GetViewByN
	mov	DWORD PTR tv315[ebp], 1
	jmp	SHORT $LN66@GetViewByN
$LN65@GetViewByN:
	mov	DWORD PTR tv315[ebp], -1
$LN66@GetViewByN:
	mov	ecx, DWORD PTR tv315[ebp]
	mov	DWORD PTR tv316[ebp], ecx
$LN68@GetViewByN:
	cmp	DWORD PTR tv316[ebp], 0
	jne	SHORT $LN49@GetViewByN

; 2212 :             {
; 2213 :                nRC = zLEVEL_APPLICATION;

	mov	edx, 4
	mov	WORD PTR _nRC$[ebp], dx

; 2214 :             // TraceLineS( "GetViewByName APPLICATION: ", cpcName );
; 2215 :                break;

	jmp	SHORT $LN47@GetViewByN
$LN49@GetViewByN:

; 2216 :             }
; 2217 : 
; 2218 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	eax, DWORD PTR _lpViewName$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2219 :          }

	jmp	SHORT $LN10@GetViewByN
$LN47@GetViewByN:

; 2220 :       }
; 2221 : 
; 2222 :       if ( nLevel == zLEVEL_SYSTEM || (nLevel == zLEVEL_ANY && nRC < 0) )

	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	edx, 8
	je	SHORT $LN51@GetViewByN
	movsx	eax, WORD PTR _nLevel$[ebp]
	cmp	eax, 15					; 0000000fH
	jne	$LN2@GetViewByN
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jge	$LN2@GetViewByN
$LN51@GetViewByN:

; 2223 :       {
; 2224 :          zLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysLockCoreMutex@4

; 2225 : 
; 2226 :          // Look for the requested name at the system level
; 2227 :          lpViewName = zGETPTR( AnchorBlock->hFirstViewName );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+1489]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax
$LN12@GetViewByN:

; 2228 :          while ( lpViewName )

	cmp	DWORD PTR _lpViewName$[ebp], 0
	je	SHORT $LN13@GetViewByN

; 2229 :          {
; 2230 :             if ( zstrcmp( lpViewName->szName, cpcName ) == 0 )

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _cpcName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN71@GetViewByN
	mov	edx, DWORD PTR _cpcName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewName$[ebp]
	add	eax, 10					; 0000000aH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv346[ebp], eax
	jmp	SHORT $LN72@GetViewByN
$LN71@GetViewByN:
	mov	ecx, DWORD PTR _lpViewName$[ebp]
	movsx	edx, BYTE PTR [ecx+10]
	mov	eax, DWORD PTR _cpcName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN69@GetViewByN
	mov	DWORD PTR tv345[ebp], 1
	jmp	SHORT $LN70@GetViewByN
$LN69@GetViewByN:
	mov	DWORD PTR tv345[ebp], -1
$LN70@GetViewByN:
	mov	edx, DWORD PTR tv345[ebp]
	mov	DWORD PTR tv346[ebp], edx
$LN72@GetViewByN:
	cmp	DWORD PTR tv346[ebp], 0
	jne	SHORT $LN52@GetViewByN

; 2231 :             {
; 2232 :                nRC = zLEVEL_SYSTEM;

	mov	eax, 8
	mov	WORD PTR _nRC$[ebp], ax

; 2233 :             // TraceLineS( "GetViewByName SYSTEM: ", cpcName );
; 2234 :                break;

	jmp	SHORT $LN13@GetViewByN
$LN52@GetViewByN:

; 2235 :             }
; 2236 : 
; 2237 :             lpViewName = zGETPTR( lpViewName->hNextViewName );

	mov	ecx, DWORD PTR _lpViewName$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewName$[ebp], eax

; 2238 :          }

	jmp	SHORT $LN12@GetViewByN
$LN13@GetViewByN:

; 2239 : 
; 2240 :          zUNLOCK_MUTEX( zMUTEX_ANCHORBLOCK );

	push	2
	call	_fnSysUnlockCoreMutex@4
$LN2@GetViewByN:

; 2241 :       }
; 2242 : 
; 2243 :    } while ( FALSE );  // end of purist's goto

	xor	eax, eax
	jne	$LN4@GetViewByN
$LN3@GetViewByN:

; 2244 : 
; 2245 :    // If the return code from the search is > 0, then set the view to be
; 2246 :    // returned.
; 2247 :    if ( nRC > 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jle	SHORT $LN53@GetViewByN

; 2248 :    {
; 2249 :       // Set the view to be returned.
; 2250 :       *pvReturnView = zGETPTR( lpViewName->hView );

	mov	edx, DWORD PTR _lpViewName$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [ecx], eax
$LN53@GetViewByN:

; 2251 :    }
; 2252 : 
; 2253 : #if 0
; 2254 :    if ( zstrcmp( "OpenCM_Metas", cpcName ) == 0 )
; 2255 :    {
; 2256 :       SysMessageBox( lpSubtaskView, "GetViewByName", "OpenCM_Metas", 0 );
; 2257 :       TraceLineS( "GetViewByName: ", "OpenCM_Metas" );
; 2258 :    }
; 2259 : #endif
; 2260 : 
; 2261 : #if 0
; 2262 :    if ( cpcName[ 0 ] != '_' )
; 2263 :    TraceLine( "GetViewByName (0x%08x) %s   View/Task: 0x%08x/0x%08x   Level: %s   RC ===> %s",
; 2264 :               *pvReturnView, cpcName, lpSubtaskView, lpSubtaskView->hTask,
; 2265 :               (nLevel & 0x000F) == 0x000F ? "ANY" :
; 2266 :                 nLevel & 1 ? "SUBTASK" : nLevel & 2 ? "TASK" : nLevel & 4 ?
; 2267 :                 "APPLICATION" : nLevel & 8 ? "SYSTEM" : "UNKNOWN",
; 2268 :               nRC <= 0 ? "NOT FOUND" :
; 2269 :                 nRC & 1 ? "SUBTASK" : nRC & 2 ? "TASK" : nRC & 4 ?
; 2270 :                 "APPLICATION" : nRC & 8 ? "SYSTEM" : "UNKNOWN" );
; 2271 : #endif
; 2272 : 
; 2273 : #if 1
; 2274 :    if ( *pvReturnView && hCurrentTask &&             // dks debug

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	cmp	DWORD PTR [edx], 0
	je	$LN54@GetViewByN
	cmp	DWORD PTR _hCurrentTask$[ebp], 0
	je	$LN54@GetViewByN
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+14]
	cmp	edx, DWORD PTR _hCurrentTask$[ebp]
	je	$LN54@GetViewByN

; 2275 :         (*pvReturnView)->hTask != hCurrentTask )
; 2276 :    {
; 2277 :       LPTASK lpTask = zGETPTR( hCurrentTask );

	mov	eax, DWORD PTR _hCurrentTask$[ebp]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$1[ebp], eax

; 2278 :       if ( lpTask && lpTask->bTransientTask &&

	cmp	DWORD PTR _lpTask$1[ebp], 0
	je	$LN54@GetViewByN
	mov	ecx, DWORD PTR _lpTask$1[ebp]
	mov	edx, DWORD PTR [ecx+443]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	$LN54@GetViewByN
	mov	eax, DWORD PTR _cpcName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG14125
	cmp	ecx, edx
	jne	SHORT $LN75@GetViewByN
	push	OFFSET $SG14126
	mov	eax, DWORD PTR _cpcName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv380[ebp], eax
	jmp	SHORT $LN76@GetViewByN
$LN75@GetViewByN:
	mov	ecx, DWORD PTR _cpcName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14127
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN73@GetViewByN
	mov	DWORD PTR tv379[ebp], 1
	jmp	SHORT $LN74@GetViewByN
$LN73@GetViewByN:
	mov	DWORD PTR tv379[ebp], -1
$LN74@GetViewByN:
	mov	ecx, DWORD PTR tv379[ebp]
	mov	DWORD PTR tv380[ebp], ecx
$LN76@GetViewByN:
	cmp	DWORD PTR tv380[ebp], 0
	je	$LN54@GetViewByN

; 2279 :            zstrcmp( cpcName, "Zeidon DBHandler Work Object" ) != 0 )
; 2280 :       {
; 2281 :          TraceLine( "GetViewByName TRANSIENT ERROR (0x%08x/0x%08x)  %s   View/Task: 0x%08x/0x%08x   Level: %s   RC ===> %s",

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jg	SHORT $LN85@GetViewByN
	mov	DWORD PTR tv400[ebp], OFFSET $SG14128
	jmp	SHORT $LN86@GetViewByN
$LN85@GetViewByN:
	movsx	eax, WORD PTR _nRC$[ebp]
	and	eax, 1
	je	SHORT $LN83@GetViewByN
	mov	DWORD PTR tv399[ebp], OFFSET $SG14129
	jmp	SHORT $LN84@GetViewByN
$LN83@GetViewByN:
	movsx	ecx, WORD PTR _nRC$[ebp]
	and	ecx, 2
	je	SHORT $LN81@GetViewByN
	mov	DWORD PTR tv397[ebp], OFFSET $SG14130
	jmp	SHORT $LN82@GetViewByN
$LN81@GetViewByN:
	movsx	edx, WORD PTR _nRC$[ebp]
	and	edx, 4
	je	SHORT $LN79@GetViewByN
	mov	DWORD PTR tv395[ebp], OFFSET $SG14131
	jmp	SHORT $LN80@GetViewByN
$LN79@GetViewByN:
	movsx	eax, WORD PTR _nRC$[ebp]
	and	eax, 8
	je	SHORT $LN77@GetViewByN
	mov	DWORD PTR tv393[ebp], OFFSET $SG14132
	jmp	SHORT $LN78@GetViewByN
$LN77@GetViewByN:
	mov	DWORD PTR tv393[ebp], OFFSET $SG14133
$LN78@GetViewByN:
	mov	ecx, DWORD PTR tv393[ebp]
	mov	DWORD PTR tv395[ebp], ecx
$LN80@GetViewByN:
	mov	edx, DWORD PTR tv395[ebp]
	mov	DWORD PTR tv397[ebp], edx
$LN82@GetViewByN:
	mov	eax, DWORD PTR tv397[ebp]
	mov	DWORD PTR tv399[ebp], eax
$LN84@GetViewByN:
	mov	ecx, DWORD PTR tv399[ebp]
	mov	DWORD PTR tv400[ebp], ecx
$LN86@GetViewByN:
	movsx	edx, WORD PTR _nLevel$[ebp]
	and	edx, 15					; 0000000fH
	cmp	edx, 15					; 0000000fH
	jne	SHORT $LN95@GetViewByN
	mov	DWORD PTR tv453[ebp], OFFSET $SG14134
	jmp	SHORT $LN96@GetViewByN
$LN95@GetViewByN:
	movsx	eax, WORD PTR _nLevel$[ebp]
	and	eax, 1
	je	SHORT $LN93@GetViewByN
	mov	DWORD PTR tv452[ebp], OFFSET $SG14135
	jmp	SHORT $LN94@GetViewByN
$LN93@GetViewByN:
	movsx	ecx, WORD PTR _nLevel$[ebp]
	and	ecx, 2
	je	SHORT $LN91@GetViewByN
	mov	DWORD PTR tv450[ebp], OFFSET $SG14136
	jmp	SHORT $LN92@GetViewByN
$LN91@GetViewByN:
	movsx	edx, WORD PTR _nLevel$[ebp]
	and	edx, 4
	je	SHORT $LN89@GetViewByN
	mov	DWORD PTR tv448[ebp], OFFSET $SG14137
	jmp	SHORT $LN90@GetViewByN
$LN89@GetViewByN:
	movsx	eax, WORD PTR _nLevel$[ebp]
	and	eax, 8
	je	SHORT $LN87@GetViewByN
	mov	DWORD PTR tv414[ebp], OFFSET $SG14138
	jmp	SHORT $LN88@GetViewByN
$LN87@GetViewByN:
	mov	DWORD PTR tv414[ebp], OFFSET $SG14139
$LN88@GetViewByN:
	mov	ecx, DWORD PTR tv414[ebp]
	mov	DWORD PTR tv448[ebp], ecx
$LN90@GetViewByN:
	mov	edx, DWORD PTR tv448[ebp]
	mov	DWORD PTR tv450[ebp], edx
$LN92@GetViewByN:
	mov	eax, DWORD PTR tv450[ebp]
	mov	DWORD PTR tv452[ebp], eax
$LN94@GetViewByN:
	mov	ecx, DWORD PTR tv452[ebp]
	mov	DWORD PTR tv453[ebp], ecx
$LN96@GetViewByN:
	mov	edx, DWORD PTR tv400[ebp]
	push	edx
	mov	eax, DWORD PTR tv453[ebp]
	push	eax
	mov	ecx, DWORD PTR _hCurrentTask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	OFFSET $SG14140
	call	_TraceLine
	add	esp, 32					; 00000020H
$LN54@GetViewByN:

; 2282 :                     *pvReturnView, (*pvReturnView)->hTask, cpcName, vSubtask, hCurrentTask,
; 2283 :                     (nLevel & 0x000F) == 0x000F ? "ANY" :
; 2284 :                       nLevel & 1 ? "SUBTASK" : nLevel & 2 ? "TASK" : nLevel & 4 ?
; 2285 :                       "APPLICATION" : nLevel & 8 ? "SYSTEM" : "UNKNOWN",
; 2286 :                     nRC <= 0 ? "NOT FOUND" :
; 2287 :                       nRC & 1 ? "SUBTASK" : nRC & 2 ? "TASK" : nRC & 4 ?
; 2288 :                       "APPLICATION" : nRC & 8 ? "SYSTEM" : "UNKNOWN" );
; 2289 :       // if ( *pvReturnView )
; 2290 :       //    DisplayObjectInstance( *pvReturnView, 0, 0 );
; 2291 :       }
; 2292 :    }
; 2293 : #endif
; 2294 : 
; 2295 :    fnOperationReturn( iGetViewByName, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	206					; 000000ceH
	call	_fnOperationReturn
	add	esp, 8

; 2296 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@GetViewByN:

; 2297 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_GetViewByName@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_GetDefaultViewForActiveTask@0 PROC

; 1588 : {

	push	ebp
	mov	ebp, esp

; 1589 :    return( g_vDefaultTaskView );

	mov	eax, DWORD PTR _g_vDefaultTaskView

; 1590 : }

	pop	ebp
	ret	0
_GetDefaultViewForActiveTask@0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_vPrev$ = -16						; size = 4
$T1 = -12						; size = 4
_lpTask$2 = -8						; size = 4
_szTrace$ = -4						; size = 2
_vDefault$ = 8						; size = 4
_lFlag$ = 12						; size = 4
_SetDefaultViewForActiveTask@8 PROC

; 1542 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1543 :    zVIEW vPrev = g_vDefaultTaskView;

	mov	eax, DWORD PTR _g_vDefaultTaskView
	mov	DWORD PTR _vPrev$[ebp], eax

; 1544 :    zCHAR szTrace[ 2 ];
; 1545 : 
; 1546 :    if ( lFlag & 0x00000004 )

	mov	ecx, DWORD PTR _lFlag$[ebp]
	and	ecx, 4
	je	SHORT $LN2@SetDefault

; 1547 :    {
; 1548 :       vPrev = g_vRealTaskView;

	mov	edx, DWORD PTR _g_vRealTaskView
	mov	DWORD PTR _vPrev$[ebp], edx

; 1549 :       g_vRealTaskView = vDefault;

	mov	eax, DWORD PTR _vDefault$[ebp]
	mov	DWORD PTR _g_vRealTaskView, eax
$LN2@SetDefault:

; 1550 :    }
; 1551 : 
; 1552 :    if ( lFlag & 0x00000001 )

	mov	ecx, DWORD PTR _lFlag$[ebp]
	and	ecx, 1
	je	SHORT $LN3@SetDefault

; 1553 :    {
; 1554 :       g_vDefaultTaskView = vDefault;

	mov	edx, DWORD PTR _vDefault$[ebp]
	mov	DWORD PTR _g_vDefaultTaskView, edx

; 1555 :       g_lProcessID = SysGetProcessID( 0 );

	push	0
	call	_SysGetProcessID@4
	mov	DWORD PTR _g_lProcessID, eax
$LN3@SetDefault:

; 1556 : 
; 1557 :    }
; 1558 : 
; 1559 :    if ( lFlag & 0x00000002 )

	mov	eax, DWORD PTR _lFlag$[ebp]
	and	eax, 2
	je	SHORT $LN4@SetDefault

; 1560 :    {
; 1561 :       LPTASK lpTask = 0;

	mov	DWORD PTR _lpTask$2[ebp], 0

; 1562 : 
; 1563 :       if ( vDefault )

	cmp	DWORD PTR _vDefault$[ebp], 0
	je	SHORT $LN5@SetDefault

; 1564 :          lpTask  = zGETPTR( vDefault->hTask );

	mov	ecx, DWORD PTR _vDefault$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax
	jmp	SHORT $LN6@SetDefault
$LN5@SetDefault:

; 1565 :       else
; 1566 :       if ( g_vDefaultTaskView )

	cmp	DWORD PTR _g_vDefaultTaskView, 0
	je	SHORT $LN6@SetDefault

; 1567 :          lpTask = zGETPTR( g_vDefaultTaskView->hTask );

	mov	eax, DWORD PTR _g_vDefaultTaskView
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$2[ebp], eax
$LN6@SetDefault:

; 1568 : 
; 1569 :       if ( lpTask )

	cmp	DWORD PTR _lpTask$2[ebp], 0
	je	SHORT $LN4@SetDefault

; 1570 :          lpTask->vWebSubtask = vDefault;

	mov	edx, DWORD PTR _lpTask$2[ebp]
	mov	eax, DWORD PTR _vDefault$[ebp]
	mov	DWORD PTR [edx+28], eax
$LN4@SetDefault:

; 1571 :    }
; 1572 : 
; 1573 :    szTrace[ 0 ] = (zCHAR) SysSendOE_Message( IDM_GETOEWARNINGTRACE, 0 );

	push	0
	push	215					; 000000d7H
	call	_SysSendOE_Message@8
	mov	ecx, 1
	imul	edx, ecx, 0
	mov	BYTE PTR _szTrace$[ebp+edx], al

; 1574 :    szTrace[ 1 ] = 0;

	mov	DWORD PTR $T1[ebp], 1
	cmp	DWORD PTR $T1[ebp], 2
	jae	SHORT $LN16@SetDefault
	jmp	SHORT $LN17@SetDefault
$LN16@SetDefault:
	call	___report_rangecheckfailure
$LN17@SetDefault:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szTrace$[ebp+eax], 0

; 1575 :    if ( szTrace[ 0 ] == 'n' || szTrace[ 0 ] == 'N' )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szTrace$[ebp+edx]
	cmp	eax, 110				; 0000006eH
	je	SHORT $LN11@SetDefault
	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szTrace$[ebp+edx]
	cmp	eax, 78					; 0000004eH
	jne	SHORT $LN9@SetDefault
$LN11@SetDefault:

; 1576 :       g_nOE_TraceWarning = 0;

	xor	ecx, ecx
	mov	WORD PTR _g_nOE_TraceWarning, cx
	jmp	SHORT $LN10@SetDefault
$LN9@SetDefault:

; 1577 :    else
; 1578 :    if ( szTrace[ 0 ] == 'y' || szTrace[ 0 ] == 'Y' )

	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szTrace$[ebp+eax]
	cmp	ecx, 121				; 00000079H
	je	SHORT $LN14@SetDefault
	mov	edx, 1
	imul	eax, edx, 0
	movsx	ecx, BYTE PTR _szTrace$[ebp+eax]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN12@SetDefault
$LN14@SetDefault:

; 1579 :       g_nOE_TraceWarning = 99;

	mov	edx, 99					; 00000063H
	mov	WORD PTR _g_nOE_TraceWarning, dx
	jmp	SHORT $LN10@SetDefault
$LN12@SetDefault:

; 1580 :    else
; 1581 :       g_nOE_TraceWarning = (zSHORT) zatol( szTrace );

	lea	eax, DWORD PTR _szTrace$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _g_nOE_TraceWarning, ax
$LN10@SetDefault:

; 1582 : 
; 1583 :    return( vPrev );

	mov	eax, DWORD PTR _vPrev$[ebp]
$LN15@SetDefault:

; 1584 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SetDefaultViewForActiveTask@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_vTgt$ = 8						; size = 4
_vSrc$ = 12						; size = 4
_SetViewFromView@8 PROC

; 575  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 576  :    LPTASK      lpCurrentTask;
; 577  :    zSHORT      nRC;
; 578  : 
; 579  :    // If task not active or disabled, or view csr invalid, return zCALL_ERROR.
; 580  :    if ( (lpCurrentTask = fnOperationCall( iSetViewFromView, vSrc,
; 581  :                                           zVALID_VIEW_CSR )) == 0 )

	push	13					; 0000000dH
	mov	eax, DWORD PTR _vSrc$[ebp]
	push	eax
	push	201					; 000000c9H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SetViewFro

; 582  :    {
; 583  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetViewFro
$LN2@SetViewFro:

; 584  :    }
; 585  : 
; 586  :    if ( fnValidView( lpCurrentTask, vTgt ) == 0 )

	mov	ecx, DWORD PTR _vTgt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnValidView
	add	esp, 8
	cwde
	test	eax, eax
	jne	SHORT $LN3@SetViewFro

; 587  :    {
; 588  :       fnOperationReturn( iSetViewFromView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	201					; 000000c9H
	call	_fnOperationReturn
	add	esp, 8

; 589  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetViewFro
$LN3@SetViewFro:

; 590  :    }
; 591  : 
; 592  :    // Call fnSetViewFromView.
; 593  :    nRC = fnSetViewFromView( vTgt, vSrc );

	mov	edx, DWORD PTR _vSrc$[ebp]
	push	edx
	mov	eax, DWORD PTR _vTgt$[ebp]
	push	eax
	call	_fnSetViewFromView
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 594  : 
; 595  :    // Success, return the good news.
; 596  :    fnOperationReturn( iSetViewFromView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	201					; 000000c9H
	call	_fnOperationReturn
	add	esp, 8

; 597  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SetViewFro:

; 598  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SetViewFromView@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pvReturnView$ = 8					; size = 4
_vSrc$ = 12						; size = 4
_SfCreateSysViewFromView@8 PROC

; 419  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 420  :    LPTASK      lpCurrentTask;
; 421  :    zSHORT      nRC;
; 422  : 
; 423  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 424  :    if ( (lpCurrentTask = fnOperationCall( iSfCreateSysViewFromView, vSrc,
; 425  :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _vSrc$[ebp]
	push	eax
	push	220					; 000000dcH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SfCreateSy

; 426  :    {
; 427  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@SfCreateSy
$LN2@SfCreateSy:

; 428  :    }
; 429  : 
; 430  :    // Declare the new view as a system view.
; 431  :    if ( (nRC = fnDeclareView( pvReturnView, lpCurrentTask,
; 432  :                               vSrc, 0, 1 )) != 0 )

	push	1
	push	0
	mov	ecx, DWORD PTR _vSrc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@SfCreateSy

; 433  :    {
; 434  :       fnOperationReturn( iSfCreateSysViewFromView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	220					; 000000dcH
	call	_fnOperationReturn
	add	esp, 8

; 435  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN1@SfCreateSy
$LN3@SfCreateSy:

; 436  :    }
; 437  : 
; 438  :    if ( vSrc->bApplicationView &&

	mov	eax, DWORD PTR _vSrc$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN4@SfCreateSy
	push	4
	mov	edx, DWORD PTR _vSrc$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SfTransferView@12
	mov	WORD PTR _nRC$[ebp], ax
	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	je	SHORT $LN4@SfCreateSy

; 439  :         (nRC = SfTransferView( *pvReturnView, vSrc, zLEVEL_APPLICATION )) != 0 )
; 440  :    {
; 441  :       fnOperationReturn( iSfCreateSysViewFromView, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	220					; 000000dcH
	call	_fnOperationReturn
	add	esp, 8

; 442  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@SfCreateSy
$LN4@SfCreateSy:

; 443  :    }
; 444  : 
; 445  :    if ( nRC == 0 )

	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	jne	SHORT $LN5@SfCreateSy

; 446  :    {
; 447  :       nRC = fnSetViewFromView( *pvReturnView, vSrc );

	mov	edx, DWORD PTR _vSrc$[ebp]
	push	edx
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fnSetViewFromView
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 448  :       TraceLine( "SfCreateSysViewFromView: 0x%08x", *pvReturnView );

	mov	edx, DWORD PTR _pvReturnView$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET $SG13448
	call	_TraceLine
	add	esp, 8
$LN5@SfCreateSy:

; 449  :    }
; 450  : 
; 451  :    fnOperationReturn( iSfCreateSysViewFromView, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	220					; 000000dcH
	call	_fnOperationReturn
	add	esp, 8

; 452  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@SfCreateSy:

; 453  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SfCreateSysViewFromView@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpViewOD$ = -8						; size = 4
_nRC$ = -4						; size = 2
_cpcMsg$ = 8						; size = 4
_pvReturnView$ = 12					; size = 4
_vSrc$ = 16						; size = 4
_vTask$ = 20						; size = 4
_CreateViewTrace@16 PROC

; 267  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 268  :    LPVIEWOD lpViewOD = zGETPTR( vSrc->hViewOD );

	mov	eax, DWORD PTR _vSrc$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 269  :    zSHORT   nRC;
; 270  : 
; 271  :    nRC = CreateViewFromViewForTask( pvReturnView, vSrc, vTask );

	mov	edx, DWORD PTR _vTask$[ebp]
	push	edx
	mov	eax, DWORD PTR _vSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12
	mov	WORD PTR _nRC$[ebp], ax

; 272  :    TraceLine( "CreateView %s: 0x%08x   LOD: %s", cpcMsg, *pvReturnView, lpViewOD->szName );

	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _cpcMsg$[ebp]
	push	edx
	push	OFFSET $SG13412
	call	_TraceLine
	add	esp, 16					; 00000010H

; 273  :    SetViewFlags( *pvReturnView, zVF_TRACEONDROP );

	push	2
	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SetViewFlags@8

; 274  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]

; 275  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_CreateViewTrace@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpTask$ = -16						; size = 4
_vTemp$ = -12						; size = 4
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_pvReturnView$ = 8					; size = 4
_vSrc$ = 12						; size = 4
_vTask$ = 16						; size = 4
_CreateViewFromViewForTask@12 PROC

; 303  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 304  :    LPTASK      lpCurrentTask;
; 305  :    LPTASK      lpTask;
; 306  :    zVIEW       vTemp;
; 307  :    zSHORT      nRC;
; 308  : 
; 309  : #ifdef DEBUG_VIEW
; 310  :    zLONG  k;
; 311  : 
; 312  :    if ( pvReturnView == 0 || g_lHighWaterView == -1 )
; 313  :    {
; 314  :       TraceLineS( "CreateViewFromView Initializing View Usage ===============================> ", "" );
; 315  :       DropView( 0 );
; 316  :       for ( k = 0; k < zMAX_VIEW_TEST; k++ )
; 317  :          g_pvView[ k ] = 0;
; 318  : 
; 319  :       g_lHighWaterView = 0;
; 320  :       if ( pvReturnView == 0 )
; 321  :          return( 0 );
; 322  :    }
; 323  : 
; 324  :    for ( k = 0; k < zMAX_VIEW_TEST; k++ )
; 325  :    {
; 326  :       if ( g_pvView[ k ] == 0 )
; 327  :          break;
; 328  :    }
; 329  : 
; 330  : #endif
; 331  : 
; 332  :    *pvReturnView = 0;  // init in case of error

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	DWORD PTR [eax], 0

; 333  : 
; 334  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 335  :    if ( (lpCurrentTask = fnOperationCall( iCreateViewFromView,
; 336  :                                           vSrc, zVALID_VIEW )) == 0 )

	push	1
	mov	ecx, DWORD PTR _vSrc$[ebp]
	push	ecx
	push	200					; 000000c8H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@CreateView

; 337  :    {
; 338  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CreateView
$LN2@CreateView:

; 339  :    }
; 340  : 
; 341  :    lpTask = lpCurrentTask;

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	mov	DWORD PTR _lpTask$[ebp], edx

; 342  : 
; 343  :    if ( vSrc->bApplicationView )  // dks 2005.11.29

	mov	eax, DWORD PTR _vSrc$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN3@CreateView

; 344  :       ;  // nothing to do

	jmp	SHORT $LN4@CreateView
$LN3@CreateView:

; 345  :    else
; 346  :    if ( vTask )

	cmp	DWORD PTR _vTask$[ebp], 0
	je	SHORT $LN4@CreateView

; 347  :       lpTask = zGETPTR( vTask->hTask );

	mov	edx, DWORD PTR _vTask$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpTask$[ebp], eax
$LN4@CreateView:

; 348  : 
; 349  :    if ( (nRC = fnDeclareView( &vTemp, lpTask, vSrc, 0, 0 )) != 0 )

	push	0
	push	0
	mov	ecx, DWORD PTR _vSrc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTask$[ebp]
	push	edx
	lea	eax, DWORD PTR _vTemp$[ebp]
	push	eax
	call	_fnDeclareView@20
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN6@CreateView

; 350  :    {
; 351  :       fnOperationReturn( iCreateViewFromView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	200					; 000000c8H
	call	_fnOperationReturn
	add	esp, 8

; 352  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@CreateView
$LN6@CreateView:

; 353  :    }
; 354  : 
; 355  :    if ( vSrc->bApplicationView &&

	mov	eax, DWORD PTR _vSrc$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	shr	ecx, 3
	and	ecx, 1
	je	SHORT $LN7@CreateView
	push	4
	mov	edx, DWORD PTR _vSrc$[ebp]
	push	edx
	mov	eax, DWORD PTR _vTemp$[ebp]
	push	eax
	call	_SfTransferView@12
	mov	WORD PTR _nRC$[ebp], ax
	movsx	ecx, WORD PTR _nRC$[ebp]
	test	ecx, ecx
	je	SHORT $LN7@CreateView

; 356  :         (nRC = SfTransferView( vTemp, vSrc, zLEVEL_APPLICATION )) != 0 )
; 357  :    {
; 358  :       fnOperationReturn( iCreateViewFromView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	200					; 000000c8H
	call	_fnOperationReturn
	add	esp, 8

; 359  :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	SHORT $LN1@CreateView
$LN7@CreateView:

; 360  :    }
; 361  : 
; 362  :    if ( nRC == 0 )

	movsx	eax, WORD PTR _nRC$[ebp]
	test	eax, eax
	jne	SHORT $LN8@CreateView

; 363  :    {
; 364  : #ifdef DEBUG_VIEW
; 365  : 
; 366  :       LPVIEWOD lpViewOD = zGETPTR( vTemp->hViewOD );
; 367  : 
; 368  :       if ( zstrcmpi( lpViewOD->szName, "TZ__PRFO" ) == 0 )
; 369  :       {
; 370  :          TraceLine( "CreateViewFromView: 0x%08x   LOD: %s",
; 371  :                     vTemp, lpViewOD->szName );
; 372  :          if ( k >= zMAX_VIEW_TEST )
; 373  :             TraceLineS( "CreateView Error: ", "Memory Test Error" );
; 374  :          else
; 375  :          {
; 376  :             if ( g_lHighWaterView < k )
; 377  :                g_lHighWaterView = k;
; 378  : 
; 379  :             g_pvView[ k ] = (zPVOID) *pvReturnView;
; 380  :          }
; 381  :       }
; 382  : #endif
; 383  : 
; 384  :       nRC = fnSetViewFromView( vTemp, vSrc );

	mov	ecx, DWORD PTR _vSrc$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vTemp$[ebp]
	push	edx
	call	_fnSetViewFromView
	add	esp, 8
	mov	WORD PTR _nRC$[ebp], ax

; 385  :       *pvReturnView = vTemp;

	mov	eax, DWORD PTR _pvReturnView$[ebp]
	mov	ecx, DWORD PTR _vTemp$[ebp]
	mov	DWORD PTR [eax], ecx
$LN8@CreateView:

; 386  :    }
; 387  : 
; 388  : // {
; 389  : //    LPVIEWOD lpViewOD = zGETPTR( (*pvReturnView)->hViewOD );
; 390  : //    if ( zstrcmp( lpViewOD->szName, "TZRPSRCO" ) == 0 )
; 391  : //    {
; 392  : //       TraceLine( "CreateView: 0x%08x   LOD: %s", *pvReturnView, lpViewOD->szName );
; 393  : //    }
; 394  : // }
; 395  : 
; 396  :    fnOperationReturn( iCreateViewFromView, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	200					; 000000c8H
	call	_fnOperationReturn
	add	esp, 8

; 397  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CreateView:

; 398  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_CreateViewFromViewForTask@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_pvReturnView$ = 8					; size = 4
_vSrc$ = 12						; size = 4
_CreateViewFromView@8 PROC

; 280  : {

	push	ebp
	mov	ebp, esp

; 281  :    return( CreateViewFromViewForTask( pvReturnView, vSrc, 0 ) );

	push	0
	mov	eax, DWORD PTR _vSrc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvReturnView$[ebp]
	push	ecx
	call	_CreateViewFromViewForTask@12

; 282  : }

	pop	ebp
	ret	8
_CreateViewFromView@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_SetViewUpdate@4 PROC

; 157  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 158  :    LPTASK   lpCurrentTask;
; 159  : 
; 160  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 161  :    if ( (lpCurrentTask = fnOperationCall( iSetViewReadOnly, lpView,
; 162  :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	217					; 000000d9H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SetViewUpd

; 163  :    {
; 164  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetViewUpd
$LN2@SetViewUpd:

; 165  :    }
; 166  : 
; 167  :    // If we're here, success
; 168  :    lpView->bReadOnly = 0;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	and	edx, -65				; ffffffbfH
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+30], edx

; 169  : 
; 170  :    fnOperationReturn( iSetViewReadOnly, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	217					; 000000d9H
	call	_fnOperationReturn
	add	esp, 8

; 171  :    return( 0 );

	xor	eax, eax
$LN1@SetViewUpd:

; 172  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SetViewUpdate@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lReturn$ = -8						; size = 4
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_GetViewFlags@4 PROC

; 237  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 238  :    LPTASK      lpCurrentTask;
; 239  :    zLONG       lReturn;
; 240  : 
; 241  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 242  :    if ( (lpCurrentTask = fnOperationCall( iGetViewFlags, lpView,
; 243  :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	224					; 000000e0H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@GetViewFla

; 244  :    {
; 245  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@GetViewFla
$LN2@GetViewFla:

; 246  :    }
; 247  : 
; 248  :    if ( lpView->bFlagDropView )

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN3@GetViewFla

; 249  :       lReturn |= zVF_MESSAGEONDROP;

	mov	eax, DWORD PTR _lReturn$[ebp]
	or	eax, 1
	mov	DWORD PTR _lReturn$[ebp], eax
$LN3@GetViewFla:

; 250  : 
; 251  :    fnOperationReturn( iGetViewFlags, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	224					; 000000e0H
	call	_fnOperationReturn
	add	esp, 8

; 252  :    return( 0 );

	xor	eax, eax
$LN1@GetViewFla:

; 253  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_GetViewFlags@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_lControl$ = 12						; size = 4
_SetViewFlags@8 PROC

; 195  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 196  :    LPTASK   lpCurrentTask;
; 197  : 
; 198  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 199  :    if ( (lpCurrentTask = fnOperationCall( iSetViewFlags, lpView,
; 200  :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	222					; 000000deH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SetViewFla

; 201  :    {
; 202  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetViewFla
$LN2@SetViewFla:

; 203  :    }
; 204  : 
; 205  :    if ( lControl & zVF_MESSAGEONDROP )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1
	je	SHORT $LN3@SetViewFla

; 206  :       lpView->bFlagDropView = TRUE;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	or	eax, 1024				; 00000400H
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax
	jmp	SHORT $LN4@SetViewFla
$LN3@SetViewFla:

; 207  :    else
; 208  :       lpView->bFlagDropView = FALSE;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+30]
	and	eax, -1025				; fffffbffH
	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [ecx+30], eax
$LN4@SetViewFla:

; 209  : 
; 210  :    if ( lControl & zVF_TRACEONDROP )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2
	je	SHORT $LN5@SetViewFla

; 211  :       lpView->bTraceDropView = TRUE;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	or	ecx, 512				; 00000200H
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+30], ecx
	jmp	SHORT $LN6@SetViewFla
$LN5@SetViewFla:

; 212  :    else
; 213  :       lpView->bTraceDropView = FALSE;

	mov	eax, DWORD PTR _lpView$[ebp]
	mov	ecx, DWORD PTR [eax+30]
	and	ecx, -513				; fffffdffH
	mov	edx, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [edx+30], ecx
$LN6@SetViewFla:

; 214  : 
; 215  :    fnOperationReturn( iSetViewFlags, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	222					; 000000deH
	call	_fnOperationReturn
	add	esp, 8

; 216  :    return( 0 );

	xor	eax, eax
$LN1@SetViewFla:

; 217  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_SetViewFlags@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoevmaa.c
_TEXT	SEGMENT
_lpCurrentTask$ = -4					; size = 4
_lpView$ = 8						; size = 4
_SetViewReadOnly@4 PROC

; 125  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 126  :    LPTASK   lpCurrentTask;
; 127  : 
; 128  :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 129  :    if ( (lpCurrentTask = fnOperationCall( iSetViewReadOnly, lpView,
; 130  :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	push	217					; 000000d9H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@SetViewRea

; 131  :    {
; 132  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@SetViewRea
$LN2@SetViewRea:

; 133  :    }
; 134  : 
; 135  :    // If we're here, success.
; 136  :    lpView->bReadOnly = TRUE;

	mov	ecx, DWORD PTR _lpView$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	or	edx, 64					; 00000040H
	mov	eax, DWORD PTR _lpView$[ebp]
	mov	DWORD PTR [eax+30], edx

; 137  : 
; 138  :    fnOperationReturn( iSetViewReadOnly, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	217					; 000000d9H
	call	_fnOperationReturn
	add	esp, 8

; 139  :    return( 0 );

	xor	eax, eax
$LN1@SetViewRea:

; 140  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_SetViewReadOnly@4 ENDP
_TEXT	ENDS
END
