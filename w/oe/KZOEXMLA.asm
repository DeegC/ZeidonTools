; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\KZOEXMLA.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG14452 DB	01H DUP (?)
$SG14527 DB	01H DUP (?)
$SG14587 DB	01H DUP (?)
$SG13850 DB	01H DUP (?)
$SG13858 DB	01H DUP (?)
$SG14032 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG14402 DB	'<?xml version="1.0" encoding="iso-8859-1"?>', 00H
$SG14407 DB	'<zOI zObjectName="%s" zAppName="%s" zIncreFlags="Y">', 00H
	ORG $+3
$SG14408 DB	'<zOI zObjectName="%s" zAppName="%s">', 00H
	ORG $+3
$SG14412 DB	'</zOI>', 00H
	ORG $+1
$SG14450 DB	'(xml) Element = ', 00H
	ORG $+3
$SG14451 DB	'(xml) Attrib %s = %s', 00H
	ORG $+3
$SG14463 DB	'zAppName', 00H
	ORG $+3
$SG14466 DB	'zObjectName', 00H
$SG14469 DB	'zIncreFlags', 00H
$SG14526 DB	'(xml) Parent mismatch (%s != %s) for entity: %s', 00H
$SG14528 DB	'XML Parser', 00H
	ORG $+1
$SG14533 DB	'zEKey', 00H
	ORG $+2
$SG14586 DB	'(xml) Could not find Entity.Attribute: %s.%s', 00H
	ORG $+3
$SG14588 DB	'XML Parser', 00H
	ORG $+1
$SG14589 DB	'zIncreFlags', 00H
$SG14662 DB	'zOI', 00H
$SG14663 DB	'zOI', 00H
$SG14664 DB	'zOI', 00H
$SG14667 DB	'zLevel', 00H
	ORG $+1
$SG14670 DB	'Located zLevel parsing XML', 00H
	ORG $+1
$SG14671 DB	'Error', 00H
	ORG $+2
$SG14672 DB	'zEName', 00H
	ORG $+1
$SG14686 DB	'(xml) Could not find Entity.SimpleAttribute: %s.%s', 00H
	ORG $+1
$SG14690 DB	'(xml) ERROR - Attribute without an entity.  Tag = ', 00H
	ORG $+1
$SG14714 DB	'Depth Error parsing XML', 00H
$SG14715 DB	'Error', 00H
	ORG $+2
$SG13747 DB	'KEY WAS BLOB - NOT SUPPORTED', 00H
	ORG $+3
$SG13770 DB	' %s="%s"', 00H
	ORG $+3
$SG14795 DB	'More than one zLEVEL_ option requested', 00H
	ORG $+1
$SG14800 DB	'with zLEVEL_SAME', 00H
	ORG $+3
$SG14801 DB	'vSubtask', 00H
	ORG $+3
$SG14810 DB	'%s at line %d', 00H
	ORG $+2
$SG14811 DB	'(xml) Error txt: ', 00H
	ORG $+2
$SG14812 DB	'Error parsing XML', 00H
	ORG $+2
$SG14813 DB	'Error', 00H
	ORG $+2
$SG13829 DB	'<%s', 00H
$SG13830 DB	'<%s', 00H
$SG13836 DB	'..', 00H
	ORG $+1
$SG13840 DB	'..', 00H
	ORG $+1
$SG13841 DB	'..', 00H
	ORG $+1
$SG13842 DB	'..', 00H
	ORG $+1
$SG13843 DB	' zIncreFlags="%s"', 00H
	ORG $+2
$SG13844 DB	'>', 00H
	ORG $+2
$SG13851 DB	'<![CDATA[', 00H
	ORG $+2
$SG14879 DB	' ', 00H
	ORG $+2
$SG14880 DB	'%*s ', 00H
	ORG $+3
$SG14900 DB	'Invalid view for CommitOI_ToXML_File: ', 00H
	ORG $+1
$SG13878 DB	' %s=', 00H
	ORG $+3
$SG13880 DB	' %s="%s"', 00H
	ORG $+3
$SG13885 DB	']]></%s>', 00H
	ORG $+3
$SG13888 DB	'</%s>', 00H
	ORG $+2
$SG13889 DB	'</%s>', 00H
	ORG $+2
$SG13959 DB	'<%s', 00H
$SG13962 DB	' zLevel="%ld"', 00H
	ORG $+2
$SG13964 DB	' zEName="%s"', 00H
	ORG $+3
$SG13966 DB	'........', 00H
	ORG $+3
$SG13976 DB	'........', 00H
	ORG $+3
$SG13977 DB	'........', 00H
	ORG $+3
$SG13978 DB	'........', 00H
	ORG $+3
$SG13979 DB	' zIncreFlags="%s"', 00H
	ORG $+2
$SG13981 DB	' zEKey="%lx"', 00H
	ORG $+3
$SG13987 DB	' zCursor="Y"', 00H
	ORG $+3
$SG13990 DB	' zSelect%d="Y"', 00H
	ORG $+1
$SG13991 DB	'>', 00H
	ORG $+2
$SG14028 DB	'<%s>', 00H
	ORG $+3
$SG14048 DB	'</%s>', 00H
	ORG $+2
$SG14071 DB	'<ListEntryValue Name="%s">', 00H
	ORG $+1
$SG14073 DB	'CurrentValue', 00H
	ORG $+3
$SG14075 DB	'</ListEntryValue>', 00H
	ORG $+2
$SG14158 DB	'<Control Name="%s" Type="%s">', 00H
	ORG $+2
$SG14166 DB	'ListEntry', 00H
	ORG $+2
$SG14167 DB	'ListEntry', 00H
	ORG $+2
$SG14168 DB	'ListEntry', 00H
	ORG $+2
$SG14173 DB	'<ListEntry>', 00H
$SG14174 DB	'<ListEntry zSelect1="Y">', 00H
	ORG $+3
$SG14179 DB	'</ListEntry>', 00H
	ORG $+3
$SG14183 DB	'ComboValue', 00H
	ORG $+1
$SG14184 DB	'ComboValue', 00H
	ORG $+1
$SG14185 DB	'ComboValue', 00H
	ORG $+1
$SG14190 DB	'<ComboValue>', 00H
	ORG $+3
$SG14191 DB	'<ComboValue zSelect1="Y">', 00H
	ORG $+2
$SG14193 DB	'</ComboValue>', 00H
	ORG $+2
$SG14195 DB	'CurrentValue', 00H
	ORG $+3
$SG14197 DB	'</Control>', 00H
	ORG $+1
$SG14242 DB	'Control', 00H
$SG14243 DB	'Control', 00H
$SG14244 DB	'Control', 00H
$SG14247 DB	'ListEntryValue', 00H
	ORG $+1
$SG14248 DB	'ListEntryValue', 00H
	ORG $+1
$SG14249 DB	'ListEntryValue', 00H
	ORG $+1
$SG14256 DB	'</%s>', 00H
	ORG $+2
$SG14316 DB	'<?xml version="1.0" encoding="iso-8859-1"?>', 00H
$SG14322 DB	'<zOI zObjectName="%s" zAppName="%s" zIncreFlags="Y">', 00H
	ORG $+3
$SG14323 DB	'<zOI zObjectName="%s" zAppName="%s">', 00H
	ORG $+3
$SG14327 DB	'<zOI>', 00H
	ORG $+2
$SG14331 DB	'</zOI>', 00H
_DATA	ENDS
PUBLIC	_ActivateOI_FromXML_File@20
PUBLIC	_CommitOI_ToXML_File@12
PUBLIC	_CommitSubobjectToXML_File@16
PUBLIC	_WriteSubobjectToXML@20
PUBLIC	_WriteOI_ToXML@16
PUBLIC	_WriteMultipleOIs_ToXML@20
PUBLIC	_ActivateOI_FromXML@24
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_fnConvertEntity@12
PUBLIC	_fnContainsSpecialChar@4
PUBLIC	_fnAppendKeyAttribs@8
PUBLIC	_fnWriteAttribs@20
PUBLIC	_fnWriteEntityStartTag@12
PUBLIC	_fnWriteAttribEntry@24
PUBLIC	_fnWriteListEntryValue@16
PUBLIC	_fnWriteControlEntry@16
PUBLIC	_fnGetIdentifierValue@16
PUBLIC	_fnTraceAttributes@8
PUBLIC	_fnProcessOI_Element@8
PUBLIC	_fnProcessEntityElement@16
PUBLIC	_fnProcessAttribElement@12
PUBLIC	_startElement
PUBLIC	_endElement
PUBLIC	_GetElementData
PUBLIC	_unknownEncodingHandler
PUBLIC	_fnReadXMLData@16
PUBLIC	_fnWriteXML_ToFile@24
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	__imp__strchr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcmp:PROC
EXTRN	_strcpy:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__strtoul:PROC
EXTRN	__imp___ltoa:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceLine:PROC
EXTRN	_ActivateEmptyObjectInstance@16:PROC
EXTRN	_CreateViewFromViewForTask@12:PROC
EXTRN	_SysAllocMemory@20:PROC
EXTRN	_SysAppendcDirSep@4:PROC
EXTRN	_SysCloseFile@12:PROC
EXTRN	_SysFreeMemory@4:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysOpenFile@12:PROC
EXTRN	_SysReadFile@16:PROC
EXTRN	_SysWriteLine@12:PROC
EXTRN	_SysWriteLineLth@20:PROC
EXTRN	_StoreValueInRecord@20:PROC
EXTRN	_GetValueFromRecord@24:PROC
EXTRN	_StoreStringInRecord@16:PROC
EXTRN	_GetStringFromRecord@20:PROC
EXTRN	_GetAttributeFlags@16:PROC
EXTRN	_ActivateViewObject@12:PROC
EXTRN	_SfCreateSubtask@12:PROC
EXTRN	_SfDropSubtask@8:PROC
EXTRN	_SfGetApplicationForSubtask@8:PROC
EXTRN	_fnEstablishCursorForView:PROC
EXTRN	_fnEntityInstanceIsDead@4:PROC
EXTRN	_fnCreateEntity@20:PROC
EXTRN	_fnEstablishViewForInstance:PROC
EXTRN	_fnIssueCoreError:PROC
EXTRN	_fnGetApplicationForSubtask@8:PROC
EXTRN	_fnOperationCall:PROC
EXTRN	_fnOperationReturn:PROC
EXTRN	_fnValidView:PROC
EXTRN	_fnValidViewEntity@16:PROC
EXTRN	_fnDropView@4:PROC
EXTRN	_fnSetViewToSubobject:PROC
EXTRN	_fnResetView:PROC
EXTRN	_fnResetViewFromSubobject:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_XML_ParserCreate:PROC
EXTRN	_XML_SetElementHandler:PROC
EXTRN	_XML_SetCharacterDataHandler:PROC
EXTRN	_XML_SetUnknownEncodingHandler:PROC
EXTRN	_XML_SetUserData:PROC
EXTRN	_XML_Parse:PROC
EXTRN	_XML_GetErrorCode:PROC
EXTRN	_XML_GetCurrentLineNumber:PROC
EXTRN	_XML_ParserFree:PROC
EXTRN	_XML_ErrorString:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	_memset:PROC
EXTRN	_g_pfnGetPtr:DWORD
EXTRN	_g_pfnGetHndl:DWORD
EXTRN	_AnchorBlock:DWORD
EXTRN	_cDirSep:BYTE
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_hFile$ = -512						; size = 4
_nIndent$1 = -508					; size = 2
_szBuffer$2 = -504					; size = 500
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_lControl$ = 12						; size = 4
_pchText$ = 16						; size = 4
_ulLth$ = 20						; size = 4
_nLevel$ = 24						; size = 2
_lpData$ = 28						; size = 4
_fnWriteXML_ToFile@24 PROC

; 2798 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 512				; 00000200H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2799 :    zLONG hFile = *((zPLONG) lpData);

	mov	eax, DWORD PTR _lpData$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _hFile$[ebp], ecx

; 2800 : 
; 2801 : // if ( lControl & zXML_STARTENTITY )  // too many blank lines as far as I can tell ... dks 2009.11.30
; 2802 : //    SysWriteLine( lpTaskView, hFile, "" );
; 2803 : 
; 2804 :    // Some XML elements will be indented.
; 2805 :    if ( lControl & (zXML_STARTATTRIB | zXML_STARTENTITY | zXML_ENDENTITY) )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 28					; 0000001cH
	je	SHORT $LN2@fnWriteXML

; 2806 :    {
; 2807 :       if ( nLevel > 0 )

	movsx	eax, WORD PTR _nLevel$[ebp]
	test	eax, eax
	jle	SHORT $LN2@fnWriteXML

; 2808 :       {
; 2809 :          zCHAR  szBuffer[ 500 ];
; 2810 :          zSHORT nIndent = nLevel * 3 - 2;

	movsx	ecx, WORD PTR _nLevel$[ebp]
	imul	edx, ecx, 3
	sub	edx, 2
	mov	WORD PTR _nIndent$1[ebp], dx

; 2811 : 
; 2812 :          zsprintf( szBuffer, "%*s ", nIndent, " " );

	push	OFFSET $SG14879
	movsx	eax, WORD PTR _nIndent$1[ebp]
	push	eax
	push	OFFSET $SG14880
	lea	ecx, DWORD PTR _szBuffer$2[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2813 :          SysWriteLineLth( lpTaskView, hFile, szBuffer, zstrlen( szBuffer ), FALSE );

	push	0
	lea	edx, DWORD PTR _szBuffer$2[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	push	eax
	lea	eax, DWORD PTR _szBuffer$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFile$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_SysWriteLineLth@20
$LN2@fnWriteXML:

; 2814 :       }
; 2815 :    }
; 2816 : 
; 2817 :    if ( lControl & (zXML_STARTATTRIB | zXML_ATTRIBVALUE) )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 80					; 00000050H
	je	SHORT $LN4@fnWriteXML

; 2818 :       SysWriteLineLth( lpTaskView, hFile, pchText, zstrlen( pchText ), FALSE );

	push	0
	mov	ecx, DWORD PTR _pchText$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _pchText$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_SysWriteLineLth@20
	jmp	SHORT $LN5@fnWriteXML
$LN4@fnWriteXML:

; 2819 :    else
; 2820 :       SysWriteLine( lpTaskView, hFile, pchText );

	mov	edx, DWORD PTR _pchText$[ebp]
	push	edx
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_SysWriteLine@12
$LN5@fnWriteXML:

; 2821 : 
; 2822 :    return( 0 );

	xor	eax, eax

; 2823 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_fnWriteXML_ToFile@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_pInfo$ = -4						; size = 4
_lpTaskView$ = 8					; size = 4
_ppchReturnBuffer$ = 12					; size = 4
_pulReturnLth$ = 16					; size = 4
_lpData$ = 20						; size = 4
_fnReadXMLData@16 PROC

; 2735 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2736 :    PXMLDATA pInfo = (PXMLDATA) lpData;

	mov	eax, DWORD PTR _lpData$[ebp]
	mov	DWORD PTR _pInfo$[ebp], eax

; 2737 : 
; 2738 :    *ppchReturnBuffer = pInfo->szReadBuffer;

	mov	ecx, DWORD PTR _pInfo$[ebp]
	mov	edx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	DWORD PTR [edx], ecx

; 2739 :    *pulReturnLth = SysReadFile( lpTaskView, pInfo->hFile,

	push	5000					; 00001388H
	mov	eax, DWORD PTR _pInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pInfo$[ebp]
	mov	edx, DWORD PTR [ecx+5000]
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_SysReadFile@16
	mov	ecx, DWORD PTR _pulReturnLth$[ebp]
	mov	DWORD PTR [ecx], eax

; 2740 :                                 pInfo->szReadBuffer,
; 2741 :                                 sizeof( pInfo->szReadBuffer ) );
; 2742 :    if ( *pulReturnLth < sizeof( pInfo->szReadBuffer ) )

	mov	edx, DWORD PTR _pulReturnLth$[ebp]
	cmp	DWORD PTR [edx], 5000			; 00001388H
	jae	SHORT $LN2@fnReadXMLD

; 2743 :       return( TRUE );   // Nothing more to read.

	mov	eax, 1
	jmp	SHORT $LN1@fnReadXMLD
	jmp	SHORT $LN1@fnReadXMLD
$LN2@fnReadXMLD:

; 2744 :    else
; 2745 :       return( FALSE );  // Still more info in file.

	xor	eax, eax
$LN1@fnReadXMLD:

; 2746 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnReadXMLData@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_k$ = -4						; size = 4
_lpPtr$ = 8						; size = 4
_Name$ = 12						; size = 4
_info$ = 16						; size = 4
_unknownEncodingHandler PROC

; 2512 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 2513 :    int  k;
; 2514 : 
; 2515 :    zmemset( info, 0, sizeof( XML_Encoding ) );

	push	1036					; 0000040cH
	push	0
	mov	eax, DWORD PTR _info$[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 2516 :    for ( k = 0; k < 256; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN4@unknownEnc
$LN2@unknownEnc:
	mov	ecx, DWORD PTR _k$[ebp]
	add	ecx, 1
	mov	DWORD PTR _k$[ebp], ecx
$LN4@unknownEnc:
	cmp	DWORD PTR _k$[ebp], 256			; 00000100H
	jge	SHORT $LN3@unknownEnc

; 2517 :       info->map[ k ] = k;

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _info$[ebp]
	mov	ecx, DWORD PTR _k$[ebp]
	mov	DWORD PTR [eax+edx*4], ecx
	jmp	SHORT $LN2@unknownEnc
$LN3@unknownEnc:

; 2518 : 
; 2519 :    return( 1 );

	mov	eax, 1

; 2520 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_unknownEncodingHandler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_nNewSize$1 = -20					; size = 4
_pchNewBuffer$2 = -16					; size = 4
_pchTgt$ = -12						; size = 4
_pchSrc$ = -8						; size = 4
_lpInfo$ = -4						; size = 4
_pvUserData$ = 8					; size = 4
_pchData$ = 12						; size = 4
_nLth$ = 16						; size = 4
_GetElementData PROC

; 2441 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2442 :    LPPARSERINFO lpInfo = (LPPARSERINFO) pvUserData;

	mov	eax, DWORD PTR _pvUserData$[ebp]
	mov	DWORD PTR _lpInfo$[ebp], eax

; 2443 :    zPCHAR       pchSrc, pchTgt;
; 2444 : 
; 2445 :    #ifdef TRACE_XML
; 2446 :       TraceBuffer( "(xml) Element data = ", (zPVOID) pchData, nLth );
; 2447 :    #endif
; 2448 : 
; 2449 :    // Ignore data unless we're reading attribute value data.
; 2450 :    if ( lpInfo->lpViewAttrib == 0 )

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	jne	SHORT $LN5@GetElement

; 2451 :       return;

	jmp	$LN1@GetElement
$LN5@GetElement:

; 2452 : 
; 2453 :    if ( lpInfo->bFatalError == TRUE )

	mov	edx, DWORD PTR _lpInfo$[ebp]
	movzx	eax, BYTE PTR [edx+4850]
	cmp	eax, 1
	jne	SHORT $LN6@GetElement

; 2454 :       return;

	jmp	$LN1@GetElement
$LN6@GetElement:

; 2455 : 
; 2456 :    // The attribute value can come in chunks so we have to concatenate all
; 2457 :    // the chunks before we can set the attribute.  Allocate space big enough
; 2458 :    // to hold the current chunk.
; 2459 :    if ( lpInfo->nBufferPhysicalSize < nLth + lpInfo->nBufferCurrentUsed )

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR _nLth$[ebp]
	add	edx, DWORD PTR [ecx+842]
	mov	eax, DWORD PTR _lpInfo$[ebp]
	cmp	DWORD PTR [eax+838], edx
	jge	SHORT $LN7@GetElement

; 2460 :    {
; 2461 :       int    nNewSize = nLth + lpInfo->nBufferCurrentUsed + 5000;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+842]
	mov	eax, DWORD PTR _nLth$[ebp]
	lea	ecx, DWORD PTR [eax+edx+5000]
	mov	DWORD PTR _nNewSize$1[ebp], ecx

; 2462 :       zPCHAR pchNewBuffer;
; 2463 : 
; 2464 :       // Allocate a new chunk.
; 2465 :       pchNewBuffer = malloc( nNewSize );

	mov	edx, DWORD PTR _nNewSize$1[ebp]
	push	edx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _pchNewBuffer$2[ebp], eax

; 2466 : 
; 2467 :       // If there was an old buffer then copy data to new buffer.
; 2468 :       if ( lpInfo->pchAttributeBuffer )

	mov	eax, DWORD PTR _lpInfo$[ebp]
	cmp	DWORD PTR [eax+834], 0
	je	SHORT $LN8@GetElement

; 2469 :       {
; 2470 :          zmemcpy( pchNewBuffer, lpInfo->pchAttributeBuffer,

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+842]
	push	edx
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+834]
	push	ecx
	mov	edx, DWORD PTR _pchNewBuffer$2[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 2471 :                   lpInfo->nBufferCurrentUsed );
; 2472 : 
; 2473 :          free( lpInfo->pchAttributeBuffer );

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+834]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN8@GetElement:

; 2474 :       }
; 2475 : 
; 2476 :       lpInfo->pchAttributeBuffer  = pchNewBuffer;

	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR _pchNewBuffer$2[ebp]
	mov	DWORD PTR [edx+834], eax

; 2477 :       lpInfo->nBufferPhysicalSize = nNewSize;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR _nNewSize$1[ebp]
	mov	DWORD PTR [ecx+838], edx
$LN7@GetElement:

; 2478 :    }
; 2479 : 
; 2480 :    // Append new data to the buffer.  Do it one char at a time so we can
; 2481 :    // convert special chars.
; 2482 :    pchTgt = &lpInfo->pchAttributeBuffer[ lpInfo->nBufferCurrentUsed ];

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+834]
	mov	edx, DWORD PTR _lpInfo$[ebp]
	add	ecx, DWORD PTR [edx+842]
	mov	DWORD PTR _pchTgt$[ebp], ecx

; 2483 :    for ( pchSrc = (zPCHAR) pchData;

	mov	eax, DWORD PTR _pchData$[ebp]
	mov	DWORD PTR _pchSrc$[ebp], eax
	jmp	SHORT $LN4@GetElement
$LN2@GetElement:

; 2485 :          pchSrc++ )

	mov	ecx, DWORD PTR _pchSrc$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchSrc$[ebp], ecx
$LN4@GetElement:

; 2484 :          pchSrc != (zPCHAR) pchData + nLth;

	mov	edx, DWORD PTR _pchData$[ebp]
	add	edx, DWORD PTR _nLth$[ebp]
	cmp	DWORD PTR _pchSrc$[ebp], edx
	je	$LN1@GetElement

; 2486 :    {
; 2487 :       // We need to convert chars from their UTF-8 representation back to
; 2488 :       // their ASCII representation.  For char with hex value 0 - 7f it's
; 2489 :       // just a straight translation. Other chars need something special.
; 2490 :       if ( (zUCHAR) *pchSrc == 194 )

	mov	eax, DWORD PTR _pchSrc$[ebp]
	movzx	ecx, BYTE PTR [eax]
	cmp	ecx, 194				; 000000c2H
	jne	SHORT $LN9@GetElement

; 2491 :       {
; 2492 :          // Next byte after 194 represents char.
; 2493 :          *pchTgt++ = *++pchSrc;

	mov	edx, DWORD PTR _pchSrc$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchSrc$[ebp], edx
	mov	eax, DWORD PTR _pchTgt$[ebp]
	mov	ecx, DWORD PTR _pchSrc$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pchTgt$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchTgt$[ebp], eax

; 2494 :       }

	jmp	SHORT $LN10@GetElement
$LN9@GetElement:

; 2495 :       else
; 2496 :       if ( (zUCHAR) *pchSrc == 195 )

	mov	ecx, DWORD PTR _pchSrc$[ebp]
	movzx	edx, BYTE PTR [ecx]
	cmp	edx, 195				; 000000c3H
	jne	SHORT $LN11@GetElement

; 2497 :       {
; 2498 :          // Next byte after 194 represents char.
; 2499 :          *pchTgt++ = *++pchSrc + 64;

	mov	eax, DWORD PTR _pchSrc$[ebp]
	add	eax, 1
	mov	DWORD PTR _pchSrc$[ebp], eax
	mov	ecx, DWORD PTR _pchSrc$[ebp]
	movsx	edx, BYTE PTR [ecx]
	add	edx, 64					; 00000040H
	mov	eax, DWORD PTR _pchTgt$[ebp]
	mov	BYTE PTR [eax], dl
	mov	ecx, DWORD PTR _pchTgt$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchTgt$[ebp], ecx

; 2500 :       }

	jmp	SHORT $LN10@GetElement
$LN11@GetElement:

; 2501 :       else
; 2502 :          *pchTgt++ = *pchSrc;

	mov	edx, DWORD PTR _pchTgt$[ebp]
	mov	eax, DWORD PTR _pchSrc$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pchTgt$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchTgt$[ebp], edx
$LN10@GetElement:

; 2503 : 
; 2504 :       lpInfo->nBufferCurrentUsed++;

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+842]
	add	ecx, 1
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [edx+842], ecx

; 2505 :    }

	jmp	$LN2@GetElement
$LN1@GetElement:

; 2506 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GetElementData ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_lpAttribFlags$1 = -16					; size = 4
_lpViewEntity$2 = -12					; size = 4
_lpViewAttrib$3 = -8					; size = 4
_lpInfo$ = -4						; size = 4
_pvUserData$ = 8					; size = 4
_cpcElementName$ = 12					; size = 4
_endElement PROC

; 2357 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2358 :    LPPARSERINFO lpInfo = (LPPARSERINFO) pvUserData;

	mov	eax, DWORD PTR _pvUserData$[ebp]
	mov	DWORD PTR _lpInfo$[ebp], eax

; 2359 : 
; 2360 :    #ifdef TRACE_XML
; 2361 :       TraceLineS( "(xml) End of element ", cpcElementName );
; 2362 :    #endif
; 2363 : 
; 2364 :    if ( lpInfo->bFatalError )

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	movzx	edx, BYTE PTR [ecx+4850]
	test	edx, edx
	je	SHORT $LN2@endElement

; 2365 :    {
; 2366 :       if ( lpInfo->bFatalError < 0 )

	mov	eax, DWORD PTR _lpInfo$[ebp]
	movzx	ecx, BYTE PTR [eax+4850]
	test	ecx, ecx
	jge	SHORT $LN3@endElement

; 2367 :          lpInfo->bFatalError = 0;

	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	BYTE PTR [edx+4850], 0
$LN3@endElement:

; 2368 : 
; 2369 :       return;

	jmp	$LN1@endElement
$LN2@endElement:

; 2370 :    }
; 2371 : 
; 2372 :    // If lpViewAttrib is not 0 then we've just finished reading attribute data.
; 2373 :    // Set the attribute value.
; 2374 :    if ( lpInfo->lpViewAttrib )

	mov	eax, DWORD PTR _lpInfo$[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	$LN4@endElement

; 2375 :    {
; 2376 :       LPVIEWATTRIB  lpViewAttrib = lpInfo->lpViewAttrib;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+30]
	mov	DWORD PTR _lpViewAttrib$3[ebp], edx

; 2377 :       LPVIEWENTITY  lpViewEntity = zGETPTR( lpViewAttrib->hViewEntity );

	mov	eax, DWORD PTR _lpViewAttrib$3[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$2[ebp], eax

; 2378 :       LPATTRIBFLAGS lpAttribFlags;
; 2379 : 
; 2380 :       if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$3[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $LN6@endElement

; 2381 :       {
; 2382 :          StoreValueInRecord( lpInfo->vOI, lpViewEntity, lpViewAttrib,

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+842]
	push	edx
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+834]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_StoreValueInRecord@20

; 2383 :                              lpInfo->pchAttributeBuffer,
; 2384 :                              lpInfo->nBufferCurrentUsed );
; 2385 :       }

	jmp	SHORT $LN7@endElement
$LN6@endElement:

; 2386 :       else
; 2387 :       {
; 2388 :          // Terminate the string.
; 2389 :          lpInfo->pchAttributeBuffer[ lpInfo->nBufferCurrentUsed ] = 0;

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+842]
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR [edx+834]
	mov	BYTE PTR [eax+ecx], 0

; 2390 : 
; 2391 :          StoreStringInRecord( lpInfo->vOI, lpViewEntity, lpViewAttrib,

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+834]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$2[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_StoreStringInRecord@16
$LN7@endElement:

; 2392 :                               lpInfo->pchAttributeBuffer );
; 2393 :       }
; 2394 : 
; 2395 :       // Set attribute flags.
; 2396 :       GetAttributeFlags( &lpAttribFlags, lpInfo->vOI, lpViewEntity, lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$2[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	lea	edx, DWORD PTR _lpAttribFlags$1[ebp]
	push	edx
	call	_GetAttributeFlags@16

; 2397 :       lpAttribFlags->u.uFlags = lpInfo->AttribFlags.u.uFlags;

	mov	eax, DWORD PTR _lpAttribFlags$1[ebp]
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+846]
	mov	DWORD PTR [eax], edx

; 2398 : 
; 2399 :       // Set ptr to indicate we are no longer processing an attribute.
; 2400 :       lpInfo->lpViewAttrib = 0;

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [eax+30], 0

; 2401 : 
; 2402 :       // Indicate Attr buffer is empty.
; 2403 :       lpInfo->nBufferCurrentUsed = 0;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [ecx+842], 0

; 2404 :    }

	jmp	$LN5@endElement
$LN4@endElement:

; 2405 :    else
; 2406 :    if ( lpInfo->lpViewEntity )

	mov	edx, DWORD PTR _lpInfo$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	$LN5@endElement

; 2407 :    {
; 2408 :       // Must be the end of the entity.  This means that the current entity
; 2409 :       // is now the parent of lpViewEntity.
; 2410 :       lpInfo->lpViewEntity = zGETPTR( lpInfo->lpViewEntity->hParent );

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [ecx+22], eax

; 2411 : 
; 2412 :       // We are done with this entity so we can now set its incremental update flags.
; 2413 :       if ( lpInfo->lpEntityInstance[ lpInfo->nDepth ] == 0 ) // zero if error

	mov	edx, DWORD PTR _lpInfo$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	cmp	DWORD PTR [ecx+eax*4+434], 0
	jne	SHORT $LN9@endElement

; 2414 :          SysMessageBox( lpInfo->vSubtask, "Error", "Depth Error parsing XML", 1 );

	push	1
	push	OFFSET $SG14714
	push	OFFSET $SG14715
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	_SysMessageBox@16
	jmp	SHORT $LN10@endElement
$LN9@endElement:

; 2415 :       else
; 2416 :          lpInfo->lpEntityInstance[ lpInfo->nDepth ]->u.nIndicators = lpInfo->nIndicators [ lpInfo->nDepth ];

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	eax, DWORD PTR _lpInfo$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+434]
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+34]
	mov	DWORD PTR [ecx+6], edx
$LN10@endElement:

; 2417 : 
; 2418 :       // If there is an abstract child then copy the indicators.
; 2419 :       if ( lpInfo->lpAbstractChildEI )

	mov	eax, DWORD PTR _lpInfo$[ebp]
	cmp	DWORD PTR [eax+18], 0
	je	SHORT $LN11@endElement

; 2420 :          lpInfo->lpAbstractChildEI->u.nIndicators = lpInfo->nIndicators [ lpInfo->nDepth ];

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	movsx	edx, WORD PTR [ecx]
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+18]
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [eax+edx*4+34]
	mov	DWORD PTR [ecx+6], edx
$LN11@endElement:

; 2421 : 
; 2422 :       // If the entity is an abstract child it may have had a child entity underneath it.
; 2423 :       // If so we need to decrement nDepth because the abstract child takes up two entities.
; 2424 :       if ( lpInfo->lpViewEntity &&

	mov	eax, DWORD PTR _lpInfo$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN5@endElement
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	movsx	eax, WORD PTR [edx+217]
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+850]
	and	edx, 1
	je	SHORT $LN5@endElement

; 2425 :            lpInfo->EntityInfo[ lpInfo->lpViewEntity->nHierNbr ].bFirstUnderAbChild )
; 2426 :       {
; 2427 :          lpInfo->nDepth--;

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	cx, WORD PTR [eax]
	sub	cx, 1
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	WORD PTR [edx], cx

; 2428 :          lpInfo->EntityInfo[ lpInfo->lpViewEntity->nHierNbr ].bFirstUnderAbChild = 0;

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	movsx	edx, WORD PTR [ecx+217]
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+850]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR [edx+22]
	movsx	edx, WORD PTR [eax+217]
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [eax+edx*4+850], ecx

; 2429 :          lpInfo->lpViewEntity = zGETPTR( lpInfo->lpViewEntity->hParent );

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [ecx+22], eax
$LN5@endElement:

; 2430 :       }
; 2431 :    }
; 2432 : 
; 2433 :    // We're ending an element so depth is now one less.
; 2434 :    lpInfo->nDepth--;

	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	ax, WORD PTR [edx]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	WORD PTR [ecx], ax
$LN1@endElement:

; 2435 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_endElement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_lpAttribFlags$1 = -72					; size = 4
tv283 = -68						; size = 4
tv282 = -64						; size = 4
tv232 = -60						; size = 4
tv231 = -56						; size = 4
tv207 = -52						; size = 4
tv206 = -48						; size = 4
tv177 = -44						; size = 4
tv176 = -40						; size = 4
_pchEntityFlag$ = -36					; size = 4
tv78 = -32						; size = 4
tv77 = -28						; size = 4
_lpParentViewEntity$2 = -24				; size = 4
_pchEntityName$ = -20					; size = 4
_lpViewAttrib$3 = -16					; size = 4
_lpViewEntity$4 = -12					; size = 4
_lpInfo$ = -8						; size = 4
_k$5 = -4						; size = 2
_pvUserData$ = 8					; size = 4
_cpcElementName$ = 12					; size = 4
_ppAtts$ = 16						; size = 4
_startElement PROC

; 2200 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H

; 2201 :    zPCHAR       pchEntityFlag;
; 2202 :    zPCHAR       pchEntityName;
; 2203 :    LPPARSERINFO lpInfo = (LPPARSERINFO) pvUserData;

	mov	eax, DWORD PTR _pvUserData$[ebp]
	mov	DWORD PTR _lpInfo$[ebp], eax

; 2204 : 
; 2205 :    // If we've had a fatal error then just skip processing.
; 2206 :    if ( lpInfo->bFatalError )

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	movzx	edx, BYTE PTR [ecx+4850]
	test	edx, edx
	je	SHORT $LN14@startEleme

; 2207 :       return;

	jmp	$LN1@startEleme
$LN14@startEleme:

; 2208 : 
; 2209 :    #ifdef TRACE_XML
; 2210 :       fnTraceAttributes( cpcElementName, ppAtts );
; 2211 :    #endif
; 2212 : 
; 2213 :    // If the element name is "zOI" then get info from attributes.
; 2214 :    if ( zstrcmp( cpcElementName, "zOI" ) == 0 )

	mov	eax, DWORD PTR _cpcElementName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG14662
	cmp	ecx, edx
	jne	SHORT $LN40@startEleme
	push	OFFSET $SG14663
	mov	eax, DWORD PTR _cpcElementName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv78[ebp], eax
	jmp	SHORT $LN41@startEleme
$LN40@startEleme:
	mov	ecx, DWORD PTR _cpcElementName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14664
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN38@startEleme
	mov	DWORD PTR tv77[ebp], 1
	jmp	SHORT $LN39@startEleme
$LN38@startEleme:
	mov	DWORD PTR tv77[ebp], -1
$LN39@startEleme:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR tv78[ebp], ecx
$LN41@startEleme:
	cmp	DWORD PTR tv78[ebp], 0
	jne	SHORT $LN15@startEleme

; 2215 :    {
; 2216 :       lpInfo->bZeidonXML = TRUE;

	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	BYTE PTR [edx+4851], 1

; 2217 :       fnProcessOI_Element( lpInfo, ppAtts );

	mov	eax, DWORD PTR _ppAtts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	push	ecx
	call	_fnProcessOI_Element@8

; 2218 :       return;

	jmp	$LN1@startEleme

; 2219 :    }

	jmp	SHORT $LN16@startEleme
$LN15@startEleme:

; 2220 :    else
; 2221 :    if ( lpInfo->vOI == 0 )

	mov	edx, DWORD PTR _lpInfo$[ebp]
	cmp	DWORD PTR [edx+6], 0
	jne	SHORT $LN16@startEleme

; 2222 :    {
; 2223 :       if ( ActivateEmptyObjectInstance( &lpInfo->vOI, lpInfo->lpViewOD->szName,
; 2224 :                                         lpInfo->vSubtask, zMULTIPLE ) == zCALL_ERROR )

	push	256					; 00000100H
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR [edx+10]
	add	eax, 10					; 0000000aH
	push	eax
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	add	ecx, 6
	push	ecx
	call	_ActivateEmptyObjectInstance@16
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN16@startEleme

; 2225 :       {
; 2226 :          lpInfo->bFatalError = TRUE;

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	BYTE PTR [eax+4850], 1

; 2227 :          return;

	jmp	$LN1@startEleme
$LN16@startEleme:

; 2228 :       }
; 2229 :    }
; 2230 : 
; 2231 :    // Check to see if the tag is an entity.  It will be an entity if there
; 2232 :    // is an identifier called zLevel.
; 2233 :    fnGetIdentifierValue( lpInfo, ppAtts, "zLevel", &pchEntityFlag );

	lea	ecx, DWORD PTR _pchEntityFlag$[ebp]
	push	ecx
	push	OFFSET $SG14667
	mov	edx, DWORD PTR _ppAtts$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInfo$[ebp]
	push	eax
	call	_fnGetIdentifierValue@16

; 2234 :    if ( pchEntityFlag && *pchEntityFlag )

	cmp	DWORD PTR _pchEntityFlag$[ebp], 0
	je	SHORT $LN19@startEleme
	mov	ecx, DWORD PTR _pchEntityFlag$[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN19@startEleme

; 2235 :    {
; 2236 :       // Trying to find out when this occurs ... dks 2009.11.13
; 2237 :       SysMessageBox( lpInfo->vSubtask, "Error", "Located zLevel parsing XML", 1 );

	push	1
	push	OFFSET $SG14670
	push	OFFSET $SG14671
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	_SysMessageBox@16

; 2238 : 
; 2239 :       // Check to see if the entity name is supplied.  It will be supplied
; 2240 :       // if the entity name is different from the element name.
; 2241 :       fnGetIdentifierValue( lpInfo, ppAtts, "zEName", &pchEntityName );

	lea	edx, DWORD PTR _pchEntityName$[ebp]
	push	edx
	push	OFFSET $SG14672
	mov	eax, DWORD PTR _ppAtts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	push	ecx
	call	_fnGetIdentifierValue@16

; 2242 :       if ( pchEntityName == 0 || *pchEntityName == 0 )

	cmp	DWORD PTR _pchEntityName$[ebp], 0
	je	SHORT $LN22@startEleme
	mov	edx, DWORD PTR _pchEntityName$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	jne	SHORT $LN21@startEleme
$LN22@startEleme:

; 2243 :       {
; 2244 :          // It wasn't supplied so use the element name.
; 2245 :          pchEntityName = (zPCHAR) cpcElementName;

	mov	ecx, DWORD PTR _cpcElementName$[ebp]
	mov	DWORD PTR _pchEntityName$[ebp], ecx
$LN21@startEleme:

; 2246 :       }
; 2247 : 
; 2248 :       fnProcessEntityElement( lpInfo, cpcElementName, pchEntityName, ppAtts );

	mov	edx, DWORD PTR _ppAtts$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcElementName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInfo$[ebp]
	push	edx
	call	_fnProcessEntityElement@16

; 2249 :       return;

	jmp	$LN1@startEleme

; 2250 :    }

	jmp	$LN20@startEleme
$LN19@startEleme:

; 2251 :    else
; 2252 :    if ( lpInfo->bZeidonXML == FALSE )

	mov	eax, DWORD PTR _lpInfo$[ebp]
	movzx	ecx, BYTE PTR [eax+4851]
	test	ecx, ecx
	jne	$LN20@startEleme

; 2253 :    {
; 2254 :       LPVIEWENTITY lpViewEntity;
; 2255 : 
; 2256 :       // Check to see if the element name matches an entity name.
; 2257 :       for ( lpViewEntity = zGETPTR( lpInfo->lpViewOD->hFirstOD_Entity );

	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR [edx+10]
	mov	ecx, DWORD PTR [eax+224]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$4[ebp], eax
	jmp	SHORT $LN4@startEleme
$LN2@startEleme:

; 2259 :             lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	mov	edx, DWORD PTR _lpViewEntity$4[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$4[ebp], eax
$LN4@startEleme:

; 2258 :             lpViewEntity;

	cmp	DWORD PTR _lpViewEntity$4[ebp], 0
	je	SHORT $LN3@startEleme

; 2260 :       {
; 2261 :          if ( zstrcmp( cpcElementName, lpViewEntity->szName ) == 0 )

	mov	ecx, DWORD PTR _cpcElementName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _lpViewEntity$4[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	cmp	edx, ecx
	jne	SHORT $LN44@startEleme
	mov	edx, DWORD PTR _lpViewEntity$4[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _cpcElementName$[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv177[ebp], eax
	jmp	SHORT $LN45@startEleme
$LN44@startEleme:
	mov	ecx, DWORD PTR _cpcElementName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _lpViewEntity$4[ebp]
	movsx	ecx, BYTE PTR [eax+14]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $LN42@startEleme
	mov	DWORD PTR tv176[ebp], 1
	jmp	SHORT $LN43@startEleme
$LN42@startEleme:
	mov	DWORD PTR tv176[ebp], -1
$LN43@startEleme:
	mov	edx, DWORD PTR tv176[ebp]
	mov	DWORD PTR tv177[ebp], edx
$LN45@startEleme:
	cmp	DWORD PTR tv177[ebp], 0
	jne	SHORT $LN24@startEleme

; 2262 :             break;

	jmp	SHORT $LN3@startEleme
$LN24@startEleme:

; 2263 :       }

	jmp	SHORT $LN2@startEleme
$LN3@startEleme:

; 2264 : 
; 2265 :       if ( lpViewEntity == 0 )  // did not find entity the normal way

	cmp	DWORD PTR _lpViewEntity$4[ebp], 0
	jne	$LN25@startEleme

; 2266 :       {
; 2267 :          LPVIEWENTITY lpParentViewEntity;
; 2268 : 
; 2269 :           // Check for entity using the XML entity name (to permit us to process duplicate XML entity names).
; 2270 :          for ( lpViewEntity = zGETPTR( lpInfo->lpViewOD->hFirstOD_Entity );

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	mov	edx, DWORD PTR [ecx+224]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$4[ebp], eax
	jmp	SHORT $LN7@startEleme
$LN5@startEleme:

; 2272 :                lpViewEntity = zGETPTR( lpViewEntity->hNextHier ) )

	mov	eax, DWORD PTR _lpViewEntity$4[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$4[ebp], eax
$LN7@startEleme:

; 2271 :                lpViewEntity;

	cmp	DWORD PTR _lpViewEntity$4[ebp], 0
	je	$LN25@startEleme

; 2273 :          {
; 2274 :             if ( lpViewEntity->szXML_Name[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpViewEntity$4[ebp]
	movsx	edx, BYTE PTR [ecx+eax+47]
	test	edx, edx
	je	$LN26@startEleme

; 2275 :             {
; 2276 :                if ( zstrcmp( cpcElementName, lpViewEntity->szXML_Name ) == 0 )

	mov	eax, DWORD PTR _cpcElementName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _lpViewEntity$4[ebp]
	movsx	eax, BYTE PTR [edx+47]
	cmp	ecx, eax
	jne	SHORT $LN48@startEleme
	mov	ecx, DWORD PTR _lpViewEntity$4[ebp]
	add	ecx, 47					; 0000002fH
	push	ecx
	mov	edx, DWORD PTR _cpcElementName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv207[ebp], eax
	jmp	SHORT $LN49@startEleme
$LN48@startEleme:
	mov	eax, DWORD PTR _cpcElementName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _lpViewEntity$4[ebp]
	movsx	eax, BYTE PTR [edx+47]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN46@startEleme
	mov	DWORD PTR tv206[ebp], 1
	jmp	SHORT $LN47@startEleme
$LN46@startEleme:
	mov	DWORD PTR tv206[ebp], -1
$LN47@startEleme:
	mov	ecx, DWORD PTR tv206[ebp]
	mov	DWORD PTR tv207[ebp], ecx
$LN49@startEleme:
	cmp	DWORD PTR tv207[ebp], 0
	jne	SHORT $LN26@startEleme

; 2277 :                {
; 2278 :                   lpParentViewEntity = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$4[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParentViewEntity$2[ebp], eax

; 2279 :                   if ( zstrcmp( lpParentViewEntity->szName, lpInfo->lpViewEntity->szName ) == 0 )

	mov	ecx, DWORD PTR _lpParentViewEntity$2[ebp]
	movsx	edx, BYTE PTR [ecx+14]
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	movsx	eax, BYTE PTR [ecx+14]
	cmp	edx, eax
	jne	SHORT $LN52@startEleme
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	add	edx, 14					; 0000000eH
	push	edx
	mov	eax, DWORD PTR _lpParentViewEntity$2[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv232[ebp], eax
	jmp	SHORT $LN53@startEleme
$LN52@startEleme:
	mov	ecx, DWORD PTR _lpParentViewEntity$2[ebp]
	movsx	edx, BYTE PTR [ecx+14]
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	movsx	eax, BYTE PTR [ecx+14]
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN50@startEleme
	mov	DWORD PTR tv231[ebp], 1
	jmp	SHORT $LN51@startEleme
$LN50@startEleme:
	mov	DWORD PTR tv231[ebp], -1
$LN51@startEleme:
	mov	ecx, DWORD PTR tv231[ebp]
	mov	DWORD PTR tv232[ebp], ecx
$LN53@startEleme:
	cmp	DWORD PTR tv232[ebp], 0
	jne	SHORT $LN26@startEleme

; 2280 :                      break;

	jmp	SHORT $LN25@startEleme
$LN26@startEleme:

; 2281 :                }
; 2282 :             }
; 2283 :          }

	jmp	$LN5@startEleme
$LN25@startEleme:

; 2284 :       }
; 2285 : 
; 2286 :       if ( lpViewEntity )

	cmp	DWORD PTR _lpViewEntity$4[ebp], 0
	je	$LN20@startEleme

; 2287 :       {
; 2288 :          zSHORT k;
; 2289 : 
; 2290 :       // TraceLine( "StartElement ParentEntity: %s   Entity: %s [%d]", lpInfo->lpViewEntity ? lpInfo->lpViewEntity->szName : "<root>", lpViewEntity->szName, nStartCnt );
; 2291 :          fnProcessEntityElement( lpInfo, lpViewEntity->szName, lpViewEntity->szName, ppAtts );

	mov	edx, DWORD PTR _ppAtts$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$4[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$4[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpInfo$[ebp]
	push	edx
	call	_fnProcessEntityElement@16

; 2292 :          if ( lpInfo->bFatalError )

	mov	eax, DWORD PTR _lpInfo$[ebp]
	movzx	ecx, BYTE PTR [eax+4850]
	test	ecx, ecx
	je	SHORT $LN30@startEleme

; 2293 :             return;

	jmp	$LN1@startEleme
$LN30@startEleme:

; 2294 : 
; 2295 :          // Let's look for "simple attributes" and set them if defined in the LOD.  We will not
; 2296 :          // get a startElement or an endElement for the simple attributes, so we have to take
; 2297 :          // care of everything right here and now.
; 2298 :          for ( k = 0; ppAtts[ k ] != 0; k += 2 )

	xor	edx, edx
	mov	WORD PTR _k$5[ebp], dx
	jmp	SHORT $LN10@startEleme
$LN8@startEleme:
	movsx	eax, WORD PTR _k$5[ebp]
	add	eax, 2
	mov	WORD PTR _k$5[ebp], ax
$LN10@startEleme:
	movsx	ecx, WORD PTR _k$5[ebp]
	mov	edx, DWORD PTR _ppAtts$[ebp]
	cmp	DWORD PTR [edx+ecx*4], 0
	je	$LN9@startEleme

; 2299 :          {
; 2300 :             LPVIEWATTRIB  lpViewAttrib;
; 2301 :             LPATTRIBFLAGS lpAttribFlags;
; 2302 : 
; 2303 :             // Look for the "simple attribute".
; 2304 :             for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$4[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$3[ebp], eax
	jmp	SHORT $LN13@startEleme
$LN11@startEleme:

; 2306 :                   lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewAttrib$3[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$3[ebp], eax
$LN13@startEleme:

; 2305 :                   lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$3[ebp], 0
	je	SHORT $LN12@startEleme

; 2307 :             {
; 2308 :                if ( zstrcmp( lpViewAttrib->szXML_SimpleName, ppAtts[ k ] ) == 0 )

	mov	ecx, DWORD PTR _lpViewAttrib$3[ebp]
	movsx	edx, BYTE PTR [ecx+43]
	movsx	eax, WORD PTR _k$5[ebp]
	mov	ecx, DWORD PTR _ppAtts$[ebp]
	mov	eax, DWORD PTR [ecx+eax*4]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN56@startEleme
	movsx	edx, WORD PTR _k$5[ebp]
	mov	eax, DWORD PTR _ppAtts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$3[ebp]
	add	edx, 43					; 0000002bH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv283[ebp], eax
	jmp	SHORT $LN57@startEleme
$LN56@startEleme:
	mov	eax, DWORD PTR _lpViewAttrib$3[ebp]
	movsx	ecx, BYTE PTR [eax+43]
	movsx	edx, WORD PTR _k$5[ebp]
	mov	eax, DWORD PTR _ppAtts$[ebp]
	mov	edx, DWORD PTR [eax+edx*4]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN54@startEleme
	mov	DWORD PTR tv282[ebp], 1
	jmp	SHORT $LN55@startEleme
$LN54@startEleme:
	mov	DWORD PTR tv282[ebp], -1
$LN55@startEleme:
	mov	ecx, DWORD PTR tv282[ebp]
	mov	DWORD PTR tv283[ebp], ecx
$LN57@startEleme:
	cmp	DWORD PTR tv283[ebp], 0
	jne	SHORT $LN31@startEleme

; 2309 :                   break;

	jmp	SHORT $LN12@startEleme
$LN31@startEleme:

; 2310 :             }

	jmp	$LN11@startEleme
$LN12@startEleme:

; 2311 : 
; 2312 :             // If we didn't find it, we're not too worried, but will trace the failure.
; 2313 :             if ( lpViewAttrib == 0 )

	cmp	DWORD PTR _lpViewAttrib$3[ebp], 0
	jne	SHORT $LN32@startEleme

; 2314 :             {
; 2315 :                TraceLine( "(xml) Could not find Entity.SimpleAttribute: %s.%s",

	movsx	edx, WORD PTR _k$5[ebp]
	mov	eax, DWORD PTR _ppAtts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$4[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG14686
	call	_TraceLine
	add	esp, 12					; 0000000cH

; 2316 :                           lpViewEntity->szName, ppAtts[ k ] );
; 2317 :             }

	jmp	$LN33@startEleme
$LN32@startEleme:

; 2318 :             else
; 2319 :             {
; 2320 :             // TraceLine( "(xml) Processing Entity.SimpleAttribute: %s.%s=%s",
; 2321 :             //            lpViewEntity->szName, ppAtts[ k ], ppAtts[ k + 1 ] );
; 2322 : 
; 2323 :                if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	eax, DWORD PTR _lpViewAttrib$3[ebp]
	movsx	ecx, BYTE PTR [eax+202]
	cmp	ecx, 66					; 00000042H
	jne	SHORT $LN34@startEleme

; 2324 :                {
; 2325 :                   StoreValueInRecord( lpInfo->vOI, lpViewEntity, lpViewAttrib,

	movsx	edx, WORD PTR _k$5[ebp]
	mov	eax, DWORD PTR _ppAtts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	push	ecx
	call	_strlen
	add	esp, 4
	push	eax
	movsx	edx, WORD PTR _k$5[ebp]
	mov	eax, DWORD PTR _ppAtts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_StoreValueInRecord@20

; 2326 :                                       (zPCHAR) ppAtts[ k + 1 ], strlen( ppAtts[ k + 1 ] ) );
; 2327 :                }

	jmp	SHORT $LN35@startEleme
$LN34@startEleme:

; 2328 :                else
; 2329 :                {
; 2330 :                   StoreStringInRecord( lpInfo->vOI, lpViewEntity, lpViewAttrib,

	movsx	eax, WORD PTR _k$5[ebp]
	mov	ecx, DWORD PTR _ppAtts$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+4]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$3[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$4[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_StoreStringInRecord@16
$LN35@startEleme:

; 2331 :                                        ppAtts[ k + 1 ] );
; 2332 :                }
; 2333 : 
; 2334 :                // Set attribute flags.
; 2335 :                GetAttributeFlags( &lpAttribFlags, lpInfo->vOI, lpViewEntity, lpViewAttrib );

	mov	ecx, DWORD PTR _lpViewAttrib$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$4[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	lea	edx, DWORD PTR _lpAttribFlags$1[ebp]
	push	edx
	call	_GetAttributeFlags@16

; 2336 :                lpAttribFlags->u.uFlags = lpInfo->AttribFlags.u.uFlags;

	mov	eax, DWORD PTR _lpAttribFlags$1[ebp]
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+846]
	mov	DWORD PTR [eax], edx
$LN33@startEleme:

; 2337 :             }
; 2338 :          }

	jmp	$LN8@startEleme
$LN9@startEleme:

; 2339 : 
; 2340 :          return;

	jmp	SHORT $LN1@startEleme
$LN20@startEleme:

; 2341 :       }
; 2342 :    }
; 2343 : 
; 2344 :    if ( lpInfo->lpViewEntity == 0 )

	mov	eax, DWORD PTR _lpInfo$[ebp]
	cmp	DWORD PTR [eax+22], 0
	jne	SHORT $LN36@startEleme

; 2345 :    {
; 2346 :       TraceLineS( "(xml) ERROR - Attribute without an entity.  Tag = ", cpcElementName );

	mov	ecx, DWORD PTR _cpcElementName$[ebp]
	push	ecx
	push	OFFSET $SG14690
	call	_TraceLineS@8

; 2347 :       return;

	jmp	SHORT $LN1@startEleme
$LN36@startEleme:

; 2348 :    }
; 2349 : 
; 2350 :    // If we get here then the element must be an attribute.
; 2351 :    fnProcessAttribElement( lpInfo, cpcElementName, ppAtts );

	mov	edx, DWORD PTR _ppAtts$[ebp]
	push	edx
	mov	eax, DWORD PTR _cpcElementName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	push	ecx
	call	_fnProcessAttribElement@12
$LN1@startEleme:

; 2352 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_startElement ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
tv214 = -304						; size = 4
tv204 = -300						; size = 4
tv167 = -296						; size = 4
tv166 = -292						; size = 4
tv138 = -288						; size = 4
tv137 = -284						; size = 4
tv90 = -280						; size = 4
tv89 = -276						; size = 4
_pchFlag$ = -272					; size = 4
_lpViewEntity$ = -268					; size = 4
_lpViewAttrib$ = -264					; size = 4
_szMsg$1 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpInfo$ = 8						; size = 4
_pchAttribName$ = 12					; size = 4
_ppAtts$ = 16						; size = 4
_fnProcessAttribElement@12 PROC

; 2132 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 304				; 00000130H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2133 :    LPVIEWENTITY lpViewEntity;
; 2134 :    LPVIEWATTRIB lpViewAttrib;
; 2135 :    zPCHAR       pchFlag;
; 2136 : 
; 2137 :    lpInfo->nDepth++;

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	cx, WORD PTR [eax]
	add	cx, 1
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	WORD PTR [edx], cx

; 2138 : 
; 2139 :    lpViewEntity = lpInfo->lpViewEntity;

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	mov	DWORD PTR _lpViewEntity$[ebp], ecx

; 2140 : 
; 2141 :    // Look for the attribute.  Note that we can't use fnValidViewAttrib( )
; 2142 :    // because it won't find hidden attributes.
; 2143 :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnProcessA
$LN2@fnProcessA:

; 2145 :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnProcessA:

; 2144 :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN3@fnProcessA

; 2146 :    {
; 2147 :       if ( zstrcmp( lpViewAttrib->szName, pchAttribName ) == 0 ||

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _pchAttribName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN17@fnProcessA
	mov	ecx, DWORD PTR _pchAttribName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv90[ebp], eax
	jmp	SHORT $LN18@fnProcessA
$LN17@fnProcessA:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _pchAttribName$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN15@fnProcessA
	mov	DWORD PTR tv89[ebp], 1
	jmp	SHORT $LN16@fnProcessA
$LN15@fnProcessA:
	mov	DWORD PTR tv89[ebp], -1
$LN16@fnProcessA:
	mov	ecx, DWORD PTR tv89[ebp]
	mov	DWORD PTR tv90[ebp], ecx
$LN18@fnProcessA:
	cmp	DWORD PTR tv90[ebp], 0
	je	SHORT $LN9@fnProcessA
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+76]
	mov	ecx, DWORD PTR _pchAttribName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN21@fnProcessA
	mov	eax, DWORD PTR _pchAttribName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv138[ebp], eax
	jmp	SHORT $LN22@fnProcessA
$LN21@fnProcessA:
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+76]
	mov	ecx, DWORD PTR _pchAttribName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN19@fnProcessA
	mov	DWORD PTR tv137[ebp], 1
	jmp	SHORT $LN20@fnProcessA
$LN19@fnProcessA:
	mov	DWORD PTR tv137[ebp], -1
$LN20@fnProcessA:
	mov	eax, DWORD PTR tv137[ebp]
	mov	DWORD PTR tv138[ebp], eax
$LN22@fnProcessA:
	cmp	DWORD PTR tv138[ebp], 0
	jne	SHORT $LN8@fnProcessA
$LN9@fnProcessA:

; 2148 :            zstrcmp( lpViewAttrib->szXML_ExternalName, pchAttribName ) == 0 )
; 2149 :          break;

	jmp	SHORT $LN3@fnProcessA
$LN8@fnProcessA:

; 2150 :    }

	jmp	$LN2@fnProcessA
$LN3@fnProcessA:

; 2151 : 
; 2152 :    // If we didn't find it, check the abstract child entity.
; 2153 :    if ( lpViewAttrib == 0 && lpViewEntity->bAbstract )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	$LN10@fnProcessA
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+239]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	$LN10@fnProcessA

; 2154 :    {
; 2155 :       lpViewEntity = lpInfo->lpAbstractChild;

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	mov	DWORD PTR _lpViewEntity$[ebp], ecx

; 2156 :       for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN7@fnProcessA
$LN5@fnProcessA:

; 2158 :             lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN7@fnProcessA:

; 2157 :             lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	SHORT $LN10@fnProcessA

; 2159 :       {
; 2160 :          if ( zstrcmp( lpViewAttrib->szName, pchAttribName ) == 0 )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _pchAttribName$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	ecx, eax
	jne	SHORT $LN25@fnProcessA
	mov	ecx, DWORD PTR _pchAttribName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv167[ebp], eax
	jmp	SHORT $LN26@fnProcessA
$LN25@fnProcessA:
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+10]
	mov	edx, DWORD PTR _pchAttribName$[ebp]
	movsx	eax, BYTE PTR [edx]
	sub	ecx, eax
	test	ecx, ecx
	jle	SHORT $LN23@fnProcessA
	mov	DWORD PTR tv166[ebp], 1
	jmp	SHORT $LN24@fnProcessA
$LN23@fnProcessA:
	mov	DWORD PTR tv166[ebp], -1
$LN24@fnProcessA:
	mov	ecx, DWORD PTR tv166[ebp]
	mov	DWORD PTR tv167[ebp], ecx
$LN26@fnProcessA:
	cmp	DWORD PTR tv167[ebp], 0
	jne	SHORT $LN11@fnProcessA

; 2161 :             break;

	jmp	SHORT $LN10@fnProcessA
$LN11@fnProcessA:

; 2162 :       }

	jmp	$LN5@fnProcessA
$LN10@fnProcessA:

; 2163 :    }
; 2164 : 
; 2165 :    if ( lpViewAttrib == 0 )

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	jne	SHORT $LN12@fnProcessA

; 2166 :    {
; 2167 :       zCHAR  szMsg[ 256 ];
; 2168 : 
; 2169 :       zsprintf( szMsg, "(xml) Could not find Entity.Attribute: %s.%s",

	mov	edx, DWORD PTR _pchAttribName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG14586
	lea	ecx, DWORD PTR _szMsg$1[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 2170 :                 lpViewEntity->szName, pchAttribName );
; 2171 :       TraceLineS( szMsg, "" );

	push	OFFSET $SG14587
	lea	edx, DWORD PTR _szMsg$1[ebp]
	push	edx
	call	_TraceLineS@8

; 2172 :       SysMessageBox( 0, "XML Parser", szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$1[ebp]
	push	eax
	push	OFFSET $SG14588
	push	0
	call	_SysMessageBox@16

; 2173 :       lpInfo->bFatalError = -1; // set it to be a temporary error (to prevent endElement from occurring once)

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	BYTE PTR [ecx+4850], 255		; 000000ffH

; 2174 :       lpInfo->nDepth--;

	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	ax, WORD PTR [edx]
	sub	ax, 1
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	WORD PTR [ecx], ax

; 2175 :       return;

	jmp	$LN1@fnProcessA
$LN12@fnProcessA:

; 2176 :    }
; 2177 : 
; 2178 :    lpInfo->lpViewAttrib = lpViewAttrib;

	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	DWORD PTR [edx+30], eax

; 2179 : 
; 2180 :    // Get the attribute flags.
; 2181 :    lpInfo->AttribFlags.u.uFlags = 0;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [ecx+846], 0

; 2182 :    lpInfo->AttribFlags.u.bFlags.bUpdated = TRUE;

	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR [edx+846]
	or	eax, 2
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [ecx+846], eax

; 2183 :    fnGetIdentifierValue( lpInfo, ppAtts, "zIncreFlags", &pchFlag );

	lea	edx, DWORD PTR _pchFlag$[ebp]
	push	edx
	push	OFFSET $SG14589
	mov	eax, DWORD PTR _ppAtts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	push	ecx
	call	_fnGetIdentifierValue@16

; 2184 :    if ( lpInfo->bIncreFlags && pchFlag )

	mov	edx, DWORD PTR _lpInfo$[ebp]
	movzx	eax, BYTE PTR [edx+4852]
	test	eax, eax
	je	$LN1@fnProcessA
	cmp	DWORD PTR _pchFlag$[ebp], 0
	je	$LN1@fnProcessA

; 2185 :    {
; 2186 :       lpInfo->AttribFlags.u.bFlags.bActivated =

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _pchFlag$[ebp]
	movsx	ecx, BYTE PTR [eax+edx]
	cmp	ecx, 89					; 00000059H
	jne	SHORT $LN27@fnProcessA
	mov	DWORD PTR tv204[ebp], 1
	jmp	SHORT $LN28@fnProcessA
$LN27@fnProcessA:
	mov	DWORD PTR tv204[ebp], 0
$LN28@fnProcessA:
	mov	edx, DWORD PTR tv204[ebp]
	and	edx, 1
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+846]
	and	ecx, -2					; fffffffeH
	or	ecx, edx
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [edx+846], ecx

; 2187 :                                  pchFlag[ ATTRIB_FLAGS_ACTIVATED_IDX ] == 'Y';
; 2188 :       lpInfo->AttribFlags.u.bFlags.bUpdated =

	mov	eax, 1
	shl	eax, 0
	mov	ecx, DWORD PTR _pchFlag$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	cmp	edx, 89					; 00000059H
	jne	SHORT $LN29@fnProcessA
	mov	DWORD PTR tv214[ebp], 1
	jmp	SHORT $LN30@fnProcessA
$LN29@fnProcessA:
	mov	DWORD PTR tv214[ebp], 0
$LN30@fnProcessA:
	mov	eax, DWORD PTR tv214[ebp]
	and	eax, 1
	shl	eax, 1
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+846]
	and	edx, -3					; fffffffdH
	or	edx, eax
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [eax+846], edx
$LN1@fnProcessA:

; 2189 :                                  pchFlag[ ATTRIB_FLAGS_UPDATED_IDX ] == 'Y';
; 2190 :    }
; 2191 : 
; 2192 : } // fnProcessAttribElement

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnProcessAttribElement@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_lER_Tok$1 = -320					; size = 4
_lpViewCsr$2 = -316					; size = 4
_lpWkViewEntity$3 = -312				; size = 4
_lpViewCsr$4 = -308					; size = 4
tv262 = -304						; size = 4
tv261 = -300						; size = 4
_pchFlag$ = -296					; size = 4
tv130 = -292						; size = 4
tv129 = -288						; size = 4
_lpEntityInstance$ = -284				; size = 4
_lpWkViewEntity$5 = -280				; size = 4
_lpParent$ = -276					; size = 4
_lpViewEntityCsr$ = -272				; size = 4
_lpViewEntity$ = -268					; size = 4
_nLevel$ = -264						; size = 2
_szMsg$6 = -260						; size = 256
__$ArrayPad$ = -4					; size = 4
_lpInfo$ = 8						; size = 4
_cpcElementName$ = 12					; size = 4
_pchEntityName$ = 16					; size = 4
_ppAtts$ = 20						; size = 4
_fnProcessEntityElement@16 PROC

; 1967 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1968 :    LPVIEWENTITY      lpViewEntity;
; 1969 :    LPVIEWENTITY      lpParent;
; 1970 :    LPENTITYINSTANCE  lpEntityInstance;
; 1971 :    LPVIEWENTITYCSR   lpViewEntityCsr;
; 1972 :    zPCHAR            pchFlag;
; 1973 :    zSHORT            nLevel;
; 1974 : 
; 1975 :    // Create the entity
; 1976 :    lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpInfo->vOI, pchEntityName, 0 );

	push	0
	mov	eax, DWORD PTR _pchEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1977 :    if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN9@fnProcessE

; 1978 :    {
; 1979 :       lpInfo->bFatalError = TRUE;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	BYTE PTR [ecx+4850], 1

; 1980 :       return;

	jmp	$LN1@fnProcessE
$LN9@fnProcessE:

; 1981 :    }
; 1982 : 
; 1983 :    // Check to see if the parent of the current entity is an abstract child.
; 1984 :    // If it is, and if the current entity is the first child found under the
; 1985 :    // abstract child, we need to bump up nDepth because the abstract child
; 1986 :    // is really two entity instances.
; 1987 :    lpParent = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$[ebp], eax

; 1988 :    if ( lpParent && lpInfo->lpViewEntity &&

	cmp	DWORD PTR _lpParent$[ebp], 0
	je	$LN10@fnProcessE
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	$LN10@fnProcessE
	mov	edx, DWORD PTR _lpParent$[ebp]
	movsx	eax, BYTE PTR [edx+14]
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	movsx	ecx, BYTE PTR [edx+14]
	cmp	eax, ecx
	jne	SHORT $LN25@fnProcessE
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR [edx+22]
	add	eax, 14					; 0000000eH
	push	eax
	mov	ecx, DWORD PTR _lpParent$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv130[ebp], eax
	jmp	SHORT $LN26@fnProcessE
$LN25@fnProcessE:
	mov	edx, DWORD PTR _lpParent$[ebp]
	movsx	eax, BYTE PTR [edx+14]
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	movsx	ecx, BYTE PTR [edx+14]
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN23@fnProcessE
	mov	DWORD PTR tv129[ebp], 1
	jmp	SHORT $LN24@fnProcessE
$LN23@fnProcessE:
	mov	DWORD PTR tv129[ebp], -1
$LN24@fnProcessE:
	mov	edx, DWORD PTR tv129[ebp]
	mov	DWORD PTR tv130[ebp], edx
$LN26@fnProcessE:
	cmp	DWORD PTR tv130[ebp], 0
	je	SHORT $LN10@fnProcessE

; 1989 :         zstrcmp( lpParent->szName, lpInfo->lpViewEntity->szName ) != 0 )
; 1990 :    {
; 1991 :       zCHAR  szMsg[ 256 ];
; 1992 : 
; 1993 :       zsprintf( szMsg, "(xml) Parent mismatch (%s != %s) for entity: %s",

	mov	eax, DWORD PTR _pchEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpParent$[ebp]
	add	ecx, 14					; 0000000eH
	push	ecx
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR [edx+22]
	add	eax, 14					; 0000000eH
	push	eax
	push	OFFSET $SG14526
	lea	ecx, DWORD PTR _szMsg$6[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 1994 :                 lpInfo->lpViewEntity->szName, lpParent->szName, pchEntityName );
; 1995 :       TraceLineS( szMsg, "" );

	push	OFFSET $SG14527
	lea	edx, DWORD PTR _szMsg$6[ebp]
	push	edx
	call	_TraceLineS@8

; 1996 :       SysMessageBox( 0, "XML Parser", szMsg, -1 );

	push	-1
	lea	eax, DWORD PTR _szMsg$6[ebp]
	push	eax
	push	OFFSET $SG14528
	push	0
	call	_SysMessageBox@16

; 1997 :       lpInfo->bFatalError = TRUE;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	BYTE PTR [ecx+4850], 1

; 1998 :       return;

	jmp	$LN1@fnProcessE
$LN10@fnProcessE:

; 1999 :    }
; 2000 : 
; 2001 :    lpInfo->nDepth++;

	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	ax, WORD PTR [edx]
	add	ax, 1
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	WORD PTR [ecx], ax

; 2002 : 
; 2003 :    if ( lpParent && lpParent->bAbstractChild &&

	cmp	DWORD PTR _lpParent$[ebp], 0
	je	SHORT $LN11@fnProcessE
	mov	edx, DWORD PTR _lpParent$[ebp]
	mov	eax, DWORD PTR [edx+239]
	shr	eax, 12					; 0000000cH
	and	eax, 1
	je	SHORT $LN11@fnProcessE
	mov	ecx, DWORD PTR _lpParent$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+850]
	and	ecx, 1
	jne	SHORT $LN11@fnProcessE

; 2004 :         lpInfo->EntityInfo[ lpParent->nHierNbr ].bFirstUnderAbChild == FALSE )
; 2005 :    {
; 2006 :       lpInfo->EntityInfo[ lpParent->nHierNbr ].bFirstUnderAbChild = TRUE;

	mov	edx, DWORD PTR _lpParent$[ebp]
	movsx	eax, WORD PTR [edx+217]
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+850]
	or	edx, 1
	mov	eax, DWORD PTR _lpParent$[ebp]
	movsx	ecx, WORD PTR [eax+217]
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [eax+ecx*4+850], edx

; 2007 :       lpInfo->nDepth++;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	dx, WORD PTR [ecx]
	add	dx, 1
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	WORD PTR [eax], dx
$LN11@fnProcessE:

; 2008 :    }
; 2009 : 
; 2010 :    nLevel = lpInfo->nDepth;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR _nLevel$[ebp], dx

; 2011 : 
; 2012 :    if ( lpViewEntityCsr->nLevel > nLevel )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN12@fnProcessE

; 2013 :    {
; 2014 :       LPVIEWCSR lpViewCsr = zGETPTR( lpInfo->vOI->hViewCsr );

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$4[ebp], eax
$LN2@fnProcessE:

; 2015 : 
; 2016 :       while ( lpViewEntityCsr->nLevel > nLevel &&

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN3@fnProcessE
	mov	eax, DWORD PTR _lpViewCsr$4[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $LN3@fnProcessE

; 2017 :               lpViewCsr->hFirstViewSubobject )
; 2018 :       {
; 2019 :          fnResetViewFromSubobject( lpInfo->vOI );

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_fnResetViewFromSubobject
	add	esp, 4

; 2020 :       }

	jmp	SHORT $LN2@fnProcessE
$LN3@fnProcessE:

; 2021 :    }

	jmp	SHORT $LN13@fnProcessE
$LN12@fnProcessE:

; 2022 :    else
; 2023 :    if ( lpViewEntityCsr->nLevel < nLevel && lpInfo->lpPrevEntityInstance )  // dks 2009.11.11

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	jge	SHORT $LN13@fnProcessE
	mov	eax, DWORD PTR _lpInfo$[ebp]
	cmp	DWORD PTR [eax+14], 0
	je	SHORT $LN13@fnProcessE

; 2024 :    {
; 2025 :       // The view entity csr level is < the entity level.
; 2026 :       // In this case, the current (last) instance must be the
; 2027 :       // parent of the instance we are about to create and
; 2028 :       // it must have recursive behaviour. Otherwise we will
; 2029 :       // drop out and issue a level error
; 2030 :       LPVIEWENTITY lpWkViewEntity =

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$3[ebp], eax

; 2031 :                   zGETPTR( lpInfo->lpPrevEntityInstance->hViewEntity );
; 2032 : 
; 2033 :       fnSetViewToSubobject( lpInfo->vOI, lpWkViewEntity, 0 );

	push	0
	mov	ecx, DWORD PTR _lpWkViewEntity$3[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH
$LN13@fnProcessE:

; 2034 :    }
; 2035 : 
; 2036 :    fnCreateEntity( lpInfo->vOI, lpViewEntity, lpViewEntityCsr, zPOS_LAST, 0 );

	push	0
	push	2
	mov	ecx, DWORD PTR _lpViewEntityCsr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_fnCreateEntity@20

; 2037 :    lpEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	edx, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax

; 2038 : 
; 2039 :    // Now set the flags for the entity.
; 2040 :    lpEntityInstance->u.nIndicators = 0;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], 0

; 2041 :    lpEntityInstance->u.nInd.bUpdated = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 4
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax

; 2042 :    fnGetIdentifierValue( lpInfo, ppAtts, "zEKey", &pchFlag );

	lea	edx, DWORD PTR _pchFlag$[ebp]
	push	edx
	push	OFFSET $SG14533
	mov	eax, DWORD PTR _ppAtts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	push	ecx
	call	_fnGetIdentifierValue@16

; 2043 :    if ( pchFlag )

	cmp	DWORD PTR _pchFlag$[ebp], 0
	je	SHORT $LN15@fnProcessE

; 2044 :       lpEntityInstance->ulKey = (zULONG) zxtol( pchFlag );

	push	16					; 00000010H
	push	0
	mov	edx, DWORD PTR _pchFlag$[ebp]
	push	edx
	call	DWORD PTR __imp__strtoul
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+50], eax
$LN15@fnProcessE:

; 2045 : 
; 2046 :    // Store the indicators so we can re-set the flags after the attribute
; 2047 :    // values have been set.
; 2048 :    lpInfo->nIndicators[ lpInfo->nDepth ] = lpEntityInstance->u.nIndicators;

	mov	edx, DWORD PTR _lpInfo$[ebp]
	movsx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [edx+6]
	mov	DWORD PTR [ecx+eax*4+34], edx

; 2049 :    lpInfo->lpEntityInstance[ lpInfo->nDepth ] = lpEntityInstance;

	mov	eax, DWORD PTR _lpInfo$[ebp]
	movsx	ecx, WORD PTR [eax]
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [edx+ecx*4+434], eax

; 2050 : 
; 2051 :    lpInfo->lpViewEntity = lpViewEntity;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+22], edx

; 2052 : 
; 2053 :    // If the entity is an abstract entity then we need to create the abstract
; 2054 :    // child, too.  UNLESS the element and entity names are the same.  If they
; 2055 :    // are the the abstract parent has no child under it and the element name
; 2056 :    // *is* the name of the abstract element.  If this is the case then we
; 2057 :    // don't need to create an abstract child.
; 2058 :    if ( lpViewEntity->bAbstract &&

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	$LN16@fnProcessE
	mov	edx, DWORD PTR _cpcElementName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	jne	SHORT $LN29@fnProcessE
	mov	eax, DWORD PTR _pchEntityName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cpcElementName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv262[ebp], eax
	jmp	SHORT $LN30@fnProcessE
$LN29@fnProcessE:
	mov	edx, DWORD PTR _cpcElementName$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN27@fnProcessE
	mov	DWORD PTR tv261[ebp], 1
	jmp	SHORT $LN28@fnProcessE
$LN27@fnProcessE:
	mov	DWORD PTR tv261[ebp], -1
$LN28@fnProcessE:
	mov	eax, DWORD PTR tv261[ebp]
	mov	DWORD PTR tv262[ebp], eax
$LN30@fnProcessE:
	cmp	DWORD PTR tv262[ebp], 0
	je	$LN16@fnProcessE

; 2059 :         zstrcmp( cpcElementName, pchEntityName ) != 0 )
; 2060 :    {
; 2061 :       // Init/reset any info stored for each entity type.
; 2062 :       lpInfo->EntityInfo[ lpViewEntity->nHierNbr ].bFirstUnderAbChild = FALSE;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+850]
	and	ecx, -2					; fffffffeH
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [edx+eax*4+850], ecx

; 2063 : 
; 2064 :       // The entity is abstract.  This means that the element name had better
; 2065 :       // be the name of an abstract child entity.
; 2066 :       lpViewEntity = fnValidViewEntity( &lpViewEntityCsr, lpInfo->vOI,

	push	0
	mov	eax, DWORD PTR _cpcElementName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	call	_fnValidViewEntity@16
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 2067 :                                         cpcElementName, 0 );
; 2068 : 
; 2069 :       if ( lpViewEntity == 0 )

	cmp	DWORD PTR _lpViewEntity$[ebp], 0
	jne	SHORT $LN18@fnProcessE

; 2070 :       {
; 2071 :          lpInfo->bFatalError = TRUE;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	BYTE PTR [ecx+4850], 1

; 2072 :          return;

	jmp	$LN1@fnProcessE
$LN18@fnProcessE:

; 2073 :       }
; 2074 : 
; 2075 :       nLevel++;

	mov	dx, WORD PTR _nLevel$[ebp]
	add	dx, 1
	mov	WORD PTR _nLevel$[ebp], dx

; 2076 :       if ( lpViewEntityCsr->nLevel > nLevel )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN19@fnProcessE

; 2077 :       {
; 2078 :          LPVIEWCSR lpViewCsr = zGETPTR( lpInfo->vOI->hViewCsr );

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$2[ebp], eax
$LN4@fnProcessE:

; 2079 : 
; 2080 :          while ( lpViewEntityCsr->nLevel > nLevel &&

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	jle	SHORT $LN5@fnProcessE
	mov	eax, DWORD PTR _lpViewCsr$2[ebp]
	cmp	DWORD PTR [eax+30], 0
	je	SHORT $LN5@fnProcessE

; 2081 :                  lpViewCsr->hFirstViewSubobject )
; 2082 :          {
; 2083 :             fnResetViewFromSubobject( lpInfo->vOI );

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	_fnResetViewFromSubobject
	add	esp, 4

; 2084 :          }

	jmp	SHORT $LN4@fnProcessE
$LN5@fnProcessE:

; 2085 :       }

	jmp	$LN20@fnProcessE
$LN19@fnProcessE:

; 2086 :       else
; 2087 :       if ( lpViewEntityCsr->nLevel < nLevel )

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	movsx	ecx, WORD PTR [eax+22]
	movsx	edx, WORD PTR _nLevel$[ebp]
	cmp	ecx, edx
	jge	$LN20@fnProcessE

; 2088 :       {
; 2089 :          zLONG lER_Tok;
; 2090 : 
; 2091 :          // The view entity csr level is < the entity level.
; 2092 :          // In this case, the current instance must be the
; 2093 :          // parent of the instance we are about to create and
; 2094 :          // it must have recursive behaviour. Otherwise we will
; 2095 :          // drop out and issue a level error
; 2096 :          LPVIEWENTITY lpWkViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$5[ebp], eax

; 2097 : 
; 2098 :          fnSetViewToSubobject( lpInfo->vOI, lpWkViewEntity, 0 );

	push	0
	mov	edx, DWORD PTR _lpWkViewEntity$5[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	_fnSetViewToSubobject
	add	esp, 12					; 0000000cH

; 2099 : 
; 2100 :          // We have just set view to subobject so that the abstract child is
; 2101 :          // in view.  This means that the parent of the abstract child is now
; 2102 :          // referenced by the recursive parent.  Find the recursive parent
; 2103 :          // and set lpInfo accordingly.
; 2104 :          lER_Tok = lpWkViewEntity->lEREntTok;

	mov	edx, DWORD PTR _lpWkViewEntity$5[ebp]
	mov	eax, DWORD PTR [edx+195]
	mov	DWORD PTR _lER_Tok$1[ebp], eax

; 2105 :          for ( lpWkViewEntity = zGETPTR( lpWkViewEntity->hParent );

	mov	ecx, DWORD PTR _lpWkViewEntity$5[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$5[ebp], eax
	jmp	SHORT $LN8@fnProcessE
$LN6@fnProcessE:

; 2107 :                lpWkViewEntity = zGETPTR( lpWkViewEntity->hParent ) )

	mov	eax, DWORD PTR _lpWkViewEntity$5[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpWkViewEntity$5[ebp], eax
$LN8@fnProcessE:

; 2106 :                lpWkViewEntity->lEREntTok != lER_Tok;

	mov	edx, DWORD PTR _lpWkViewEntity$5[ebp]
	mov	eax, DWORD PTR [edx+195]
	cmp	eax, DWORD PTR _lER_Tok$1[ebp]
	je	SHORT $LN7@fnProcessE

; 2108 :          {
; 2109 :             // Nothing needs to be done here.
; 2110 :          }

	jmp	SHORT $LN6@fnProcessE
$LN7@fnProcessE:

; 2111 : 
; 2112 :          lpInfo->lpViewEntity = lpWkViewEntity;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR _lpWkViewEntity$5[ebp]
	mov	DWORD PTR [ecx+22], edx
$LN20@fnProcessE:

; 2113 :       }
; 2114 : 
; 2115 :       fnCreateEntity( lpInfo->vOI, lpViewEntity, lpViewEntityCsr, zPOS_LAST, 0 );

	push	0
	push	2
	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR [edx+6]
	push	eax
	call	_fnCreateEntity@20

; 2116 : 
; 2117 :       lpInfo->lpAbstractChild   = lpViewEntity;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	DWORD PTR [ecx+26], edx

; 2118 :       lpInfo->lpAbstractChildEI = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	eax, DWORD PTR _lpViewEntityCsr$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [edx+18], eax

; 2119 :    }

	jmp	SHORT $LN1@fnProcessE
$LN16@fnProcessE:

; 2120 :    else
; 2121 :    {
; 2122 :       lpInfo->lpAbstractChild   = 0;

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [eax+26], 0

; 2123 :       lpInfo->lpAbstractChildEI = 0;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	DWORD PTR [ecx+18], 0
$LN1@fnProcessE:

; 2124 :    }
; 2125 : 
; 2126 : } // fnProcessEntityElement

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnProcessEntityElement@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_pch$ = -12						; size = 4
_pchObjectName$ = -8					; size = 4
_pchAppName$ = -4					; size = 4
_lpInfo$ = 8						; size = 4
_ppAtts$ = 12						; size = 4
_fnProcessOI_Element@8 PROC

; 1926 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1927 :    zPCHAR pchObjectName;
; 1928 :    zPCHAR pchAppName;
; 1929 :    zPCHAR pch;
; 1930 : 
; 1931 :    // Activate the subtask/application if it's needed.
; 1932 :    if ( lpInfo->vSubtask == 0 )

	mov	eax, DWORD PTR _lpInfo$[ebp]
	cmp	DWORD PTR [eax+2], 0
	jne	SHORT $LN2@fnProcessO

; 1933 :    {
; 1934 :       fnGetIdentifierValue( lpInfo, ppAtts, "zAppName", &pchAppName );

	lea	ecx, DWORD PTR _pchAppName$[ebp]
	push	ecx
	push	OFFSET $SG14463
	mov	edx, DWORD PTR _ppAtts$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInfo$[ebp]
	push	eax
	call	_fnGetIdentifierValue@16

; 1935 :       if ( pchAppName == 0 ||

	cmp	DWORD PTR _pchAppName$[ebp], 0
	je	SHORT $LN4@fnProcessO
	mov	ecx, DWORD PTR _pchAppName$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpInfo$[ebp]
	add	edx, 2
	push	edx
	call	_SfCreateSubtask@12
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN2@fnProcessO
$LN4@fnProcessO:

; 1936 :            SfCreateSubtask( &lpInfo->vSubtask, 0, pchAppName ) == zCALL_ERROR )
; 1937 :       {
; 1938 :          lpInfo->bFatalError = TRUE;

	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	BYTE PTR [ecx+4850], 1

; 1939 :          return;

	jmp	$LN1@fnProcessO
$LN2@fnProcessO:

; 1940 :       }
; 1941 :    }
; 1942 : 
; 1943 :    // Activate an empty object instance.
; 1944 :    fnGetIdentifierValue( lpInfo, ppAtts, "zObjectName", &pchObjectName );

	lea	edx, DWORD PTR _pchObjectName$[ebp]
	push	edx
	push	OFFSET $SG14466
	mov	eax, DWORD PTR _ppAtts$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	push	ecx
	call	_fnGetIdentifierValue@16

; 1945 :    if ( pchObjectName == 0 ||

	cmp	DWORD PTR _pchObjectName$[ebp], 0
	je	SHORT $LN6@fnProcessO
	push	256					; 00000100H
	mov	edx, DWORD PTR _lpInfo$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	mov	ecx, DWORD PTR _pchObjectName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpInfo$[ebp]
	add	edx, 6
	push	edx
	call	_ActivateEmptyObjectInstance@16
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN5@fnProcessO
$LN6@fnProcessO:

; 1946 :         ActivateEmptyObjectInstance( &lpInfo->vOI, pchObjectName,
; 1947 :                                      lpInfo->vSubtask,
; 1948 :                                      zMULTIPLE ) == zCALL_ERROR )
; 1949 :    {
; 1950 :       SfDropSubtask( lpInfo->vSubtask, 0 );

	push	0
	mov	ecx, DWORD PTR _lpInfo$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	_SfDropSubtask@8

; 1951 :       lpInfo->bFatalError = TRUE;

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	BYTE PTR [eax+4850], 1

; 1952 :       return;

	jmp	SHORT $LN1@fnProcessO
$LN5@fnProcessO:

; 1953 :    }
; 1954 : 
; 1955 :    // Check for incremental update flags.
; 1956 :    fnGetIdentifierValue( lpInfo, ppAtts, "zIncreFlags", &pch );

	lea	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	push	OFFSET $SG14469
	mov	edx, DWORD PTR _ppAtts$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpInfo$[ebp]
	push	eax
	call	_fnGetIdentifierValue@16

; 1957 :    if ( pch && *pch == 'Y' )

	cmp	DWORD PTR _pch$[ebp], 0
	je	SHORT $LN1@fnProcessO
	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 89					; 00000059H
	jne	SHORT $LN1@fnProcessO

; 1958 :       lpInfo->bIncreFlags = TRUE;

	mov	eax, DWORD PTR _lpInfo$[ebp]
	mov	BYTE PTR [eax+4852], 1
$LN1@fnProcessO:

; 1959 : 
; 1960 : } // fnProcessOI_Element

	mov	esp, ebp
	pop	ebp
	ret	8
_fnProcessOI_Element@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_k$ = -2008						; size = 2
_szMsg$1 = -2004					; size = 2000
__$ArrayPad$ = -4					; size = 4
_cpcElementName$ = 8					; size = 4
_ppAtts$ = 12						; size = 4
_fnTraceAttributes@8 PROC

; 1910 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 2008				; 000007d8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1911 :    zSHORT k;
; 1912 : 
; 1913 :    TraceLineS( "(xml) Element = ", cpcElementName );

	mov	eax, DWORD PTR _cpcElementName$[ebp]
	push	eax
	push	OFFSET $SG14450
	call	_TraceLineS@8

; 1914 :    for ( k = 0; ppAtts[ k ] != 0; k += 2 )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN4@fnTraceAtt
$LN2@fnTraceAtt:
	movsx	edx, WORD PTR _k$[ebp]
	add	edx, 2
	mov	WORD PTR _k$[ebp], dx
$LN4@fnTraceAtt:
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _ppAtts$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN1@fnTraceAtt

; 1915 :    {
; 1916 :       zCHAR szMsg[ 2000 ];
; 1917 : 
; 1918 :       zsprintf( szMsg, "(xml) Attrib %s = %s", ppAtts[ k ], ppAtts[ k + 1 ] );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _ppAtts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4+4]
	push	ecx
	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _ppAtts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	push	OFFSET $SG14451
	lea	edx, DWORD PTR _szMsg$1[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1919 :       TraceLineS( szMsg, "" );

	push	OFFSET $SG14452
	lea	eax, DWORD PTR _szMsg$1[ebp]
	push	eax
	call	_TraceLineS@8

; 1920 :    }

	jmp	SHORT $LN2@fnTraceAtt
$LN1@fnTraceAtt:

; 1921 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_fnTraceAttributes@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
tv93 = -12						; size = 4
tv92 = -8						; size = 4
_k$ = -4						; size = 2
_lpInfo$ = 8						; size = 4
_ppAtts$ = 12						; size = 4
_pchIdName$ = 16					; size = 4
_ppchIdValue$ = 20					; size = 4
_fnGetIdentifierValue@16 PROC

; 1892 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1893 :    zSHORT k;
; 1894 : 
; 1895 :    *ppchIdValue = 0;

	mov	eax, DWORD PTR _ppchIdValue$[ebp]
	mov	DWORD PTR [eax], 0

; 1896 : 
; 1897 :    for ( k = 0; ppAtts[ k ] != 0; k += 2 )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN4@fnGetIdent
$LN2@fnGetIdent:
	movsx	edx, WORD PTR _k$[ebp]
	add	edx, 2
	mov	WORD PTR _k$[ebp], dx
$LN4@fnGetIdent:
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _ppAtts$[ebp]
	cmp	DWORD PTR [ecx+eax*4], 0
	je	SHORT $LN1@fnGetIdent

; 1898 :    {
; 1899 :       if ( zstrcmp( ppAtts[ k ], pchIdName ) == 0 )

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _ppAtts$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	movsx	edx, BYTE PTR [ecx]
	mov	eax, DWORD PTR _pchIdName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	edx, ecx
	jne	SHORT $LN9@fnGetIdent
	mov	edx, DWORD PTR _pchIdName$[ebp]
	push	edx
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _ppAtts$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv93[ebp], eax
	jmp	SHORT $LN10@fnGetIdent
$LN9@fnGetIdent:
	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _ppAtts$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _pchIdName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	sub	eax, edx
	test	eax, eax
	jle	SHORT $LN7@fnGetIdent
	mov	DWORD PTR tv92[ebp], 1
	jmp	SHORT $LN8@fnGetIdent
$LN7@fnGetIdent:
	mov	DWORD PTR tv92[ebp], -1
$LN8@fnGetIdent:
	mov	eax, DWORD PTR tv92[ebp]
	mov	DWORD PTR tv93[ebp], eax
$LN10@fnGetIdent:
	cmp	DWORD PTR tv93[ebp], 0
	jne	SHORT $LN5@fnGetIdent

; 1900 :       {
; 1901 :          *ppchIdValue = (zPCHAR) ppAtts[ k + 1 ];

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _ppchIdValue$[ebp]
	mov	eax, DWORD PTR _ppAtts$[ebp]
	mov	ecx, DWORD PTR [eax+ecx*4+4]
	mov	DWORD PTR [edx], ecx

; 1902 :          return;

	jmp	SHORT $LN1@fnGetIdent
$LN5@fnGetIdent:

; 1903 :       }
; 1904 :    }

	jmp	$LN2@fnGetIdent
$LN1@fnGetIdent:

; 1905 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnGetIdentifierValue@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_pchAttribName$ = -580					; size = 4
_pchAttribType$ = -576					; size = 4
_ulLth$ = -572						; size = 4
tv265 = -568						; size = 4
tv264 = -564						; size = 4
tv156 = -560						; size = 4
tv155 = -556						; size = 4
_lpViewNextEntity$ = -552				; size = 4
_lpNextInstance$ = -548					; size = 4
_hEntityInstance$ = -544				; size = 4
_lpViewAttrib$ = -540					; size = 4
_chType$ = -533						; size = 1
_lpChildInstance$ = -532				; size = 4
_lpViewEntity$ = -528					; size = 4
_lpComboInstance$ = -524				; size = 4
_lpSrchSelectedInstance$ = -520				; size = 4
_nFlag$ = -516						; size = 2
_pchEntityName$ = -512					; size = 4
_lpListEntryInstance$ = -508				; size = 4
_szWriteLine$ = -504					; size = 500
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_lpWriteInfo$ = 12					; size = 4
_nLevel$ = 16						; size = 2
_lpEntityInstance$ = 20					; size = 4
_fnWriteControlEntry@16 PROC

; 1179 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 580				; 00000244H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1180 :    LPVIEWATTRIB     lpViewAttrib;
; 1181 :    LPENTITYINSTANCE lpListEntryInstance;
; 1182 :    LPENTITYINSTANCE lpComboInstance;
; 1183 :    LPENTITYINSTANCE lpChildInstance;
; 1184 :    LPENTITYINSTANCE lpNextInstance;
; 1185 :    LPVIEWENTITY     lpViewEntity;
; 1186 :    LPVIEWENTITY     lpViewNextEntity;
; 1187 :    LPENTITYINSTANCE hEntityInstance;
; 1188 :    LPSELECTEDINSTANCE lpSrchSelectedInstance;
; 1189 :    zCHAR            szWriteLine[ 500 ];
; 1190 :    zCHAR            chType;
; 1191 :    zPCHAR           pchAttribName;
; 1192 :    zPCHAR           pchAttribType;
; 1193 :    zPCHAR           pchEntityName;
; 1194 :    zULONG           ulLth;
; 1195 :    zSHORT           nFlag;
; 1196 : 
; 1197 :    // Get Name and Type values.
; 1198 :    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1199 :    lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1200 :    GetValueFromRecord( lpWriteInfo->vOI, lpViewEntity, lpViewAttrib,

	lea	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _chType$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchAttribName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_GetValueFromRecord@24

; 1201 :                        &pchAttribName, &chType, &ulLth );
; 1202 :    lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1203 :    GetValueFromRecord( lpWriteInfo->vOI, lpViewEntity, lpViewAttrib,

	lea	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _chType$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchAttribType$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_GetValueFromRecord@24

; 1204 :                        &pchAttribType, &chType, &ulLth );
; 1205 : 
; 1206 :    // Create Control line and write to file
; 1207 :    zsprintf( szWriteLine, "<Control Name=\"%s\" Type=\"%s\">", pchAttribName, pchAttribType );

	mov	edx, DWORD PTR _pchAttribType$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchAttribName$[ebp]
	push	eax
	push	OFFSET $SG14158
	lea	ecx, DWORD PTR _szWriteLine$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 16					; 00000010H

; 1208 :    if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_STARTENTITY, szWriteLine,
; 1209 :                                    0, lpEntityInstance->nLevel,
; 1210 :                                    lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+10424]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movzx	edx, WORD PTR [ecx+58]
	push	edx
	push	0
	lea	eax, DWORD PTR _szWriteLine$[ebp]
	push	eax
	push	4
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+10420]
	call	eax
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN19@fnWriteCon

; 1211 :    {
; 1212 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnWriteCon
$LN19@fnWriteCon:

; 1213 :    }
; 1214 : 
; 1215 :    // If there are ListEntry entries, process them.
; 1216 :    lpNextInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpNextInstance$[ebp], eax

; 1217 :    if ( lpNextInstance == 0 )

	cmp	DWORD PTR _lpNextInstance$[ebp], 0
	jne	SHORT $LN20@fnWriteCon

; 1218 :       pchEntityName = 0;

	mov	DWORD PTR _pchEntityName$[ebp], 0
	jmp	SHORT $LN21@fnWriteCon
$LN20@fnWriteCon:

; 1219 :    else
; 1220 :    {
; 1221 :       lpViewNextEntity = zGETPTR( lpNextInstance->hViewEntity );

	mov	ecx, DWORD PTR _lpNextInstance$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewNextEntity$[ebp], eax

; 1222 :       if ( lpViewNextEntity == 0 )

	cmp	DWORD PTR _lpViewNextEntity$[ebp], 0
	jne	SHORT $LN22@fnWriteCon

; 1223 :          pchEntityName = 0;

	mov	DWORD PTR _pchEntityName$[ebp], 0
	jmp	SHORT $LN21@fnWriteCon
$LN22@fnWriteCon:

; 1224 :       else
; 1225 :          pchEntityName = lpViewNextEntity->szName;

	mov	eax, DWORD PTR _lpViewNextEntity$[ebp]
	add	eax, 14					; 0000000eH
	mov	DWORD PTR _pchEntityName$[ebp], eax
$LN21@fnWriteCon:

; 1226 :    }
; 1227 : 
; 1228 :    if ( pchEntityName &&

	cmp	DWORD PTR _pchEntityName$[ebp], 0
	je	$LN24@fnWriteCon
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14166
	cmp	edx, eax
	jne	SHORT $LN47@fnWriteCon
	push	OFFSET $SG14167
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv156[ebp], eax
	jmp	SHORT $LN48@fnWriteCon
$LN47@fnWriteCon:
	mov	edx, DWORD PTR _pchEntityName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG14168
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN45@fnWriteCon
	mov	DWORD PTR tv155[ebp], 1
	jmp	SHORT $LN46@fnWriteCon
$LN45@fnWriteCon:
	mov	DWORD PTR tv155[ebp], -1
$LN46@fnWriteCon:
	mov	edx, DWORD PTR tv155[ebp]
	mov	DWORD PTR tv156[ebp], edx
$LN48@fnWriteCon:
	cmp	DWORD PTR tv156[ebp], 0
	jne	$LN24@fnWriteCon

; 1229 :         zstrcmp( pchEntityName, "ListEntry" ) == 0 )
; 1230 :    {
; 1231 :       // These are ListEntry entries.
; 1232 :       // Create the ListEntry lines here but process ListEntryValues in fnConvertEntity.
; 1233 :       for ( lpListEntryInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpListEntryInstance$[ebp], eax
	jmp	SHORT $LN4@fnWriteCon
$LN2@fnWriteCon:

; 1235 :             lpListEntryInstance = zGETPTR( lpListEntryInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpListEntryInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpListEntryInstance$[ebp], eax
$LN4@fnWriteCon:

; 1234 :             lpListEntryInstance;

	cmp	DWORD PTR _lpListEntryInstance$[ebp], 0
	je	$LN3@fnWriteCon

; 1236 :       {
; 1237 :          nFlag = 0;

	xor	ecx, ecx
	mov	WORD PTR _nFlag$[ebp], cx

; 1238 :          fnEstablishViewForInstance( lpWriteInfo->vOI, 0, lpListEntryInstance );

	mov	edx, DWORD PTR _lpListEntryInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1239 :          lpViewEntity = zGETPTR( lpListEntryInstance->hViewEntity );

	mov	edx, DWORD PTR _lpListEntryInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1240 :          hEntityInstance = zGETHNDL( lpListEntryInstance );

	mov	ecx, DWORD PTR _lpListEntryInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hEntityInstance$[ebp], eax

; 1241 : 
; 1242 :          // Now check to see if the entity is selected.
; 1243 :          for ( lpSrchSelectedInstance =

	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchSelectedInstance$[ebp], eax
	jmp	SHORT $LN7@fnWriteCon
$LN5@fnWriteCon:

; 1246 :                lpSrchSelectedInstance =

	mov	edx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchSelectedInstance$[ebp], eax
$LN7@fnWriteCon:

; 1244 :                         zGETPTR( lpWriteInfo->lpViewCsr->hFirstSelectedInstance );
; 1245 :                lpSrchSelectedInstance;

	cmp	DWORD PTR _lpSrchSelectedInstance$[ebp], 0
	je	SHORT $LN6@fnWriteCon

; 1247 :                         zGETPTR( lpSrchSelectedInstance->hNextSelectedInstance ) )
; 1248 :          {
; 1249 :             // Check to see if the current EI is selected.
; 1250 :             if ( hEntityInstance != lpSrchSelectedInstance->xEntityInstance )

	mov	ecx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	edx, DWORD PTR _hEntityInstance$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN26@fnWriteCon

; 1251 :                continue;

	jmp	SHORT $LN5@fnWriteCon
$LN26@fnWriteCon:

; 1252 : 
; 1253 :             if ( lpViewEntity != zGETPTR( lpSrchSelectedInstance->hViewEntity ))

	mov	eax, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpViewEntity$[ebp], eax
	je	SHORT $LN27@fnWriteCon

; 1254 :                continue;

	jmp	SHORT $LN5@fnWriteCon
$LN27@fnWriteCon:

; 1255 : 
; 1256 :             // We have found a selected instance.
; 1257 :             nFlag = 1;

	mov	edx, 1
	mov	WORD PTR _nFlag$[ebp], dx

; 1258 :          }

	jmp	SHORT $LN5@fnWriteCon
$LN6@fnWriteCon:

; 1259 : 
; 1260 :          if ( nFlag == 0 )

	movsx	eax, WORD PTR _nFlag$[ebp]
	test	eax, eax
	jne	SHORT $LN28@fnWriteCon

; 1261 :             zstrcpy( szWriteLine, "<ListEntry>" );

	push	OFFSET $SG14173
	lea	ecx, DWORD PTR _szWriteLine$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN29@fnWriteCon
$LN28@fnWriteCon:

; 1262 :          else
; 1263 :             zstrcpy( szWriteLine, "<ListEntry zSelect1=\"Y\">" );

	push	OFFSET $SG14174
	lea	edx, DWORD PTR _szWriteLine$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN29@fnWriteCon:

; 1264 : 
; 1265 :          if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_STARTENTITY,
; 1266 :                                          szWriteLine, 0,
; 1267 :                                          lpListEntryInstance->nLevel,
; 1268 :                                          lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+10424]
	push	ecx
	mov	edx, DWORD PTR _lpListEntryInstance$[ebp]
	movzx	eax, WORD PTR [edx+58]
	push	eax
	push	0
	lea	ecx, DWORD PTR _szWriteLine$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+10420]
	call	ecx
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN30@fnWriteCon

; 1269 :          {
; 1270 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnWriteCon
$LN30@fnWriteCon:

; 1271 :          }
; 1272 : 
; 1273 :          // Go to fnConvertEntity for the ListEntryValues.
; 1274 :          for ( lpChildInstance = zGETPTR( lpListEntryInstance->hNextHier );

	mov	eax, DWORD PTR _lpListEntryInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildInstance$[ebp], eax
	jmp	SHORT $LN10@fnWriteCon
$LN8@fnWriteCon:

; 1276 :                lpChildInstance = zGETPTR( lpChildInstance->hNextHier ) )

	mov	edx, DWORD PTR _lpChildInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildInstance$[ebp], eax
$LN10@fnWriteCon:

; 1275 :                lpChildInstance;

	cmp	DWORD PTR _lpChildInstance$[ebp], 0
	je	$LN9@fnWriteCon

; 1277 :          {
; 1278 :             // If the child instance is at the same level as the current instance
; 1279 :             // then there are no more children of lpListEntryInstance.
; 1280 :             if ( lpChildInstance->nLevel <= lpListEntryInstance->nLevel )

	mov	ecx, DWORD PTR _lpChildInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpListEntryInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	cmp	edx, ecx
	jg	SHORT $LN31@fnWriteCon

; 1281 :                break;

	jmp	SHORT $LN9@fnWriteCon
$LN31@fnWriteCon:

; 1282 : 
; 1283 :             // If lpChildInstance is not a direct child of lpListEntryInstance then
; 1284 :             // skip it (and it's twins if it has any).
; 1285 :             if ( lpChildInstance->nLevel > lpListEntryInstance->nLevel + 1 )

	mov	edx, DWORD PTR _lpChildInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpListEntryInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	add	edx, 1
	cmp	eax, edx
	jle	SHORT $LN32@fnWriteCon
$LN11@fnWriteCon:

; 1286 :             {
; 1287 :                while ( lpChildInstance->hNextTwin )

	mov	eax, DWORD PTR _lpChildInstance$[ebp]
	cmp	DWORD PTR [eax+22], 0
	je	SHORT $LN12@fnWriteCon

; 1288 :                   lpChildInstance = zGETPTR( lpChildInstance->hNextTwin );

	mov	ecx, DWORD PTR _lpChildInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildInstance$[ebp], eax
	jmp	SHORT $LN11@fnWriteCon
$LN12@fnWriteCon:

; 1289 : 
; 1290 :                continue;

	jmp	SHORT $LN8@fnWriteCon
$LN32@fnWriteCon:

; 1291 :             }
; 1292 : 
; 1293 :             // Write the child instance to the XML stream.
; 1294 :             if ( fnConvertEntity( lpTaskView, lpWriteInfo, lpChildInstance ) != 0 )

	mov	eax, DWORD PTR _lpChildInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_fnConvertEntity@12
	cwde
	test	eax, eax
	je	SHORT $LN33@fnWriteCon

; 1295 :                return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnWriteCon
$LN33@fnWriteCon:

; 1296 :          }

	jmp	$LN8@fnWriteCon
$LN9@fnWriteCon:

; 1297 : 
; 1298 :          zstrcpy( szWriteLine, "</ListEntry>" );

	push	OFFSET $SG14179
	lea	ecx, DWORD PTR _szWriteLine$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1299 :          fnEstablishViewForInstance( lpWriteInfo->vOI, 0, lpListEntryInstance );

	mov	edx, DWORD PTR _lpListEntryInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1300 :          if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_ENDENTITY, szWriteLine, 0,
; 1301 :                                          lpListEntryInstance->nLevel,
; 1302 :                                          lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+10424]
	push	eax
	mov	ecx, DWORD PTR _lpListEntryInstance$[ebp]
	movzx	edx, WORD PTR [ecx+58]
	push	edx
	push	0
	lea	eax, DWORD PTR _szWriteLine$[ebp]
	push	eax
	push	8
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+10420]
	call	eax
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN34@fnWriteCon

; 1303 :          {
; 1304 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnWriteCon
$LN34@fnWriteCon:

; 1305 :          }
; 1306 :       }

	jmp	$LN2@fnWriteCon
$LN3@fnWriteCon:

; 1307 :    }

	jmp	$LN25@fnWriteCon
$LN24@fnWriteCon:

; 1308 :    else
; 1309 :    // If there are ComboValue entries, process them.
; 1310 :    if ( pchEntityName &&

	cmp	DWORD PTR _pchEntityName$[ebp], 0
	je	$LN35@fnWriteCon
	mov	edx, DWORD PTR _pchEntityName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG14183
	cmp	eax, ecx
	jne	SHORT $LN51@fnWriteCon
	push	OFFSET $SG14184
	mov	edx, DWORD PTR _pchEntityName$[ebp]
	push	edx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv265[ebp], eax
	jmp	SHORT $LN52@fnWriteCon
$LN51@fnWriteCon:
	mov	eax, DWORD PTR _pchEntityName$[ebp]
	movsx	ecx, BYTE PTR [eax]
	movsx	edx, BYTE PTR $SG14185
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN49@fnWriteCon
	mov	DWORD PTR tv264[ebp], 1
	jmp	SHORT $LN50@fnWriteCon
$LN49@fnWriteCon:
	mov	DWORD PTR tv264[ebp], -1
$LN50@fnWriteCon:
	mov	eax, DWORD PTR tv264[ebp]
	mov	DWORD PTR tv265[ebp], eax
$LN52@fnWriteCon:
	cmp	DWORD PTR tv265[ebp], 0
	jne	$LN35@fnWriteCon

; 1311 :         zstrcmp( pchEntityName, "ComboValue" ) == 0 )
; 1312 :    {
; 1313 :       // Process subentities.
; 1314 :       // Set the Control name in the "entity stack".
; 1315 :       fnEstablishViewForInstance( lpWriteInfo->vOI, 0, lpEntityInstance );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1316 :       pchEntityName = lpViewEntity->szName;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	mov	DWORD PTR _pchEntityName$[ebp], ecx

; 1317 :       lpWriteInfo->pchEntityName[ lpEntityInstance->nLevel ] = pchEntityName;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR _pchEntityName$[ebp]
	mov	DWORD PTR [ecx+eax*4+10020], edx

; 1318 : 
; 1319 :       for ( lpComboInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpComboInstance$[ebp], eax
	jmp	SHORT $LN15@fnWriteCon
$LN13@fnWriteCon:

; 1321 :             lpComboInstance = zGETPTR( lpComboInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpComboInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpComboInstance$[ebp], eax
$LN15@fnWriteCon:

; 1320 :             lpComboInstance;

	cmp	DWORD PTR _lpComboInstance$[ebp], 0
	je	$LN14@fnWriteCon

; 1322 :       {
; 1323 :          nFlag = 0;

	xor	ecx, ecx
	mov	WORD PTR _nFlag$[ebp], cx

; 1324 :          fnEstablishViewForInstance( lpWriteInfo->vTemp, 0, lpComboInstance );

	mov	edx, DWORD PTR _lpComboInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1325 :          lpViewEntity = zGETPTR( lpComboInstance->hViewEntity );

	mov	edx, DWORD PTR _lpComboInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1326 :          hEntityInstance = zGETHNDL( lpComboInstance );

	mov	ecx, DWORD PTR _lpComboInstance$[ebp]
	push	ecx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hEntityInstance$[ebp], eax

; 1327 : 
; 1328 :          // Now check to see if the entity is selected.
; 1329 :          for ( lpSrchSelectedInstance = zGETPTR( lpWriteInfo->lpViewCsr->hFirstSelectedInstance );

	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+42]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchSelectedInstance$[ebp], eax
	jmp	SHORT $LN18@fnWriteCon
$LN16@fnWriteCon:

; 1331 :                lpSrchSelectedInstance = zGETPTR( lpSrchSelectedInstance->hNextSelectedInstance ) )

	mov	edx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchSelectedInstance$[ebp], eax
$LN18@fnWriteCon:

; 1330 :                lpSrchSelectedInstance;

	cmp	DWORD PTR _lpSrchSelectedInstance$[ebp], 0
	je	SHORT $LN17@fnWriteCon

; 1332 :          {
; 1333 :             // Check to see if the current EI is selected.
; 1334 :             if ( hEntityInstance != lpSrchSelectedInstance->xEntityInstance )

	mov	ecx, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	edx, DWORD PTR _hEntityInstance$[ebp]
	cmp	edx, DWORD PTR [ecx+12]
	je	SHORT $LN37@fnWriteCon

; 1335 :                continue;

	jmp	SHORT $LN16@fnWriteCon
$LN37@fnWriteCon:

; 1336 : 
; 1337 :             if ( lpViewEntity != zGETPTR( lpSrchSelectedInstance->hViewEntity ))

	mov	eax, DWORD PTR _lpSrchSelectedInstance$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	cmp	DWORD PTR _lpViewEntity$[ebp], eax
	je	SHORT $LN38@fnWriteCon

; 1338 :                continue;

	jmp	SHORT $LN16@fnWriteCon
$LN38@fnWriteCon:

; 1339 : 
; 1340 :             // We have found a selected instance.
; 1341 :             nFlag = 1;

	mov	edx, 1
	mov	WORD PTR _nFlag$[ebp], dx

; 1342 :          }

	jmp	SHORT $LN16@fnWriteCon
$LN17@fnWriteCon:

; 1343 :          if ( nFlag == 0 )

	movsx	eax, WORD PTR _nFlag$[ebp]
	test	eax, eax
	jne	SHORT $LN39@fnWriteCon

; 1344 :             zstrcpy( szWriteLine, "<ComboValue>" );

	push	OFFSET $SG14190
	lea	ecx, DWORD PTR _szWriteLine$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN40@fnWriteCon
$LN39@fnWriteCon:

; 1345 :          else
; 1346 :             zstrcpy( szWriteLine, "<ComboValue zSelect1=\"Y\">" );

	push	OFFSET $SG14191
	lea	edx, DWORD PTR _szWriteLine$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN40@fnWriteCon:

; 1347 : 
; 1348 :          if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_STARTENTITY,
; 1349 :                                          szWriteLine, 0,
; 1350 :                                          lpComboInstance->nLevel,
; 1351 :                                          lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+10424]
	push	ecx
	mov	edx, DWORD PTR _lpComboInstance$[ebp]
	movzx	eax, WORD PTR [edx+58]
	push	eax
	push	0
	lea	ecx, DWORD PTR _szWriteLine$[ebp]
	push	ecx
	push	4
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+10420]
	call	ecx
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN41@fnWriteCon

; 1352 :          {
; 1353 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnWriteCon
$LN41@fnWriteCon:

; 1354 :          }
; 1355 : 
; 1356 :          // Write the attribs for the entity.
; 1357 :          fnWriteAttribs( lpTaskView, lpWriteInfo, (zSHORT) (lpComboInstance->nLevel + 1),

	push	0
	mov	eax, DWORD PTR _lpComboInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	edx, DWORD PTR _lpComboInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	add	eax, 1
	push	eax
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_fnWriteAttribs@20

; 1358 :                          zGETPTR( lpComboInstance->hViewEntity), 0 );
; 1359 :          zstrcpy( szWriteLine, "</ComboValue>" );

	push	OFFSET $SG14193
	lea	eax, DWORD PTR _szWriteLine$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1360 :          fnEstablishViewForInstance( lpWriteInfo->vOI, 0, lpComboInstance );

	mov	ecx, DWORD PTR _lpComboInstance$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1361 :          if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_ENDENTITY,
; 1362 :                                          szWriteLine, 0,
; 1363 :                                          lpComboInstance->nLevel,
; 1364 :                                          lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+10424]
	push	edx
	mov	eax, DWORD PTR _lpComboInstance$[ebp]
	movzx	ecx, WORD PTR [eax+58]
	push	ecx
	push	0
	lea	edx, DWORD PTR _szWriteLine$[ebp]
	push	edx
	push	8
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+10420]
	call	edx
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN42@fnWriteCon

; 1365 :          {
; 1366 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnWriteCon
$LN42@fnWriteCon:

; 1367 :          }
; 1368 :       }

	jmp	$LN13@fnWriteCon
$LN14@fnWriteCon:

; 1369 :    }

	jmp	SHORT $LN25@fnWriteCon
$LN35@fnWriteCon:

; 1370 :    else
; 1371 :    {
; 1372 :       // No subobject entries.
; 1373 :       // Create CurrentValue data line and write to file.
; 1374 :       lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1375 :       lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1376 :       fnEstablishViewForInstance( lpWriteInfo->vOI, 0, lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1377 :       fnWriteAttribEntry( lpTaskView, lpWriteInfo, (zSHORT) (nLevel + 1),

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	push	OFFSET $SG14195
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	movsx	ecx, WORD PTR _nLevel$[ebp]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_fnWriteAttribEntry@24
$LN25@fnWriteCon:

; 1378 :                           lpViewEntity, "CurrentValue", lpViewAttrib );
; 1379 :    }
; 1380 : 
; 1381 :    // Create Close Control line and write to file
; 1382 :    if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_ENDENTITY, "</Control>",
; 1383 :                                    0, lpEntityInstance->nLevel,
; 1384 :                                    lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+10424]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movzx	ecx, WORD PTR [eax+58]
	push	ecx
	push	0
	push	OFFSET $SG14197
	push	8
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+10420]
	call	ecx
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN43@fnWriteCon

; 1385 :    {
; 1386 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnWriteCon
$LN43@fnWriteCon:

; 1387 :    }
; 1388 : 
; 1389 :    // Make sure we indicate that we ended the Control structure.
; 1390 :    lpWriteInfo->pchEntityName[ lpEntityInstance->nLevel ] = 0;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	DWORD PTR [edx+ecx*4+10020], 0

; 1391 : 
; 1392 :    return( 0 );

	xor	eax, eax
$LN1@fnWriteCon:

; 1393 : 
; 1394 : } // fnWriteControlEntry

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnWriteControlEntry@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_ulLth$ = -524						; size = 4
_pchAttribName$ = -520					; size = 4
_lpViewEntity$ = -516					; size = 4
_chType$ = -509						; size = 1
_lpViewAttrib$ = -508					; size = 4
_szWriteLine$ = -504					; size = 500
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_lpWriteInfo$ = 12					; size = 4
_nLevel$ = 16						; size = 2
_lpEntityInstance$ = 20					; size = 4
_fnWriteListEntryValue@16 PROC

; 1132 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 524				; 0000020cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1133 :    LPVIEWATTRIB lpViewAttrib;
; 1134 :    LPVIEWENTITY lpViewEntity;
; 1135 :    zCHAR        szWriteLine[ 500 ];
; 1136 :    zCHAR        chType;
; 1137 :    zPCHAR       pchAttribName;
; 1138 :    zULONG       ulLth;
; 1139 : 
; 1140 :    // Get Name value.
; 1141 :    lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1142 :    lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+179]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1143 :    GetValueFromRecord( lpWriteInfo->vOI, lpViewEntity, lpViewAttrib,

	lea	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _chType$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchAttribName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_GetValueFromRecord@24

; 1144 :                        &pchAttribName, &chType, &ulLth );
; 1145 : 
; 1146 :    // Create ListEntryValue line and write to file.
; 1147 :    zsprintf( szWriteLine, "<ListEntryValue Name=\"%s\">", pchAttribName );

	mov	edx, DWORD PTR _pchAttribName$[ebp]
	push	edx
	push	OFFSET $SG14071
	lea	eax, DWORD PTR _szWriteLine$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1148 :    if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_STARTENTITY, szWriteLine,
; 1149 :                                    0, lpEntityInstance->nLevel,
; 1150 :                                    lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+10424]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movzx	ecx, WORD PTR [eax+58]
	push	ecx
	push	0
	lea	edx, DWORD PTR _szWriteLine$[ebp]
	push	edx
	push	4
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+10420]
	call	edx
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN2@fnWriteLis

; 1151 :    {
; 1152 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnWriteLis
$LN2@fnWriteLis:

; 1153 :    }
; 1154 : 
; 1155 :    // Create CurrentValue data line and write to file.
; 1156 :    lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax

; 1157 :    fnEstablishViewForInstance( lpWriteInfo->vOI, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1158 :    fnWriteAttribEntry( lpTaskView, lpWriteInfo, (zSHORT) (nLevel + 1),

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	push	OFFSET $SG14073
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	movsx	edx, WORD PTR _nLevel$[ebp]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_fnWriteAttribEntry@24

; 1159 :                        lpViewEntity, "CurrentValue", lpViewAttrib );
; 1160 : 
; 1161 :    // Create Close ListEntryValue line and write to file.
; 1162 :    if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_ENDENTITY,
; 1163 :                                    "</ListEntryValue>", 0,
; 1164 :                                    lpEntityInstance->nLevel,
; 1165 :                                    lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+10424]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movzx	edx, WORD PTR [ecx+58]
	push	edx
	push	0
	push	OFFSET $SG14075
	push	8
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+10420]
	call	edx
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN3@fnWriteLis

; 1166 :    {
; 1167 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnWriteLis
$LN3@fnWriteLis:

; 1168 :    }
; 1169 : 
; 1170 :    return( 0 );

	xor	eax, eax
$LN1@fnWriteLis:

; 1171 : 
; 1172 : } // fnWriteListEntryValue

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_fnWriteListEntryValue@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_hTempValueBuffer$ = -544				; size = 4
_lTempBufferLth$ = -540					; size = 4
_nReturn$ = -536					; size = 2
_chType$ = -529						; size = 1
tv130 = -528						; size = 4
_lCharCount$1 = -524					; size = 4
_pchTempValueBuffer$ = -520				; size = 4
_ulLth$ = -516						; size = 4
_pchAttribValue$ = -512					; size = 4
_pch$2 = -508						; size = 4
_szAttribTag$ = -504					; size = 500
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_lpWriteInfo$ = 12					; size = 4
_nLevel$ = 16						; size = 2
_lpViewEntity$ = 20					; size = 4
_pchAttribName$ = 24					; size = 4
_lpViewAttribValue$ = 28				; size = 4
_fnWriteAttribEntry@24 PROC

; 959  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 544				; 00000220H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 960  :    zSHORT       nReturn = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nReturn$[ebp], ax

; 961  :    zULONG       ulLth;
; 962  :    zPCHAR       pchTempValueBuffer = 0;

	mov	DWORD PTR _pchTempValueBuffer$[ebp], 0

; 963  :    zULONG       lTempBufferLth = 0;

	mov	DWORD PTR _lTempBufferLth$[ebp], 0

; 964  :    zLONG        hTempValueBuffer;
; 965  :    zCHAR        szAttribTag[ 500 ];
; 966  :    zPCHAR       pchAttribValue;
; 967  :    zCHAR        chType;
; 968  : 
; 969  :    zsprintf( szAttribTag, "<%s>", pchAttribName );

	mov	ecx, DWORD PTR _pchAttribName$[ebp]
	push	ecx
	push	OFFSET $SG14028
	lea	edx, DWORD PTR _szAttribTag$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 970  : 
; 971  :    // Treat the attribute lpViewAttribValue as the regular attribute and
; 972  :    // use its value.
; 973  :    GetValueFromRecord( lpWriteInfo->vOI, lpViewEntity, lpViewAttribValue,

	lea	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _chType$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchAttribValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttribValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_GetValueFromRecord@24

; 974  :                         &pchAttribValue, &chType, &ulLth );
; 975  : 
; 976  :    // Check to see if the attribute is NULL.  The we check ulLth = 1 for
; 977  :    // strings because the length contains the null-terminator.
; 978  :    if ( ulLth <= 1 || pchAttribValue == 0 )

	cmp	DWORD PTR _ulLth$[ebp], 1
	jbe	SHORT $LN11@fnWriteAtt
	cmp	DWORD PTR _pchAttribValue$[ebp], 0
	jne	SHORT $LN9@fnWriteAtt
$LN11@fnWriteAtt:

; 979  :    {
; 980  :       // If we get here then the attribute is null but it's been
; 981  :       // modified so we need to send the attribute flags.  We do this
; 982  :       // by sending a null attribute.
; 983  :       pchAttribValue = "";

	mov	DWORD PTR _pchAttribValue$[ebp], OFFSET $SG14032

; 984  :       ulLth = 0;

	mov	DWORD PTR _ulLth$[ebp], 0

; 985  :    }

	jmp	$LN10@fnWriteAtt
$LN9@fnWriteAtt:

; 986  :    else
; 987  :    {
; 988  :       zLONG lCharCount;
; 989  :       ulLth--;  // Subtract the null-terminator from the length.

	mov	ecx, DWORD PTR _ulLth$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ulLth$[ebp], ecx

; 990  : 
; 991  :       // Check to see how many chars there are that need to be
; 992  :       // translated (e.g. '&').
; 993  :       if ( (lCharCount = fnContainsSpecialChar( pchAttribValue ) ) )

	mov	edx, DWORD PTR _pchAttribValue$[ebp]
	push	edx
	call	_fnContainsSpecialChar@4
	mov	DWORD PTR _lCharCount$1[ebp], eax
	cmp	DWORD PTR _lCharCount$1[ebp], 0
	je	$LN10@fnWriteAtt

; 994  :       {
; 995  :          zPCHAR pch;
; 996  : 
; 997  :          // We need to convert some characters into XML entities.  For
; 998  :          // example, change '&' into '&amp;'.
; 999  : 
; 1000 :          // First create a temp buffer.  Make sure it's big enough to
; 1001 :          // handle the buffer plus conversions.
; 1002 :          if ( lTempBufferLth < ulLth + lCharCount * 6 )

	imul	eax, DWORD PTR _lCharCount$1[ebp], 6
	add	eax, DWORD PTR _ulLth$[ebp]
	cmp	DWORD PTR _lTempBufferLth$[ebp], eax
	jae	SHORT $LN13@fnWriteAtt

; 1003 :          {
; 1004 :             hTempValueBuffer = SysAllocMemory( &pchTempValueBuffer,

	push	0
	push	0
	push	0
	imul	ecx, DWORD PTR _lCharCount$1[ebp], 6
	add	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchTempValueBuffer$[ebp]
	push	edx
	call	_SysAllocMemory@20
	mov	DWORD PTR _hTempValueBuffer$[ebp], eax

; 1005 :                                                ulLth + lCharCount * 6,
; 1006 :                                                0, 0, 0 );
; 1007 :             if ( pchTempValueBuffer == 0 )

	cmp	DWORD PTR _pchTempValueBuffer$[ebp], 0
	jne	SHORT $LN14@fnWriteAtt

; 1008 :                goto EndOfFunction;

	jmp	$EndOfFunction$32
$LN14@fnWriteAtt:

; 1009 : 
; 1010 :             lTempBufferLth = ulLth + lCharCount * 6;

	imul	eax, DWORD PTR _lCharCount$1[ebp], 6
	add	eax, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR _lTempBufferLth$[ebp], eax
$LN13@fnWriteAtt:

; 1011 :          }
; 1012 : 
; 1013 :          // Now copy chars over, converting special ones.
; 1014 :          for ( pch = pchTempValueBuffer;

	mov	ecx, DWORD PTR _pchTempValueBuffer$[ebp]
	mov	DWORD PTR _pch$2[ebp], ecx
	jmp	SHORT $LN4@fnWriteAtt
$LN2@fnWriteAtt:

; 1016 :                pchAttribValue++ )

	mov	edx, DWORD PTR _pchAttribValue$[ebp]
	add	edx, 1
	mov	DWORD PTR _pchAttribValue$[ebp], edx
$LN4@fnWriteAtt:

; 1015 :                *pchAttribValue;

	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	$LN3@fnWriteAtt

; 1017 :          {
; 1018 :             switch ( *pchAttribValue )

	mov	edx, DWORD PTR _pchAttribValue$[ebp]
	movsx	eax, BYTE PTR [edx]
	mov	DWORD PTR tv130[ebp], eax
	mov	ecx, DWORD PTR tv130[ebp]
	sub	ecx, 9
	mov	DWORD PTR tv130[ebp], ecx
	cmp	DWORD PTR tv130[ebp], 53		; 00000035H
	ja	$LN21@fnWriteAtt
	mov	edx, DWORD PTR tv130[ebp]
	movzx	eax, BYTE PTR $LN30@fnWriteAtt[edx]
	jmp	DWORD PTR $LN31@fnWriteAtt[eax*4]
$LN15@fnWriteAtt:

; 1019 :             {
; 1020 :                case '&':
; 1021 :                   *pch++ = '&';

	mov	ecx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [ecx], 38			; 00000026H
	mov	edx, DWORD PTR _pch$2[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$2[ebp], edx

; 1022 :                   *pch++ = 'a';

	mov	eax, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [eax], 97			; 00000061H
	mov	ecx, DWORD PTR _pch$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$2[ebp], ecx

; 1023 :                   *pch++ = 'm';

	mov	edx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [edx], 109			; 0000006dH
	mov	eax, DWORD PTR _pch$2[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$2[ebp], eax

; 1024 :                   *pch++ = 'p';

	mov	ecx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [ecx], 112			; 00000070H
	mov	edx, DWORD PTR _pch$2[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$2[ebp], edx

; 1025 :                   *pch++ = ';';

	mov	eax, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [eax], 59			; 0000003bH
	mov	ecx, DWORD PTR _pch$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$2[ebp], ecx

; 1026 :                   break;

	jmp	$LN5@fnWriteAtt
$LN16@fnWriteAtt:

; 1027 : 
; 1028 :                case '<':
; 1029 :                   *pch++ = '&';

	mov	edx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _pch$2[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$2[ebp], eax

; 1030 :                   *pch++ = 'l';

	mov	ecx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [ecx], 108			; 0000006cH
	mov	edx, DWORD PTR _pch$2[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$2[ebp], edx

; 1031 :                   *pch++ = 't';

	mov	eax, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [eax], 116			; 00000074H
	mov	ecx, DWORD PTR _pch$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$2[ebp], ecx

; 1032 :                   *pch++ = ';';

	mov	edx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
	mov	eax, DWORD PTR _pch$2[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$2[ebp], eax

; 1033 :                   break;

	jmp	$LN5@fnWriteAtt
$LN17@fnWriteAtt:

; 1034 : 
; 1035 :                case '>':
; 1036 :                   *pch++ = '&';

	mov	ecx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [ecx], 38			; 00000026H
	mov	edx, DWORD PTR _pch$2[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$2[ebp], edx

; 1037 :                   *pch++ = 'g';

	mov	eax, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [eax], 103			; 00000067H
	mov	ecx, DWORD PTR _pch$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$2[ebp], ecx

; 1038 :                   *pch++ = 't';

	mov	edx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [edx], 116			; 00000074H
	mov	eax, DWORD PTR _pch$2[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$2[ebp], eax

; 1039 :                   *pch++ = ';';

	mov	ecx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
	mov	edx, DWORD PTR _pch$2[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$2[ebp], edx

; 1040 :                   break;

	jmp	$LN5@fnWriteAtt
$LN18@fnWriteAtt:

; 1041 : 
; 1042 :                case '\'':
; 1043 :                   *pch++ = '&';

	mov	eax, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _pch$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$2[ebp], ecx

; 1044 :                   *pch++ = 'a';

	mov	edx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [edx], 97			; 00000061H
	mov	eax, DWORD PTR _pch$2[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$2[ebp], eax

; 1045 :                   *pch++ = 'p';

	mov	ecx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [ecx], 112			; 00000070H
	mov	edx, DWORD PTR _pch$2[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$2[ebp], edx

; 1046 :                   *pch++ = 'o';

	mov	eax, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [eax], 111			; 0000006fH
	mov	ecx, DWORD PTR _pch$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$2[ebp], ecx

; 1047 :                   *pch++ = 's';

	mov	edx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [edx], 115			; 00000073H
	mov	eax, DWORD PTR _pch$2[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$2[ebp], eax

; 1048 :                   *pch++ = ';';

	mov	ecx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
	mov	edx, DWORD PTR _pch$2[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$2[ebp], edx

; 1049 :                   break;

	jmp	$LN5@fnWriteAtt
$LN19@fnWriteAtt:

; 1050 : 
; 1051 :                case '\"':
; 1052 :                   *pch++ = '&';

	mov	eax, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _pch$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$2[ebp], ecx

; 1053 :                   *pch++ = 'q';

	mov	edx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [edx], 113			; 00000071H
	mov	eax, DWORD PTR _pch$2[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$2[ebp], eax

; 1054 :                   *pch++ = 'u';

	mov	ecx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [ecx], 117			; 00000075H
	mov	edx, DWORD PTR _pch$2[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$2[ebp], edx

; 1055 :                   *pch++ = 'o';

	mov	eax, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [eax], 111			; 0000006fH
	mov	ecx, DWORD PTR _pch$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$2[ebp], ecx

; 1056 :                   *pch++ = 't';

	mov	edx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [edx], 116			; 00000074H
	mov	eax, DWORD PTR _pch$2[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$2[ebp], eax

; 1057 :                   *pch++ = ';';

	mov	ecx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
	mov	edx, DWORD PTR _pch$2[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$2[ebp], edx

; 1058 :                   break;

	jmp	$LN5@fnWriteAtt
$LN20@fnWriteAtt:

; 1059 : 
; 1060 :                case '\n':
; 1061 :                case '\r':
; 1062 :                case '\t':
; 1063 :                   *pch++ = *pchAttribValue;

	mov	eax, DWORD PTR _pch$2[ebp]
	mov	ecx, DWORD PTR _pchAttribValue$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pch$2[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$2[ebp], eax

; 1064 :                   break;

	jmp	$LN5@fnWriteAtt
$LN21@fnWriteAtt:

; 1065 : 
; 1066 :                default:
; 1067 :                   if ( *pchAttribValue < 32 || *pchAttribValue > 127 )

	mov	ecx, DWORD PTR _pchAttribValue$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jl	SHORT $LN24@fnWriteAtt
	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 127				; 0000007fH
	jle	$LN22@fnWriteAtt
$LN24@fnWriteAtt:

; 1068 :                   {
; 1069 :                      // Convert the char to '&#ddd;' where 'ddd' is its ASCII value.
; 1070 :                      *pch++ = '&';

	mov	edx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _pch$2[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$2[ebp], eax

; 1071 :                      *pch++ = '#';

	mov	ecx, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [ecx], 35			; 00000023H
	mov	edx, DWORD PTR _pch$2[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$2[ebp], edx

; 1072 :                      zltoa( (zLONG) (zUCHAR) *pchAttribValue, pch );

	push	10					; 0000000aH
	mov	eax, DWORD PTR _pch$2[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchAttribValue$[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$LN7@fnWriteAtt:

; 1073 :                      while ( *++pch );       // Skip to null terminator.

	mov	eax, DWORD PTR _pch$2[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$2[ebp], eax
	mov	ecx, DWORD PTR _pch$2[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	SHORT $LN8@fnWriteAtt
	jmp	SHORT $LN7@fnWriteAtt
$LN8@fnWriteAtt:

; 1074 :                      *pch++ = ';';

	mov	eax, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [eax], 59			; 0000003bH
	mov	ecx, DWORD PTR _pch$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$2[ebp], ecx

; 1075 :                   }

	jmp	SHORT $LN5@fnWriteAtt
$LN22@fnWriteAtt:

; 1076 :                   else
; 1077 :                      *pch++ = *pchAttribValue;

	mov	edx, DWORD PTR _pch$2[ebp]
	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pch$2[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$2[ebp], edx
$LN5@fnWriteAtt:

; 1078 : 
; 1079 :                   break;
; 1080 : 
; 1081 :             } // switch ( *pchAttribValue )...
; 1082 : 
; 1083 :          } // for...

	jmp	$LN2@fnWriteAtt
$LN3@fnWriteAtt:

; 1084 : 
; 1085 :          // Now that we've translated the attribute's value into the
; 1086 :          // temp buffer set attrib value ptr to point to the buffer.
; 1087 :          *pch++ = 0;

	mov	eax, DWORD PTR _pch$2[ebp]
	mov	BYTE PTR [eax], 0
	mov	ecx, DWORD PTR _pch$2[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$2[ebp], ecx

; 1088 :          ulLth = (zLONG) ( pch - pchTempValueBuffer ) - 1;

	mov	edx, DWORD PTR _pch$2[ebp]
	sub	edx, DWORD PTR _pchTempValueBuffer$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ulLth$[ebp], edx

; 1089 :          pchAttribValue = pchTempValueBuffer;

	mov	eax, DWORD PTR _pchTempValueBuffer$[ebp]
	mov	DWORD PTR _pchAttribValue$[ebp], eax
$LN10@fnWriteAtt:

; 1090 : 
; 1091 :       } // if contains special chars
; 1092 : 
; 1093 :    } // pchAttribValue non-NULL
; 1094 : 
; 1095 :    if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_STARTATTRIB,
; 1096 :                                    szAttribTag, 0, nLevel,
; 1097 :                                    lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+10424]
	push	edx
	movzx	eax, WORD PTR _nLevel$[ebp]
	push	eax
	push	0
	lea	ecx, DWORD PTR _szAttribTag$[ebp]
	push	ecx
	push	16					; 00000010H
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+10420]
	call	ecx
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN25@fnWriteAtt

; 1098 :    {
; 1099 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$32
$LN25@fnWriteAtt:

; 1100 :    }
; 1101 : 
; 1102 :    if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_ATTRIBVALUE,
; 1103 :                                    pchAttribValue, ulLth, nLevel,
; 1104 :                                    lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+10424]
	push	ecx
	movzx	edx, WORD PTR _nLevel$[ebp]
	push	edx
	mov	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchAttribValue$[ebp]
	push	ecx
	push	64					; 00000040H
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+10420]
	call	ecx
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN26@fnWriteAtt

; 1105 :    {
; 1106 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$32
$LN26@fnWriteAtt:

; 1107 :    }
; 1108 : 
; 1109 :    // Close the attribute value.
; 1110 :    zsprintf( szAttribTag, "</%s>", pchAttribName );

	mov	eax, DWORD PTR _pchAttribName$[ebp]
	push	eax
	push	OFFSET $SG14048
	lea	ecx, DWORD PTR _szAttribTag$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1111 : 
; 1112 :    if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_ENDATTRIB,
; 1113 :                                    szAttribTag, 0, nLevel,
; 1114 :                                    lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+10424]
	push	eax
	movzx	ecx, WORD PTR _nLevel$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _szAttribTag$[ebp]
	push	edx
	push	32					; 00000020H
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+10420]
	call	edx
$EndOfFunction$32:

; 1115 :    {
; 1116 :       goto EndOfFunction;
; 1117 :    }
; 1118 : 
; 1119 : EndOfFunction:
; 1120 :    if ( pchTempValueBuffer )

	cmp	DWORD PTR _pchTempValueBuffer$[ebp], 0
	je	SHORT $LN28@fnWriteAtt

; 1121 :       SysFreeMemory( hTempValueBuffer );

	mov	ecx, DWORD PTR _hTempValueBuffer$[ebp]
	push	ecx
	call	_SysFreeMemory@4
$LN28@fnWriteAtt:

; 1122 : 
; 1123 :    return( nReturn );

	mov	ax, WORD PTR _nReturn$[ebp]

; 1124 : 
; 1125 : } // fnWriteAttribEntry

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
	npad	1
$LN31@fnWriteAtt:
	DD	$LN20@fnWriteAtt
	DD	$LN19@fnWriteAtt
	DD	$LN15@fnWriteAtt
	DD	$LN18@fnWriteAtt
	DD	$LN16@fnWriteAtt
	DD	$LN17@fnWriteAtt
	DD	$LN21@fnWriteAtt
$LN30@fnWriteAtt:
	DB	0
	DB	0
	DB	6
	DB	6
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	2
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	5
_fnWriteAttribEntry@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_hEntityInstance$1 = -68				; size = 4
_hViewEntity$ = -64					; size = 4
tv305 = -60						; size = 4
tv304 = -56						; size = 4
_pchEntityName$ = -52					; size = 4
_lpAbstractChildEntity$ = -48				; size = 4
_lpSrchSelectedInstance$2 = -44				; size = 4
_pchRealEntityName$ = -40				; size = 4
_lpViewEntityCsr$3 = -36				; size = 4
_lpParent$4 = -32					; size = 4
_lpAbstractChild$ = -28					; size = 4
_lpViewEntity$ = -24					; size = 4
_bEntityNameNeeded$ = -17				; size = 1
_szIncreFlags$5 = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_lpWriteInfo$ = 12					; size = 4
_lpEntityInstance$ = 16					; size = 4
_fnWriteEntityStartTag@12 PROC

; 715  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 716  :    LPVIEWENTITY     hViewEntity = lpEntityInstance->hViewEntity;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	mov	DWORD PTR _hViewEntity$[ebp], ecx

; 717  :    LPVIEWENTITY     lpViewEntity = zGETPTR( hViewEntity );

	mov	edx, DWORD PTR _hViewEntity$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 718  :    zPCHAR           pchEntityName = lpViewEntity->szName;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	mov	DWORD PTR _pchEntityName$[ebp], eax

; 719  :    zPCHAR           pchRealEntityName;
; 720  :    LPENTITYINSTANCE lpAbstractChild = 0;

	mov	DWORD PTR _lpAbstractChild$[ebp], 0

; 721  :    LPVIEWENTITY     lpAbstractChildEntity;
; 722  :    zBOOL            bEntityNameNeeded = FALSE;

	mov	BYTE PTR _bEntityNameNeeded$[ebp], 0

; 723  : 
; 724  :    if ( lpViewEntity->szXML_Name[ 0 ] )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+47]
	test	ecx, ecx
	je	SHORT $LN13@fnWriteEnt

; 725  :       pchRealEntityName = lpViewEntity->szXML_Name;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 47					; 0000002fH
	mov	DWORD PTR _pchRealEntityName$[ebp], edx
	jmp	SHORT $LN14@fnWriteEnt
$LN13@fnWriteEnt:

; 726  :    else
; 727  :       pchRealEntityName = lpViewEntity->szName;

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	add	eax, 14					; 0000000eH
	mov	DWORD PTR _pchRealEntityName$[ebp], eax
$LN14@fnWriteEnt:

; 728  : 
; 729  :    // Check to make sure we have written the start tag for the parent.  If we
; 730  :    // are only writing entities that are updated it's possible we haven't.
; 731  :    if ( lpEntityInstance->hParent &&
; 732  :         lpEntityInstance->nLevel > lpWriteInfo->lpSubobjectRoot->nLevel &&

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+30], 0
	je	SHORT $LN15@fnWriteEnt
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	movsx	ecx, WORD PTR [edx+58]
	cmp	eax, ecx
	jle	SHORT $LN15@fnWriteEnt
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	cmp	DWORD PTR [ecx+eax*4+10016], 0
	jne	SHORT $LN15@fnWriteEnt

; 733  :         lpWriteInfo->pchEntityName[ lpEntityInstance->nLevel - 1 ] == 0 )
; 734  :    {
; 735  :       // The entity name at this level is 0 so we haven't written the parent's start tag
; 736  :       // yet.  Do it now.
; 737  :       fnWriteEntityStartTag( lpTaskView, lpWriteInfo, zGETPTR( lpEntityInstance->hParent ) );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+30]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	call	_fnWriteEntityStartTag@12
$LN15@fnWriteEnt:

; 738  :    }
; 739  : 
; 740  :    // If the entity is an abstract child then the attribute values have
; 741  :    // already been written so we don't need to write a start tag.
; 742  :    if ( lpViewEntity->bAbstractChild )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	je	SHORT $LN16@fnWriteEnt

; 743  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnWriteEnt
$LN16@fnWriteEnt:

; 744  : 
; 745  :    // If the entity is flagged as an abstract entity we need to do some
; 746  :    // extra processing so we can "fold up" the abstract child entity.
; 747  :    if ( lpViewEntity->bAbstract )

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	shr	eax, 11					; 0000000bH
	and	eax, 1
	je	$LN17@fnWriteEnt

; 748  :    {
; 749  :       // Search for the abstract child.
; 750  :       for ( lpAbstractChild = zGETPTR( lpEntityInstance->hNextHier );

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAbstractChild$[ebp], eax
	jmp	SHORT $LN4@fnWriteEnt
$LN2@fnWriteEnt:

; 752  :             lpAbstractChild = zGETPTR( lpAbstractChild->hNextHier ) )

	mov	eax, DWORD PTR _lpAbstractChild$[ebp]
	mov	ecx, DWORD PTR [eax+14]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAbstractChild$[ebp], eax
$LN4@fnWriteEnt:

; 751  :             lpAbstractChild;

	cmp	DWORD PTR _lpAbstractChild$[ebp], 0
	je	$LN3@fnWriteEnt

; 753  :       {
; 754  :          // If the child instance is at the same level as the current instance
; 755  :          // then there are no more children of lpEntityInstance.
; 756  :          if ( lpAbstractChild->nLevel <= lpEntityInstance->nLevel )

	mov	edx, DWORD PTR _lpAbstractChild$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	cmp	eax, edx
	jg	SHORT $LN18@fnWriteEnt

; 757  :          {
; 758  :             lpAbstractChild = 0;

	mov	DWORD PTR _lpAbstractChild$[ebp], 0

; 759  :             break;

	jmp	$LN3@fnWriteEnt
$LN18@fnWriteEnt:

; 760  :          }
; 761  : 
; 762  :          // If lpAbstractChild is not a direct child of lpEntityInstance then
; 763  :          // skip it (and its twins if it has any).
; 764  :          if ( lpAbstractChild->nLevel > lpEntityInstance->nLevel + 1 )

	mov	eax, DWORD PTR _lpAbstractChild$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	add	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN19@fnWriteEnt
$LN5@fnWriteEnt:

; 765  :          {
; 766  :             while ( lpAbstractChild->hNextTwin )

	mov	ecx, DWORD PTR _lpAbstractChild$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	SHORT $LN6@fnWriteEnt

; 767  :                lpAbstractChild = zGETPTR( lpAbstractChild->hNextTwin );

	mov	edx, DWORD PTR _lpAbstractChild$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAbstractChild$[ebp], eax
	jmp	SHORT $LN5@fnWriteEnt
$LN6@fnWriteEnt:

; 768  : 
; 769  :             continue;

	jmp	SHORT $LN2@fnWriteEnt
$LN19@fnWriteEnt:

; 770  :          }
; 771  : 
; 772  :          lpAbstractChildEntity = zGETPTR( lpAbstractChild->hViewEntity );

	mov	ecx, DWORD PTR _lpAbstractChild$[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAbstractChildEntity$[ebp], eax

; 773  :          if ( lpAbstractChildEntity->bAbstractChild )

	mov	eax, DWORD PTR _lpAbstractChildEntity$[ebp]
	mov	ecx, DWORD PTR [eax+239]
	shr	ecx, 12					; 0000000cH
	and	ecx, 1
	je	SHORT $LN20@fnWriteEnt

; 774  :          {
; 775  :             // We found what we want.
; 776  :             pchEntityName = lpAbstractChildEntity->szName;

	mov	edx, DWORD PTR _lpAbstractChildEntity$[ebp]
	add	edx, 14					; 0000000eH
	mov	DWORD PTR _pchEntityName$[ebp], edx

; 777  :             if ( lpAbstractChildEntity->szXML_Name[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpAbstractChildEntity$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+47]
	test	eax, eax
	je	SHORT $LN21@fnWriteEnt

; 778  :                pchRealEntityName = lpAbstractChildEntity->szXML_Name;

	mov	ecx, DWORD PTR _lpAbstractChildEntity$[ebp]
	add	ecx, 47					; 0000002fH
	mov	DWORD PTR _pchRealEntityName$[ebp], ecx
	jmp	SHORT $LN22@fnWriteEnt
$LN21@fnWriteEnt:

; 779  :             else
; 780  :                pchRealEntityName = lpAbstractChildEntity->szName;

	mov	edx, DWORD PTR _lpAbstractChildEntity$[ebp]
	add	edx, 14					; 0000000eH
	mov	DWORD PTR _pchRealEntityName$[ebp], edx
$LN22@fnWriteEnt:

; 781  : 
; 782  :             // Because we are going to "fold up" the abstract entity we
; 783  :             // need to store the Abstract entity name in the XML
; 784  :             bEntityNameNeeded = TRUE;

	mov	BYTE PTR _bEntityNameNeeded$[ebp], 1

; 785  : 
; 786  :             break;

	jmp	SHORT $LN3@fnWriteEnt
$LN20@fnWriteEnt:

; 787  :          }
; 788  :       }

	jmp	$LN2@fnWriteEnt
$LN3@fnWriteEnt:

; 789  : 
; 790  :       // Check to see if we found an abstract child of the entity.
; 791  :       if ( lpAbstractChild == 0 )

	cmp	DWORD PTR _lpAbstractChild$[ebp], 0
	jne	SHORT $LN17@fnWriteEnt

; 792  :       {
; 793  :          // No abstract child.  This means we are going to use the regular
; 794  :          // name of the abstract entity (i.e. not fold up). However, if the
; 795  :          // abstract entity is *recursive* then we will use the recursive
; 796  :          // parent name instead.
; 797  :          if ( lpViewEntity->bRecursive )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 11					; 0000000bH
	and	ecx, 1
	je	SHORT $LN17@fnWriteEnt

; 798  :          {
; 799  :             LPVIEWENTITY lpParent;
; 800  : 
; 801  :             // Find the recursive parent.
; 802  :             for ( lpParent = zGETPTR( lpViewEntity->hParent );

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$4[ebp], eax
	jmp	SHORT $LN9@fnWriteEnt
$LN7@fnWriteEnt:

; 804  :                   lpParent = zGETPTR( lpParent->hParent ) )

	mov	ecx, DWORD PTR _lpParent$4[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpParent$4[ebp], eax
$LN9@fnWriteEnt:

; 803  :                   lpParent->bRecursivePar == FALSE;

	mov	eax, DWORD PTR _lpParent$4[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 29					; 0000001dH
	and	ecx, 1
	jne	SHORT $LN8@fnWriteEnt

; 805  :             {
; 806  :                // Nothing needs to be done here.
; 807  :             }

	jmp	SHORT $LN7@fnWriteEnt
$LN8@fnWriteEnt:

; 808  : 
; 809  :             // Use the recursive parent name as the XML entity name.
; 810  :             pchEntityName = lpParent->szName;

	mov	edx, DWORD PTR _lpParent$4[ebp]
	add	edx, 14					; 0000000eH
	mov	DWORD PTR _pchEntityName$[ebp], edx

; 811  :             if ( lpParent->szXML_Name[ 0 ] )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpParent$4[ebp]
	movsx	eax, BYTE PTR [edx+ecx+47]
	test	eax, eax
	je	SHORT $LN25@fnWriteEnt

; 812  :                pchRealEntityName = lpParent->szXML_Name;

	mov	ecx, DWORD PTR _lpParent$4[ebp]
	add	ecx, 47					; 0000002fH
	mov	DWORD PTR _pchRealEntityName$[ebp], ecx
	jmp	SHORT $LN26@fnWriteEnt
$LN25@fnWriteEnt:

; 813  :             else
; 814  :                pchRealEntityName = lpParent->szName;

	mov	edx, DWORD PTR _lpParent$4[ebp]
	add	edx, 14					; 0000000eH
	mov	DWORD PTR _pchRealEntityName$[ebp], edx
$LN26@fnWriteEnt:

; 815  : 
; 816  :             // Set flag to indicate we want the abstract entity's name
; 817  :             // in the XML.
; 818  :             bEntityNameNeeded = TRUE;

	mov	BYTE PTR _bEntityNameNeeded$[ebp], 1
$LN17@fnWriteEnt:

; 819  :          }
; 820  : 
; 821  :       } //if ( lpAbstactChild == 0 )...
; 822  : 
; 823  :    } // if ( lpViewEntity->bAbstract )...
; 824  : 
; 825  :    // Set entity cursor to point to lpEntityInstance.
; 826  :    fnEstablishViewForInstance( lpWriteInfo->vTemp, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 827  : 
; 828  :    // Build Entity tag.
; 829  :    zsprintf( lpWriteInfo->szBuffer, "<%s", pchRealEntityName );

	mov	eax, DWORD PTR _pchRealEntityName$[ebp]
	push	eax
	push	OFFSET $SG13959
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 830  : 
; 831  :    // Add key attributes as Identifiers of the entity (based on control flag).
; 832  :    if ( lpWriteInfo->lControl & zXML_KEYATTRIBSASIDENT )

	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 16					; 00000010H
	je	SHORT $LN27@fnWriteEnt

; 833  :       fnAppendKeyAttribs( lpWriteInfo, lpViewEntity );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	push	edx
	call	_fnAppendKeyAttribs@8
$LN27@fnWriteEnt:

; 834  : 
; 835  :    // Add Zeidon info if needed.
; 836  :    if ( lpWriteInfo->lControl & zXML_ZEIDONINFO )

	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 1
	je	SHORT $LN28@fnWriteEnt

; 837  :    {
; 838  :       zsprintf( &lpWriteInfo->szBuffer[ zstrlen( lpWriteInfo->szBuffer ) ],

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	push	eax
	push	OFFSET $SG13962
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	lea	eax, DWORD PTR [edx+eax+20]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 839  :                 " zLevel=\"%ld\"", (zLONG) lpEntityInstance->nLevel );
; 840  : 
; 841  :       // If we have decided that we need the LOD entity name then add it.
; 842  :       if ( bEntityNameNeeded )

	movzx	ecx, BYTE PTR _bEntityNameNeeded$[ebp]
	test	ecx, ecx
	je	SHORT $LN28@fnWriteEnt

; 843  :          zsprintf( &lpWriteInfo->szBuffer[ zstrlen( lpWriteInfo->szBuffer ) ],

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	add	edx, 14					; 0000000eH
	push	edx
	push	OFFSET $SG13964
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN28@fnWriteEnt:

; 844  :                    " zEName=\"%s\"", lpViewEntity->szName );
; 845  :    }
; 846  : 
; 847  :    // Add incremental update flags if so specified.
; 848  :    if ( lpWriteInfo->lControl & zXML_INCREFLAGS )

	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 2
	je	$LN30@fnWriteEnt

; 849  :    {
; 850  :       zCHAR szIncreFlags[ 10 ] = "........";

	mov	edx, DWORD PTR $SG13966
	mov	DWORD PTR _szIncreFlags$5[ebp], edx
	mov	eax, DWORD PTR $SG13966+4
	mov	DWORD PTR _szIncreFlags$5[ebp+4], eax
	mov	cl, BYTE PTR $SG13966+8
	mov	BYTE PTR _szIncreFlags$5[ebp+8], cl
	xor	edx, edx
	mov	BYTE PTR _szIncreFlags$5[ebp+9], dl

; 851  : 
; 852  :       if ( lpEntityInstance->u.nInd.bHangingEntity )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	and	ecx, 1
	je	SHORT $LN31@fnWriteEnt

; 853  :          szIncreFlags[ ENTITY_FLAGS_HANGING_IDX ] = 'Y';

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _szIncreFlags$5[ebp+eax], 89	; 00000059H
$LN31@fnWriteEnt:

; 854  :       if ( lpEntityInstance->u.nInd.bCreated )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN32@fnWriteEnt

; 855  :          szIncreFlags[ ENTITY_FLAGS_CREATED_IDX ] = 'Y';

	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR _szIncreFlags$5[ebp+eax], 89	; 00000059H
$LN32@fnWriteEnt:

; 856  :       if ( lpEntityInstance->u.nInd.bUpdated )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 2
	and	edx, 1
	je	SHORT $LN33@fnWriteEnt

; 857  :          szIncreFlags[ ENTITY_FLAGS_UPDATED_IDX ] = 'Y';

	mov	eax, 1
	shl	eax, 1
	mov	BYTE PTR _szIncreFlags$5[ebp+eax], 89	; 00000059H
$LN33@fnWriteEnt:

; 858  :       if ( lpEntityInstance->u.nInd.bDeleted )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	je	SHORT $LN34@fnWriteEnt

; 859  :          szIncreFlags[ ENTITY_FLAGS_DELETED_IDX ] = 'Y';

	mov	eax, 1
	imul	ecx, eax, 3
	mov	BYTE PTR _szIncreFlags$5[ebp+ecx], 89	; 00000059H
$LN34@fnWriteEnt:

; 860  :       if ( lpEntityInstance->u.nInd.bExcluded )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	je	SHORT $LN35@fnWriteEnt

; 861  :          szIncreFlags[ ENTITY_FLAGS_EXCLUDED_IDX ] = 'Y';

	mov	ecx, 1
	shl	ecx, 2
	mov	BYTE PTR _szIncreFlags$5[ebp+ecx], 89	; 00000059H
$LN35@fnWriteEnt:

; 862  :       if ( lpEntityInstance->u.nInd.bIncluded )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 5
	and	eax, 1
	je	SHORT $LN36@fnWriteEnt

; 863  :          szIncreFlags[ ENTITY_FLAGS_INCLUDED_IDX ] = 'Y';

	mov	ecx, 1
	imul	edx, ecx, 5
	mov	BYTE PTR _szIncreFlags$5[ebp+edx], 89	; 00000059H
$LN36@fnWriteEnt:

; 864  :       if ( lpEntityInstance->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN37@fnWriteEnt

; 865  :          szIncreFlags[ ENTITY_FLAGS_HIDDEN_IDX ] = 'Y';

	mov	edx, 1
	imul	eax, edx, 6
	mov	BYTE PTR _szIncreFlags$5[ebp+eax], 89	; 00000059H
$LN37@fnWriteEnt:

; 866  :       if ( lpEntityInstance->u.nInd.bTemporal )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 11					; 0000000bH
	and	edx, 1
	je	SHORT $LN38@fnWriteEnt

; 867  :          szIncreFlags[ ENTITY_FLAGS_TEMPORAL_IDX ] = 'Y';

	mov	eax, 1
	imul	ecx, eax, 7
	mov	BYTE PTR _szIncreFlags$5[ebp+ecx], 89	; 00000059H
$LN38@fnWriteEnt:

; 868  : 
; 869  :       // Don't bother writing the incre flags if none are set.
; 870  :       if ( zstrcmp( szIncreFlags, "........" ) != 0 )

	movsx	edx, BYTE PTR _szIncreFlags$5[ebp]
	movsx	eax, BYTE PTR $SG13976
	cmp	edx, eax
	jne	SHORT $LN52@fnWriteEnt
	push	OFFSET $SG13977
	lea	ecx, DWORD PTR _szIncreFlags$5[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv305[ebp], eax
	jmp	SHORT $LN53@fnWriteEnt
$LN52@fnWriteEnt:
	movsx	edx, BYTE PTR _szIncreFlags$5[ebp]
	movsx	eax, BYTE PTR $SG13978
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN50@fnWriteEnt
	mov	DWORD PTR tv304[ebp], 1
	jmp	SHORT $LN51@fnWriteEnt
$LN50@fnWriteEnt:
	mov	DWORD PTR tv304[ebp], -1
$LN51@fnWriteEnt:
	mov	ecx, DWORD PTR tv304[ebp]
	mov	DWORD PTR tv305[ebp], ecx
$LN53@fnWriteEnt:
	cmp	DWORD PTR tv305[ebp], 0
	je	SHORT $LN30@fnWriteEnt

; 871  :          zsprintf( &lpWriteInfo->szBuffer[ zstrlen( lpWriteInfo->szBuffer ) ],

	lea	edx, DWORD PTR _szIncreFlags$5[ebp]
	push	edx
	push	OFFSET $SG13979
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN30@fnWriteEnt:

; 872  :                    " zIncreFlags=\"%s\"", szIncreFlags );
; 873  :    }
; 874  : 
; 875  :    // Add entity key if so specified.
; 876  :    if ( lpWriteInfo->lControl & zXML_ENTITYKEYS )

	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 8
	je	SHORT $LN40@fnWriteEnt

; 877  :    {
; 878  :       // Append the entity key.
; 879  :       zsprintf( &lpWriteInfo->szBuffer[ zstrlen( lpWriteInfo->szBuffer ) ],

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+50]
	push	eax
	push	OFFSET $SG13981
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	_strlen
	add	esp, 4
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	lea	eax, DWORD PTR [edx+eax+20]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN40@fnWriteEnt:

; 880  :                 " zEKey=\"%lx\"", lpEntityInstance->ulKey );
; 881  :    }
; 882  : 
; 883  :    // Write cursor positions if requested.
; 884  :    if ( lpWriteInfo->lControl & zXML_SAVECURSORPOSITION ||

	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 64					; 00000040H
	jne	SHORT $LN42@fnWriteEnt
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 1
	je	$LN41@fnWriteEnt
$LN42@fnWriteEnt:

; 885  :         lpWriteInfo->lControl & zXML_ZEIDONINFO )
; 886  :    {
; 887  :       LPENTITYINSTANCE   hEntityInstance = zGETHNDL( lpEntityInstance );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	DWORD PTR _g_pfnGetHndl
	mov	DWORD PTR _hEntityInstance$1[ebp], eax

; 888  :       LPVIEWENTITYCSR    lpViewEntityCsr;
; 889  :       LPSELECTEDINSTANCE lpSrchSelectedInstance;
; 890  : 
; 891  :       // Check to see if the current lpEntityInstance is selected by a csr.
; 892  :       // First find the cursor pointer.  If the entity is not recursive, then
; 893  :       // we can just get the cursor by quick addition.
; 894  :       if ( lpViewEntity->bRecursiveSt )

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+235]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN43@fnWriteEnt

; 895  :       {
; 896  :          lpViewEntityCsr = zGETPTR( lpWriteInfo->lpViewCsr->hRootViewEntityCsr );

	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+18]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$3[ebp], eax

; 897  :          lpViewEntityCsr += lpViewEntity->nHierNbr - lpViewEntityCsr->nHierNbr;

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	movsx	eax, WORD PTR [edx+217]
	mov	ecx, DWORD PTR _lpViewEntityCsr$3[ebp]
	movsx	edx, WORD PTR [ecx+24]
	sub	eax, edx
	imul	eax, eax, 30
	add	eax, DWORD PTR _lpViewEntityCsr$3[ebp]
	mov	DWORD PTR _lpViewEntityCsr$3[ebp], eax

; 898  :       }

	jmp	SHORT $LN44@fnWriteEnt
$LN43@fnWriteEnt:

; 899  :       else
; 900  :       {
; 901  :          lpViewEntityCsr = zGETPTR( lpWriteInfo->lpViewCsr->hFirstOD_EntityCsr );

	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntityCsr$3[ebp], eax

; 902  :          lpViewEntityCsr += lpViewEntity->nHierNbr - 1;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	movsx	edx, WORD PTR [ecx+217]
	sub	edx, 1
	imul	eax, edx, 30
	add	eax, DWORD PTR _lpViewEntityCsr$3[ebp]
	mov	DWORD PTR _lpViewEntityCsr$3[ebp], eax
$LN44@fnWriteEnt:

; 903  : 
; 904  :       }
; 905  : 
; 906  :       if ( zGETPTR( lpViewEntityCsr->hEntityInstance ) == lpEntityInstance )

	mov	ecx, DWORD PTR _lpViewEntityCsr$3[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	cmp	eax, DWORD PTR _lpEntityInstance$[ebp]
	jne	SHORT $LN45@fnWriteEnt

; 907  :       {
; 908  :          zsprintf( &lpWriteInfo->szBuffer[ zstrlen( lpWriteInfo->szBuffer ) ],

	push	OFFSET $SG13987
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	push	edx
	call	_sprintf
	add	esp, 8
$LN45@fnWriteEnt:

; 909  :                    " zCursor=\"Y\"" );
; 910  :       }
; 911  : 
; 912  :       // Now check to see if the entity is selected.
; 913  :       for ( lpSrchSelectedInstance =

	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR [ecx+42]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchSelectedInstance$2[ebp], eax
	jmp	SHORT $LN12@fnWriteEnt
$LN10@fnWriteEnt:

; 916  :             lpSrchSelectedInstance =

	mov	eax, DWORD PTR _lpSrchSelectedInstance$2[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSrchSelectedInstance$2[ebp], eax
$LN12@fnWriteEnt:

; 914  :                       zGETPTR( lpWriteInfo->lpViewCsr->hFirstSelectedInstance );
; 915  :             lpSrchSelectedInstance;

	cmp	DWORD PTR _lpSrchSelectedInstance$2[ebp], 0
	je	SHORT $LN41@fnWriteEnt

; 917  :                       zGETPTR( lpSrchSelectedInstance->hNextSelectedInstance ) )
; 918  :       {
; 919  :          // Check to see if the current EI is selected.
; 920  :          if ( hEntityInstance != lpSrchSelectedInstance->xEntityInstance )

	mov	edx, DWORD PTR _lpSrchSelectedInstance$2[ebp]
	mov	eax, DWORD PTR _hEntityInstance$1[ebp]
	cmp	eax, DWORD PTR [edx+12]
	je	SHORT $LN46@fnWriteEnt

; 921  :             continue;

	jmp	SHORT $LN10@fnWriteEnt
$LN46@fnWriteEnt:

; 922  : 
; 923  :          if ( hViewEntity != lpSrchSelectedInstance->hViewEntity )

	mov	ecx, DWORD PTR _lpSrchSelectedInstance$2[ebp]
	mov	edx, DWORD PTR _hViewEntity$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	je	SHORT $LN47@fnWriteEnt

; 924  :             continue;

	jmp	SHORT $LN10@fnWriteEnt
$LN47@fnWriteEnt:

; 925  : 
; 926  :          // We have found a selected instance.  Write out the info.
; 927  :          zsprintf( &lpWriteInfo->szBuffer[ zstrlen( lpWriteInfo->szBuffer ) ],

	mov	eax, DWORD PTR _lpSrchSelectedInstance$2[ebp]
	movsx	ecx, WORD PTR [eax+6]
	push	ecx
	push	OFFSET $SG13990
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 928  :                    " zSelect%d=\"Y\"", lpSrchSelectedInstance->nSelectSet );
; 929  :       }

	jmp	SHORT $LN10@fnWriteEnt
$LN41@fnWriteEnt:

; 930  :    }
; 931  : 
; 932  :    // I think this is the right place to add the "simple attributes".  dks 2009.11.19
; 933  :    fnWriteAttribs( lpTaskView, lpWriteInfo,

	push	1
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_fnWriteAttribs@20

; 934  :                    (zSHORT) (lpEntityInstance->nLevel + 1), lpViewEntity, 1 );
; 935  : 
; 936  :    zstrcat( lpWriteInfo->szBuffer, ">" );

	push	OFFSET $SG13991
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	add	edx, 20					; 00000014H
	push	edx
	call	_strcat
	add	esp, 8

; 937  : 
; 938  :    if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_STARTENTITY,
; 939  :                                    lpWriteInfo->szBuffer, 0,
; 940  :                                    lpEntityInstance->nLevel,
; 941  :                                    lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+10424]
	push	ecx
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movzx	eax, WORD PTR [edx+58]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	push	4
	mov	edx, DWORD PTR _lpTaskView$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+10420]
	call	ecx
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN48@fnWriteEnt

; 942  :    {
; 943  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnWriteEnt
$LN48@fnWriteEnt:

; 944  :    }
; 945  : 
; 946  :    // Ok, we wrote the opening tag so set the name in the "entity stack".
; 947  :    lpWriteInfo->pchEntityName[ lpEntityInstance->nLevel ] = pchRealEntityName;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR _pchRealEntityName$[ebp]
	mov	DWORD PTR [edx+ecx*4+10020], eax

; 948  : 
; 949  :    return( lpAbstractChild );

	mov	eax, DWORD PTR _lpAbstractChild$[ebp]
$LN1@fnWriteEnt:

; 950  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnWriteEntityStartTag@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
tv199 = -584						; size = 4
tv198 = -580						; size = 4
$T1 = -576						; size = 4
_hTempValueBuffer$ = -572				; size = 4
tv262 = -568						; size = 4
_lCharCount$2 = -564					; size = 4
_lpAttribFlags$ = -560					; size = 4
_lTempBufferLth$ = -556					; size = 4
_nReturn$ = -552					; size = 2
_chType$ = -545						; size = 1
_pchTempValueBuffer$ = -544				; size = 4
_bCloseCDATA$ = -537					; size = 1
_ulLth$ = -536						; size = 4
_bSkipIfNull$ = -529					; size = 1
_pchAttribValue$ = -528					; size = 4
_lpViewAttrib$ = -524					; size = 4
_pch$3 = -520						; size = 4
_szAttribTag$ = -516					; size = 500
_szIncreFlags$4 = -16					; size = 10
__$ArrayPad$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_lpWriteInfo$ = 12					; size = 4
_nLevel$ = 16						; size = 2
_lpViewEntity$ = 20					; size = 4
_lFlags$ = 24						; size = 4
_fnWriteAttribs@20 PROC

; 386  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 584				; 00000248H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 387  :    LPVIEWATTRIB  lpViewAttrib;
; 388  :    LPATTRIBFLAGS lpAttribFlags;
; 389  :    zCHAR         szAttribTag[ 500 ];
; 390  :    zPCHAR        pchAttribValue;
; 391  :    zBOOL         bCloseCDATA;
; 392  :    zCHAR         chType;
; 393  :    zULONG        ulLth;
; 394  :    zPCHAR        pchTempValueBuffer = 0;

	mov	DWORD PTR _pchTempValueBuffer$[ebp], 0

; 395  :    zULONG        lTempBufferLth = 0;

	mov	DWORD PTR _lTempBufferLth$[ebp], 0

; 396  :    zLONG         hTempValueBuffer;
; 397  :    zBOOL         bSkipIfNull;
; 398  :    zSHORT        nReturn = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nReturn$[ebp], ax

; 399  : 
; 400  :    szAttribTag[ 0 ] = 0;  // initialize to empty string

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 500			; 000001f4H
	jae	SHORT $LN67@fnWriteAtt
	jmp	SHORT $LN68@fnWriteAtt
$LN67@fnWriteAtt:
	call	___report_rangecheckfailure
$LN68@fnWriteAtt:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szAttribTag$[ebp+eax], 0

; 401  :    lTempBufferLth = 10000;

	mov	DWORD PTR _lTempBufferLth$[ebp], 10000	; 00002710H

; 402  :    hTempValueBuffer = SysAllocMemory( &pchTempValueBuffer, lTempBufferLth, 0, 0, 0 );

	push	0
	push	0
	push	0
	mov	ecx, DWORD PTR _lTempBufferLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchTempValueBuffer$[ebp]
	push	edx
	call	_SysAllocMemory@20
	mov	DWORD PTR _hTempValueBuffer$[ebp], eax

; 403  : 
; 404  :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	mov	ecx, DWORD PTR [eax+179]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnWriteAtt
$LN2@fnWriteAtt:

; 406  :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+2]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnWriteAtt:

; 405  :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN3@fnWriteAtt

; 407  :    {
; 408  :       if ( lpViewAttrib->szDerivedOper[ 0 ] && lpViewAttrib->bPersist == FALSE )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+213]
	test	ecx, ecx
	je	SHORT $LN12@fnWriteAtt
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	and	eax, 1
	jne	SHORT $LN12@fnWriteAtt

; 409  :       {
; 410  :          continue;

	jmp	SHORT $LN2@fnWriteAtt
$LN12@fnWriteAtt:

; 411  :       }
; 412  : 
; 413  :       // Skip key attributes here.  Written with entity.
; 414  :       if ( (lpWriteInfo->lControl & zXML_KEYATTRIBSASIDENT) && lpViewAttrib->bKey )

	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 16					; 00000010H
	je	SHORT $LN13@fnWriteAtt
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	shr	ecx, 1
	and	ecx, 1
	je	SHORT $LN13@fnWriteAtt

; 415  :       {
; 416  :          continue;

	jmp	SHORT $LN2@fnWriteAtt
$LN13@fnWriteAtt:

; 417  :       }
; 418  : 
; 419  :       GetAttributeFlags( &lpAttribFlags, lpWriteInfo->vTemp, lpViewEntity, lpViewAttrib );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR _lpAttribFlags$[ebp]
	push	eax
	call	_GetAttributeFlags@16

; 420  : 
; 421  :       if ( (lFlags & 1) == 0 )  // not doing "simple attributes"

	mov	ecx, DWORD PTR _lFlags$[ebp]
	and	ecx, 1
	jne	$LN14@fnWriteAtt

; 422  :       {
; 423  :          if ( lpViewAttrib->szXML_SimpleName[ 0 ] == 0 )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+43]
	test	edx, edx
	jne	$LN15@fnWriteAtt

; 424  :          {
; 425  :             if ( lpViewAttrib->szXML_ExternalName[ 0 ] == 0 )

	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+ecx+76]
	test	eax, eax
	jne	SHORT $LN17@fnWriteAtt

; 426  :                zsprintf( szAttribTag, "<%s", lpViewAttrib->szName );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG13829
	lea	edx, DWORD PTR _szAttribTag$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN18@fnWriteAtt
$LN17@fnWriteAtt:

; 427  :             else
; 428  :                zsprintf( szAttribTag, "<%s", lpViewAttrib->szXML_ExternalName );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 76					; 0000004cH
	push	eax
	push	OFFSET $SG13830
	lea	ecx, DWORD PTR _szAttribTag$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN18@fnWriteAtt:

; 429  : 
; 430  :             // If the user only wants updated attributes then skip attributes that
; 431  :             // aren't flagged as updated.
; 432  :             if ( lpWriteInfo->lControl & zXML_UPDATEDONLY )

	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 4
	je	SHORT $LN19@fnWriteAtt

; 433  :             {
; 434  :                if ( lpAttribFlags->u.bFlags.bUpdated == FALSE )

	mov	ecx, DWORD PTR _lpAttribFlags$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 1
	and	edx, 1
	jne	SHORT $LN19@fnWriteAtt

; 435  :                   continue;   // Attr is null so skip it.

	jmp	$LN2@fnWriteAtt
$LN19@fnWriteAtt:

; 436  :             }
; 437  : 
; 438  :             // Usually we won't send null attributes.  However, if we have to send
; 439  :             // attribute flags we'll have to send it if it's been changed.
; 440  :             bSkipIfNull = TRUE;

	mov	BYTE PTR _bSkipIfNull$[ebp], 1

; 441  :             if ( lpWriteInfo->lControl & zXML_INCREFLAGS )

	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 2
	je	SHORT $LN21@fnWriteAtt

; 442  :             {
; 443  :                if ( lpAttribFlags->u.bFlags.bUpdated )

	mov	edx, DWORD PTR _lpAttribFlags$[ebp]
	mov	eax, DWORD PTR [edx]
	shr	eax, 1
	and	eax, 1
	je	SHORT $LN21@fnWriteAtt

; 444  :                   bSkipIfNull = FALSE;

	mov	BYTE PTR _bSkipIfNull$[ebp], 0
$LN21@fnWriteAtt:

; 445  :             }
; 446  : 
; 447  :             // Add incremental update flags if so specified.
; 448  :             if ( lpWriteInfo->lControl & zXML_INCREFLAGS )

	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 2
	je	$LN23@fnWriteAtt

; 449  :             {
; 450  :                zCHAR szIncreFlags[ 10 ] = "..";

	mov	ax, WORD PTR $SG13836
	mov	WORD PTR _szIncreFlags$4[ebp], ax
	mov	cl, BYTE PTR $SG13836+2
	mov	BYTE PTR _szIncreFlags$4[ebp+2], cl
	xor	edx, edx
	mov	DWORD PTR _szIncreFlags$4[ebp+3], edx
	mov	WORD PTR _szIncreFlags$4[ebp+7], dx
	mov	BYTE PTR _szIncreFlags$4[ebp+9], dl

; 451  : 
; 452  :                if ( lpAttribFlags->u.bFlags.bActivated )

	mov	eax, DWORD PTR _lpAttribFlags$[ebp]
	mov	ecx, DWORD PTR [eax]
	and	ecx, 1
	je	SHORT $LN24@fnWriteAtt

; 453  :                   szIncreFlags[ ATTRIB_FLAGS_ACTIVATED_IDX ] = 'Y';

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _szIncreFlags$4[ebp+eax], 89	; 00000059H
$LN24@fnWriteAtt:

; 454  : 
; 455  :                if ( lpAttribFlags->u.bFlags.bUpdated )

	mov	ecx, DWORD PTR _lpAttribFlags$[ebp]
	mov	edx, DWORD PTR [ecx]
	shr	edx, 1
	and	edx, 1
	je	SHORT $LN25@fnWriteAtt

; 456  :                   szIncreFlags[ ATTRIB_FLAGS_UPDATED_IDX ] = 'Y';

	mov	eax, 1
	shl	eax, 0
	mov	BYTE PTR _szIncreFlags$4[ebp+eax], 89	; 00000059H
$LN25@fnWriteAtt:

; 457  : 
; 458  :                // Don't bother writing the incre flags if none are set.
; 459  :                if ( zstrcmp( szIncreFlags, ".." ) != 0 )

	movsx	ecx, BYTE PTR _szIncreFlags$4[ebp]
	movsx	edx, BYTE PTR $SG13840
	cmp	ecx, edx
	jne	SHORT $LN71@fnWriteAtt
	push	OFFSET $SG13841
	lea	eax, DWORD PTR _szIncreFlags$4[ebp]
	push	eax
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv199[ebp], eax
	jmp	SHORT $LN72@fnWriteAtt
$LN71@fnWriteAtt:
	movsx	ecx, BYTE PTR _szIncreFlags$4[ebp]
	movsx	edx, BYTE PTR $SG13842
	sub	ecx, edx
	test	ecx, ecx
	jle	SHORT $LN69@fnWriteAtt
	mov	DWORD PTR tv198[ebp], 1
	jmp	SHORT $LN70@fnWriteAtt
$LN69@fnWriteAtt:
	mov	DWORD PTR tv198[ebp], -1
$LN70@fnWriteAtt:
	mov	eax, DWORD PTR tv198[ebp]
	mov	DWORD PTR tv199[ebp], eax
$LN72@fnWriteAtt:
	cmp	DWORD PTR tv199[ebp], 0
	je	SHORT $LN23@fnWriteAtt

; 460  :                {
; 461  :                   zsprintf( szAttribTag + zstrlen( szAttribTag ),

	lea	ecx, DWORD PTR _szIncreFlags$4[ebp]
	push	ecx
	push	OFFSET $SG13843
	lea	edx, DWORD PTR _szAttribTag$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	lea	eax, DWORD PTR _szAttribTag$[ebp+eax]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN23@fnWriteAtt:

; 462  :                             " zIncreFlags=\"%s\"", szIncreFlags );
; 463  :                }
; 464  :             }
; 465  : 
; 466  :             zstrcat( szAttribTag, ">" );

	push	OFFSET $SG13844
	lea	ecx, DWORD PTR _szAttribTag$[ebp]
	push	ecx
	call	_strcat
	add	esp, 8

; 467  : 
; 468  :             bCloseCDATA = FALSE;

	mov	BYTE PTR _bCloseCDATA$[ebp], 0

; 469  :          }

	jmp	SHORT $LN14@fnWriteAtt
$LN15@fnWriteAtt:

; 470  :          else
; 471  :          {
; 472  :             continue;  // skip since it's simple

	jmp	$LN2@fnWriteAtt
$LN14@fnWriteAtt:

; 473  :          }
; 474  :       }
; 475  : 
; 476  :       if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	eax, BYTE PTR [edx+202]
	cmp	eax, 66					; 00000042H
	jne	SHORT $LN27@fnWriteAtt

; 477  :       {
; 478  :          // Get ptr to attr value.
; 479  :          GetValueFromRecord( lpWriteInfo->vTemp, lpViewEntity, lpViewAttrib,

	lea	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	lea	edx, DWORD PTR _chType$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchAttribValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_GetValueFromRecord@24

; 480  :                              &pchAttribValue, &chType, &ulLth );
; 481  : 
; 482  :          // Check to see if the attribute is NULL.  The we check ulLth = 1 for
; 483  :          // strings because the length contains the null-terminator.
; 484  :          if ( ulLth == 0 )

	cmp	DWORD PTR _ulLth$[ebp], 0
	jne	SHORT $LN29@fnWriteAtt

; 485  :          {
; 486  :             // Make sure we don't have to send attr flags.
; 487  :             if ( bSkipIfNull )

	movzx	edx, BYTE PTR _bSkipIfNull$[ebp]
	test	edx, edx
	je	SHORT $LN31@fnWriteAtt

; 488  :                continue;   // Attr is null so skip it.

	jmp	$LN2@fnWriteAtt
$LN31@fnWriteAtt:

; 489  : 
; 490  :             // If we get here then the attribute is null but it's been
; 491  :             // modified so we need to send the attribute flags.  We do this
; 492  :             // by sending a null attribute.
; 493  :             pchAttribValue = "";

	mov	DWORD PTR _pchAttribValue$[ebp], OFFSET $SG13850

; 494  :          }

	jmp	SHORT $LN30@fnWriteAtt
$LN29@fnWriteAtt:

; 495  :          else
; 496  :          {
; 497  :             zstrcat( szAttribTag, "<![CDATA[" );

	push	OFFSET $SG13851
	lea	eax, DWORD PTR _szAttribTag$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 498  :             bCloseCDATA = TRUE;

	mov	BYTE PTR _bCloseCDATA$[ebp], 1
$LN30@fnWriteAtt:

; 499  :          }
; 500  :       }

	jmp	$LN28@fnWriteAtt
$LN27@fnWriteAtt:

; 501  :       else
; 502  :       if ( lpViewAttrib->cType == zTYPE_STRING )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 83					; 00000053H
	jne	$LN32@fnWriteAtt

; 503  :       {
; 504  :          // Get ptr to attr value.
; 505  :          GetValueFromRecord( lpWriteInfo->vTemp, lpViewEntity, lpViewAttrib,

	lea	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _chType$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchAttribValue$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_GetValueFromRecord@24

; 506  :                              &pchAttribValue, &chType, &ulLth );
; 507  : 
; 508  :          // Check to see if the attribute is NULL.  The we check ulLth = 1 for
; 509  :          // strings because the length contains the null-terminator.
; 510  :          if ( ulLth <= 1 || pchAttribValue == 0 )

	cmp	DWORD PTR _ulLth$[ebp], 1
	jbe	SHORT $LN36@fnWriteAtt
	cmp	DWORD PTR _pchAttribValue$[ebp], 0
	jne	SHORT $LN34@fnWriteAtt
$LN36@fnWriteAtt:

; 511  :          {
; 512  :             // Make sure we don't have to send attr flags.
; 513  :             if ( bSkipIfNull )

	movzx	ecx, BYTE PTR _bSkipIfNull$[ebp]
	test	ecx, ecx
	je	SHORT $LN37@fnWriteAtt

; 514  :                continue;   // attribute is null so skip it

	jmp	$LN2@fnWriteAtt
$LN37@fnWriteAtt:

; 515  : 
; 516  :             // If we get here then the attribute is null but it's been
; 517  :             // modified so we need to send the attribute flags.  We do this
; 518  :             // by sending a null attribute.
; 519  :             pchAttribValue = "";

	mov	DWORD PTR _pchAttribValue$[ebp], OFFSET $SG13858

; 520  :             ulLth = 0;

	mov	DWORD PTR _ulLth$[ebp], 0

; 521  :          }

	jmp	$LN35@fnWriteAtt
$LN34@fnWriteAtt:

; 522  :          else
; 523  :          {
; 524  :             zLONG lCharCount;
; 525  :             ulLth--;  // subtract the null-terminator from the length

	mov	edx, DWORD PTR _ulLth$[ebp]
	sub	edx, 1
	mov	DWORD PTR _ulLth$[ebp], edx

; 526  : 
; 527  :             // Check to see how many chars there are that need to be translated (e.g. '&').
; 528  :             if ( (lCharCount = fnContainsSpecialChar( pchAttribValue )) )

	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	push	eax
	call	_fnContainsSpecialChar@4
	mov	DWORD PTR _lCharCount$2[ebp], eax
	cmp	DWORD PTR _lCharCount$2[ebp], 0
	je	$LN35@fnWriteAtt

; 529  :             {
; 530  :                zPCHAR pch;
; 531  : 
; 532  :                // We need to convert some characters into XML entities.  For example,
; 533  :                // change '&' into '&amp;'.
; 534  : 
; 535  :                // First create a temp buffer.  Make sure it's big enough to handle the
; 536  :                // buffer plus conversions.
; 537  :                if ( lTempBufferLth < ulLth + lCharCount * 6 )

	imul	ecx, DWORD PTR _lCharCount$2[ebp], 6
	add	ecx, DWORD PTR _ulLth$[ebp]
	cmp	DWORD PTR _lTempBufferLth$[ebp], ecx
	jae	SHORT $LN39@fnWriteAtt

; 538  :                {
; 539  :                   if ( pchTempValueBuffer )

	cmp	DWORD PTR _pchTempValueBuffer$[ebp], 0
	je	SHORT $LN40@fnWriteAtt

; 540  :                      SysFreeMemory( hTempValueBuffer );

	mov	edx, DWORD PTR _hTempValueBuffer$[ebp]
	push	edx
	call	_SysFreeMemory@4
$LN40@fnWriteAtt:

; 541  : 
; 542  :                   hTempValueBuffer = SysAllocMemory( &pchTempValueBuffer,

	push	0
	push	0
	push	0
	imul	eax, DWORD PTR _lCharCount$2[ebp], 6
	add	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchTempValueBuffer$[ebp]
	push	ecx
	call	_SysAllocMemory@20
	mov	DWORD PTR _hTempValueBuffer$[ebp], eax

; 543  :                                                      ulLth + lCharCount * 6,
; 544  :                                                      0, 0, 0 );
; 545  :                   if ( pchTempValueBuffer == 0 )

	cmp	DWORD PTR _pchTempValueBuffer$[ebp], 0
	jne	SHORT $LN41@fnWriteAtt

; 546  :                      goto EndOfFunction;

	jmp	$EndOfFunction$75
$LN41@fnWriteAtt:

; 547  : 
; 548  :                   lTempBufferLth = ulLth + lCharCount * 6;

	imul	edx, DWORD PTR _lCharCount$2[ebp], 6
	add	edx, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR _lTempBufferLth$[ebp], edx
$LN39@fnWriteAtt:

; 549  :                }
; 550  : 
; 551  :                // Now copy chars over, converting special ones.
; 552  :                for ( pch = pchTempValueBuffer;

	mov	eax, DWORD PTR _pchTempValueBuffer$[ebp]
	mov	DWORD PTR _pch$3[ebp], eax
	jmp	SHORT $LN7@fnWriteAtt
$LN5@fnWriteAtt:

; 554  :                      pchAttribValue++ )

	mov	ecx, DWORD PTR _pchAttribValue$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pchAttribValue$[ebp], ecx
$LN7@fnWriteAtt:

; 553  :                      *pchAttribValue;

	mov	edx, DWORD PTR _pchAttribValue$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	$LN6@fnWriteAtt

; 555  :                {
; 556  :                   switch ( *pchAttribValue )

	mov	ecx, DWORD PTR _pchAttribValue$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv262[ebp], edx
	mov	eax, DWORD PTR tv262[ebp]
	sub	eax, 9
	mov	DWORD PTR tv262[ebp], eax
	cmp	DWORD PTR tv262[ebp], 53		; 00000035H
	ja	$LN48@fnWriteAtt
	mov	ecx, DWORD PTR tv262[ebp]
	movzx	edx, BYTE PTR $LN73@fnWriteAtt[ecx]
	jmp	DWORD PTR $LN74@fnWriteAtt[edx*4]
$LN42@fnWriteAtt:

; 557  :                   {
; 558  :                      case '&':
; 559  :                         *pch++ = '&';

	mov	eax, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _pch$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$3[ebp], ecx

; 560  :                         *pch++ = 'a';

	mov	edx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [edx], 97			; 00000061H
	mov	eax, DWORD PTR _pch$3[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$3[ebp], eax

; 561  :                         *pch++ = 'm';

	mov	ecx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [ecx], 109			; 0000006dH
	mov	edx, DWORD PTR _pch$3[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$3[ebp], edx

; 562  :                         *pch++ = 'p';

	mov	eax, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [eax], 112			; 00000070H
	mov	ecx, DWORD PTR _pch$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$3[ebp], ecx

; 563  :                         *pch++ = ';';

	mov	edx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
	mov	eax, DWORD PTR _pch$3[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$3[ebp], eax

; 564  :                         break;

	jmp	$LN8@fnWriteAtt
$LN43@fnWriteAtt:

; 565  : 
; 566  :                      case '<':
; 567  :                         *pch++ = '&';

	mov	ecx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [ecx], 38			; 00000026H
	mov	edx, DWORD PTR _pch$3[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$3[ebp], edx

; 568  :                         *pch++ = 'l';

	mov	eax, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [eax], 108			; 0000006cH
	mov	ecx, DWORD PTR _pch$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$3[ebp], ecx

; 569  :                         *pch++ = 't';

	mov	edx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [edx], 116			; 00000074H
	mov	eax, DWORD PTR _pch$3[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$3[ebp], eax

; 570  :                         *pch++ = ';';

	mov	ecx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
	mov	edx, DWORD PTR _pch$3[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$3[ebp], edx

; 571  :                         break;

	jmp	$LN8@fnWriteAtt
$LN44@fnWriteAtt:

; 572  : 
; 573  :                      case '>':
; 574  :                         *pch++ = '&';

	mov	eax, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _pch$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$3[ebp], ecx

; 575  :                         *pch++ = 'g';

	mov	edx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [edx], 103			; 00000067H
	mov	eax, DWORD PTR _pch$3[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$3[ebp], eax

; 576  :                         *pch++ = 't';

	mov	ecx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [ecx], 116			; 00000074H
	mov	edx, DWORD PTR _pch$3[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$3[ebp], edx

; 577  :                         *pch++ = ';';

	mov	eax, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [eax], 59			; 0000003bH
	mov	ecx, DWORD PTR _pch$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$3[ebp], ecx

; 578  :                         break;

	jmp	$LN8@fnWriteAtt
$LN45@fnWriteAtt:

; 579  : 
; 580  :                      case '\'':
; 581  :                         *pch++ = '&';

	mov	edx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _pch$3[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$3[ebp], eax

; 582  :                         *pch++ = 'a';

	mov	ecx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [ecx], 97			; 00000061H
	mov	edx, DWORD PTR _pch$3[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$3[ebp], edx

; 583  :                         *pch++ = 'p';

	mov	eax, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [eax], 112			; 00000070H
	mov	ecx, DWORD PTR _pch$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$3[ebp], ecx

; 584  :                         *pch++ = 'o';

	mov	edx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [edx], 111			; 0000006fH
	mov	eax, DWORD PTR _pch$3[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$3[ebp], eax

; 585  :                         *pch++ = 's';

	mov	ecx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [ecx], 115			; 00000073H
	mov	edx, DWORD PTR _pch$3[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$3[ebp], edx

; 586  :                         *pch++ = ';';

	mov	eax, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [eax], 59			; 0000003bH
	mov	ecx, DWORD PTR _pch$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$3[ebp], ecx

; 587  :                         break;

	jmp	$LN8@fnWriteAtt
$LN46@fnWriteAtt:

; 588  : 
; 589  :                      case '\"':
; 590  :                         *pch++ = '&';

	mov	edx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _pch$3[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$3[ebp], eax

; 591  :                         *pch++ = 'q';

	mov	ecx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [ecx], 113			; 00000071H
	mov	edx, DWORD PTR _pch$3[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$3[ebp], edx

; 592  :                         *pch++ = 'u';

	mov	eax, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [eax], 117			; 00000075H
	mov	ecx, DWORD PTR _pch$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$3[ebp], ecx

; 593  :                         *pch++ = 'o';

	mov	edx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [edx], 111			; 0000006fH
	mov	eax, DWORD PTR _pch$3[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$3[ebp], eax

; 594  :                         *pch++ = 't';

	mov	ecx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [ecx], 116			; 00000074H
	mov	edx, DWORD PTR _pch$3[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$3[ebp], edx

; 595  :                         *pch++ = ';';

	mov	eax, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [eax], 59			; 0000003bH
	mov	ecx, DWORD PTR _pch$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$3[ebp], ecx

; 596  :                         break;

	jmp	$LN8@fnWriteAtt
$LN47@fnWriteAtt:

; 597  : 
; 598  :                      case '\n':
; 599  :                      case '\r':
; 600  :                      case '\t':
; 601  :                         *pch++ = *pchAttribValue;

	mov	edx, DWORD PTR _pch$3[ebp]
	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pch$3[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$3[ebp], edx

; 602  :                         break;

	jmp	$LN8@fnWriteAtt
$LN48@fnWriteAtt:

; 603  : 
; 604  :                      default:
; 605  :                         if ( *pchAttribValue < 32 || *pchAttribValue > 127 )

	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 32					; 00000020H
	jl	SHORT $LN51@fnWriteAtt
	mov	edx, DWORD PTR _pchAttribValue$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 127				; 0000007fH
	jle	$LN49@fnWriteAtt
$LN51@fnWriteAtt:

; 606  :                         {
; 607  :                            // Convert the char to '&#ddd;' where 'ddd' is its ASCII value.
; 608  :                            *pch++ = '&';

	mov	ecx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [ecx], 38			; 00000026H
	mov	edx, DWORD PTR _pch$3[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$3[ebp], edx

; 609  :                            *pch++ = '#';

	mov	eax, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [eax], 35			; 00000023H
	mov	ecx, DWORD PTR _pch$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$3[ebp], ecx

; 610  :                            zltoa( (zLONG) (zUCHAR) *pchAttribValue, pch );

	push	10					; 0000000aH
	mov	edx, DWORD PTR _pch$3[ebp]
	push	edx
	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$LN10@fnWriteAtt:

; 611  :                            while ( *++pch )  // skip to null terminator

	mov	edx, DWORD PTR _pch$3[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$3[ebp], edx
	mov	eax, DWORD PTR _pch$3[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN11@fnWriteAtt

; 612  :                            {
; 613  :                            }

	jmp	SHORT $LN10@fnWriteAtt
$LN11@fnWriteAtt:

; 614  : 
; 615  :                            *pch++ = ';';

	mov	edx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
	mov	eax, DWORD PTR _pch$3[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$3[ebp], eax

; 616  :                         }

	jmp	SHORT $LN8@fnWriteAtt
$LN49@fnWriteAtt:

; 617  :                         else
; 618  :                            *pch++ = *pchAttribValue;

	mov	ecx, DWORD PTR _pch$3[ebp]
	mov	edx, DWORD PTR _pchAttribValue$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pch$3[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$3[ebp], ecx
$LN8@fnWriteAtt:

; 619  : 
; 620  :                         break;
; 621  : 
; 622  :                   } // switch ( *pchAttribValue )...
; 623  : 
; 624  :                } // for...

	jmp	$LN5@fnWriteAtt
$LN6@fnWriteAtt:

; 625  : 
; 626  :                // Now that we've translated the attribute's value into the
; 627  :                // temp buffer, set attribute value ptr to point to the buffer.
; 628  :                *pch++ = 0;

	mov	edx, DWORD PTR _pch$3[ebp]
	mov	BYTE PTR [edx], 0
	mov	eax, DWORD PTR _pch$3[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$3[ebp], eax

; 629  :                ulLth = (zLONG) (pch - pchTempValueBuffer) - 1;

	mov	ecx, DWORD PTR _pch$3[ebp]
	sub	ecx, DWORD PTR _pchTempValueBuffer$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ulLth$[ebp], ecx

; 630  :                pchAttribValue = pchTempValueBuffer;

	mov	edx, DWORD PTR _pchTempValueBuffer$[ebp]
	mov	DWORD PTR _pchAttribValue$[ebp], edx
$LN35@fnWriteAtt:

; 631  : 
; 632  :             } // if contains special chars
; 633  : 
; 634  :          } // pchAttribValue non-NULL
; 635  : 
; 636  :       } // if ( lpViewAttrib->cType == zTYPE_STRING )...

	jmp	SHORT $LN28@fnWriteAtt
$LN32@fnWriteAtt:

; 637  :       else
; 638  :       {
; 639  :          // Get attribute value.  If return is -1 then the attribute is NULL so skip it.
; 640  :          if ( GetStringFromRecord( lpWriteInfo->vTemp, lpViewEntity, lpViewAttrib,
; 641  :                                    pchTempValueBuffer, lTempBufferLth ) == -1 )

	mov	eax, DWORD PTR _lTempBufferLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchTempValueBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewEntity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_GetStringFromRecord@20
	cwde
	cmp	eax, -1
	jne	SHORT $LN52@fnWriteAtt

; 642  :          {
; 643  :             // Attribute is NULL.  Skip null attributes if flag is set.
; 644  :             if ( bSkipIfNull )

	movzx	ecx, BYTE PTR _bSkipIfNull$[ebp]
	test	ecx, ecx
	je	SHORT $LN52@fnWriteAtt

; 645  :                continue;

	jmp	$LN2@fnWriteAtt
$LN52@fnWriteAtt:

; 646  :          }
; 647  : 
; 648  :          pchAttribValue = pchTempValueBuffer;

	mov	edx, DWORD PTR _pchTempValueBuffer$[ebp]
	mov	DWORD PTR _pchAttribValue$[ebp], edx

; 649  :          ulLth = zstrlen( pchAttribValue );

	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax
$LN28@fnWriteAtt:

; 650  :       }
; 651  : 
; 652  :       if ( lFlags & 1 )  // doing "simple attributes"

	mov	ecx, DWORD PTR _lFlags$[ebp]
	and	ecx, 1
	je	$LN54@fnWriteAtt

; 653  :       {
; 654  :          if ( lpViewAttrib->szXML_SimpleName[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+43]
	test	edx, edx
	je	SHORT $LN56@fnWriteAtt

; 655  :          {
; 656  :             zsprintf( szAttribTag, " %s=", lpViewAttrib->szXML_SimpleName );

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	add	eax, 43					; 0000002bH
	push	eax
	push	OFFSET $SG13878
	lea	ecx, DWORD PTR _szAttribTag$[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 657  :             if ( pchAttribValue[ 0 ] )

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _pchAttribValue$[ebp]
	movsx	edx, BYTE PTR [ecx+eax]
	test	edx, edx
	je	SHORT $LN56@fnWriteAtt

; 658  :             {
; 659  :                zsprintf( szAttribTag, " %s=\"%s\"", lpViewAttrib->szXML_SimpleName, pchAttribValue );

	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 43					; 0000002bH
	push	ecx
	push	OFFSET $SG13880
	lea	edx, DWORD PTR _szAttribTag$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 660  :                zstrcat( lpWriteInfo->szBuffer, szAttribTag );

	lea	eax, DWORD PTR _szAttribTag$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	_strcat
	add	esp, 8
$LN56@fnWriteAtt:

; 661  :             }
; 662  :          }
; 663  :       }

	jmp	$LN55@fnWriteAtt
$LN54@fnWriteAtt:

; 664  :       else
; 665  :       {
; 666  :          if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_STARTATTRIB,
; 667  :                                          szAttribTag, 0, nLevel,
; 668  :                                          lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+10424]
	push	eax
	movzx	ecx, WORD PTR _nLevel$[ebp]
	push	ecx
	push	0
	lea	edx, DWORD PTR _szAttribTag$[ebp]
	push	edx
	push	16					; 00000010H
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+10420]
	call	edx
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN58@fnWriteAtt

; 669  :          {
; 670  :             goto EndOfFunction;

	jmp	$EndOfFunction$75
$LN58@fnWriteAtt:

; 671  :          }
; 672  : 
; 673  :          if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_ATTRIBVALUE,
; 674  :                                          pchAttribValue, ulLth, nLevel,
; 675  :                                          lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+10424]
	push	edx
	movzx	eax, WORD PTR _nLevel$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAttribValue$[ebp]
	push	edx
	push	64					; 00000040H
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+10420]
	call	edx
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN59@fnWriteAtt

; 676  :          {
; 677  :             goto EndOfFunction;

	jmp	$EndOfFunction$75
$LN59@fnWriteAtt:

; 678  :          }
; 679  : 
; 680  :          // Close the attribute value.  If necessary close the CDATA section too.
; 681  :          if ( bCloseCDATA )

	movzx	ecx, BYTE PTR _bCloseCDATA$[ebp]
	test	ecx, ecx
	je	SHORT $LN60@fnWriteAtt

; 682  :             zsprintf( szAttribTag, "]]></%s>", lpViewAttrib->szName );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG13885
	lea	eax, DWORD PTR _szAttribTag$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN61@fnWriteAtt
$LN60@fnWriteAtt:

; 683  :          else
; 684  :          {
; 685  :             if ( lpViewAttrib->szXML_ExternalName[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	movsx	ecx, BYTE PTR [eax+edx+76]
	test	ecx, ecx
	jne	SHORT $LN62@fnWriteAtt

; 686  :                zsprintf( szAttribTag, "</%s>", lpViewAttrib->szName );

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG13888
	lea	eax, DWORD PTR _szAttribTag$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN61@fnWriteAtt
$LN62@fnWriteAtt:

; 687  :             else
; 688  :                zsprintf( szAttribTag, "</%s>", lpViewAttrib->szXML_ExternalName );

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	add	ecx, 76					; 0000004cH
	push	ecx
	push	OFFSET $SG13889
	lea	edx, DWORD PTR _szAttribTag$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH
$LN61@fnWriteAtt:

; 689  :          }
; 690  : 
; 691  :          if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_ENDATTRIB,
; 692  :                                          szAttribTag, 0, nLevel,
; 693  :                                          lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+10424]
	push	ecx
	movzx	edx, WORD PTR _nLevel$[ebp]
	push	edx
	push	0
	lea	eax, DWORD PTR _szAttribTag$[ebp]
	push	eax
	push	32					; 00000020H
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+10420]
	call	eax
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN55@fnWriteAtt

; 694  :          {
; 695  :             goto EndOfFunction;

	jmp	SHORT $EndOfFunction$75
$LN55@fnWriteAtt:

; 696  :          }
; 697  :       }
; 698  : 
; 699  :    } // for each lpViewAttrib...

	jmp	$LN2@fnWriteAtt
$LN3@fnWriteAtt:

; 700  : 
; 701  :    nReturn = 0;

	xor	edx, edx
	mov	WORD PTR _nReturn$[ebp], dx
$EndOfFunction$75:

; 702  : 
; 703  : EndOfFunction:
; 704  :    if ( pchTempValueBuffer )

	cmp	DWORD PTR _pchTempValueBuffer$[ebp], 0
	je	SHORT $LN65@fnWriteAtt

; 705  :       SysFreeMemory( hTempValueBuffer );

	mov	eax, DWORD PTR _hTempValueBuffer$[ebp]
	push	eax
	call	_SysFreeMemory@4
$LN65@fnWriteAtt:

; 706  : 
; 707  :    return( nReturn );

	mov	ax, WORD PTR _nReturn$[ebp]
$LN66@fnWriteAtt:

; 708  : 
; 709  : } // fnWriteAttribs

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
	npad	1
$LN74@fnWriteAtt:
	DD	$LN47@fnWriteAtt
	DD	$LN46@fnWriteAtt
	DD	$LN42@fnWriteAtt
	DD	$LN45@fnWriteAtt
	DD	$LN43@fnWriteAtt
	DD	$LN44@fnWriteAtt
	DD	$LN48@fnWriteAtt
$LN73@fnWriteAtt:
	DB	0
	DB	0
	DB	6
	DB	6
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	2
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	5
_fnWriteAttribs@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_hTempValueBuffer$ = -556				; size = 4
$T1 = -552						; size = 4
_lTempBufferLth$ = -548					; size = 4
$T2 = -544						; size = 4
_chType$3 = -537					; size = 1
tv159 = -536						; size = 4
_lCharCount$4 = -532					; size = 4
_nReturn$ = -528					; size = 2
_pchTempValueBuffer$ = -524				; size = 4
_lpViewAttrib$ = -520					; size = 4
_ulLth$ = -516						; size = 4
_pchAttribValue$5 = -512				; size = 4
_pch$6 = -508						; size = 4
_szAttribIdent$7 = -504					; size = 500
__$ArrayPad$ = -4					; size = 4
_lpWriteInfo$ = 8					; size = 4
_lpViewEntity$ = 12					; size = 4
_fnAppendKeyAttribs@8 PROC

; 180  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 556				; 0000022cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 181  :    LPVIEWATTRIB lpViewAttrib;
; 182  :    zULONG       ulLth;
; 183  :    zPCHAR       pchTempValueBuffer = 0;

	mov	DWORD PTR _pchTempValueBuffer$[ebp], 0

; 184  :    zULONG       lTempBufferLth = 0;

	mov	DWORD PTR _lTempBufferLth$[ebp], 0

; 185  :    zLONG        hTempValueBuffer;
; 186  :    zSHORT       nReturn = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nReturn$[ebp], ax

; 187  : 
; 188  :    for ( lpViewAttrib = zGETPTR( lpViewEntity->hFirstOD_Attrib );

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	mov	edx, DWORD PTR [ecx+179]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
	jmp	SHORT $LN4@fnAppendKe
$LN2@fnAppendKe:

; 190  :          lpViewAttrib = zGETPTR( lpViewAttrib->hNextOD_Attrib ) )

	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewAttrib$[ebp], eax
$LN4@fnAppendKe:

; 189  :          lpViewAttrib;

	cmp	DWORD PTR _lpViewAttrib$[ebp], 0
	je	$LN3@fnAppendKe

; 191  :    {
; 192  :       zCHAR         szAttribIdent[ 500 ];
; 193  :       zPCHAR        pchAttribValue;
; 194  :       // LPATTRIBFLAGS lpAttribFlags;
; 195  : 
; 196  :       if ( lpViewAttrib->szDerivedOper[ 0 ] &&

	mov	edx, 1
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+eax+213]
	test	edx, edx
	je	SHORT $LN12@fnAppendKe
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	mov	ecx, DWORD PTR [eax+193]
	and	ecx, 1
	jne	SHORT $LN12@fnAppendKe

; 197  :            lpViewAttrib->bPersist == FALSE )
; 198  :       {
; 199  :          continue;

	jmp	SHORT $LN2@fnAppendKe
$LN12@fnAppendKe:

; 200  :       }
; 201  : 
; 202  :       // Skip non-key attributes here.  Will be written as attribute later.
; 203  :       if ( lpViewAttrib->bKey == FALSE )

	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	mov	eax, DWORD PTR [edx+193]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN13@fnAppendKe

; 204  :          continue;

	jmp	SHORT $LN2@fnAppendKe
$LN13@fnAppendKe:

; 205  : 
; 206  :       if ( lpViewAttrib->cType == zTYPE_BLOB )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 66					; 00000042H
	jne	SHORT $LN14@fnAppendKe

; 207  :       {
; 208  :          zstrcpy( szAttribIdent, "KEY WAS BLOB - NOT SUPPORTED" );

	push	OFFSET $SG13747
	lea	eax, DWORD PTR _szAttribIdent$7[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 209  :       }

	jmp	$LN15@fnAppendKe
$LN14@fnAppendKe:

; 210  :       else
; 211  :       if ( lpViewAttrib->cType == zTYPE_STRING )

	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	movsx	edx, BYTE PTR [ecx+202]
	cmp	edx, 83					; 00000053H
	jne	$LN16@fnAppendKe

; 212  :       {
; 213  :          zCHAR  chType;
; 214  : 
; 215  :          // Get ptr to attr value.
; 216  :          GetValueFromRecord( lpWriteInfo->vTemp, lpViewEntity, lpViewAttrib,

	lea	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _chType$3[ebp]
	push	ecx
	lea	edx, DWORD PTR _pchAttribValue$5[ebp]
	push	edx
	mov	eax, DWORD PTR _lpViewAttrib$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_GetValueFromRecord@24

; 217  :                              &pchAttribValue, &chType, &ulLth );
; 218  : 
; 219  :          // Check to see if the attribute is NULL.  The we check ulLth = 1 for
; 220  :          // strings because the length contains the null-terminator.
; 221  :          if ( ulLth <= 1 || pchAttribValue == 0 )

	cmp	DWORD PTR _ulLth$[ebp], 1
	jbe	SHORT $LN20@fnAppendKe
	cmp	DWORD PTR _pchAttribValue$5[ebp], 0
	jne	SHORT $LN18@fnAppendKe
$LN20@fnAppendKe:

; 222  :          {
; 223  :             // Key attributes should never be null, but if it is, put it out
; 224  :             // by sending an empty string.
; 225  :             szAttribIdent[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T2[ebp], edx
	cmp	DWORD PTR $T2[ebp], 500			; 000001f4H
	jae	SHORT $LN40@fnAppendKe
	jmp	SHORT $LN41@fnAppendKe
$LN40@fnAppendKe:
	call	___report_rangecheckfailure
$LN41@fnAppendKe:
	mov	eax, DWORD PTR $T2[ebp]
	mov	BYTE PTR _szAttribIdent$7[ebp+eax], 0

; 226  :             ulLth = 0;

	mov	DWORD PTR _ulLth$[ebp], 0

; 227  :          }

	jmp	$LN19@fnAppendKe
$LN18@fnAppendKe:

; 228  :          else
; 229  :          {
; 230  :             zLONG lCharCount;
; 231  :             ulLth--;  // Subtract the null-terminator from the length.

	mov	ecx, DWORD PTR _ulLth$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _ulLth$[ebp], ecx

; 232  : 
; 233  :             // Check to see how many chars there are that need to be
; 234  :             // translated (e.g. '&').
; 235  :             if ( (lCharCount = fnContainsSpecialChar( pchAttribValue ) ) )

	mov	edx, DWORD PTR _pchAttribValue$5[ebp]
	push	edx
	call	_fnContainsSpecialChar@4
	mov	DWORD PTR _lCharCount$4[ebp], eax
	cmp	DWORD PTR _lCharCount$4[ebp], 0
	je	$LN21@fnAppendKe

; 236  :             {
; 237  :                zPCHAR pch;
; 238  : 
; 239  :                // We need to convert some characters into XML entities.  For
; 240  :                // example, change '&' into '&amp;'.
; 241  : 
; 242  :                // First create a temp buffer.  Make sure it's big enough to
; 243  :                // handle the buffer plus conversions.
; 244  :                if ( lTempBufferLth < ulLth + lCharCount * 6 )

	imul	eax, DWORD PTR _lCharCount$4[ebp], 6
	add	eax, DWORD PTR _ulLth$[ebp]
	cmp	DWORD PTR _lTempBufferLth$[ebp], eax
	jae	SHORT $LN23@fnAppendKe

; 245  :                {
; 246  :                   if ( pchTempValueBuffer )

	cmp	DWORD PTR _pchTempValueBuffer$[ebp], 0
	je	SHORT $LN24@fnAppendKe

; 247  :                      SysFreeMemory( hTempValueBuffer );

	mov	ecx, DWORD PTR _hTempValueBuffer$[ebp]
	push	ecx
	call	_SysFreeMemory@4
$LN24@fnAppendKe:

; 248  : 
; 249  :                   hTempValueBuffer = SysAllocMemory( &pchTempValueBuffer,

	push	0
	push	0
	push	0
	imul	edx, DWORD PTR _lCharCount$4[ebp], 6
	add	edx, DWORD PTR _ulLth$[ebp]
	push	edx
	lea	eax, DWORD PTR _pchTempValueBuffer$[ebp]
	push	eax
	call	_SysAllocMemory@20
	mov	DWORD PTR _hTempValueBuffer$[ebp], eax

; 250  :                                                      ulLth + lCharCount * 6,
; 251  :                                                      0, 0, 0 );
; 252  :                   if ( pchTempValueBuffer == 0 )

	cmp	DWORD PTR _pchTempValueBuffer$[ebp], 0
	jne	SHORT $LN25@fnAppendKe

; 253  :                      goto EndOfFunction;

	jmp	$EndOfFunction$46
$LN25@fnAppendKe:

; 254  : 
; 255  :                   lTempBufferLth = ulLth + lCharCount * 6;

	imul	ecx, DWORD PTR _lCharCount$4[ebp], 6
	add	ecx, DWORD PTR _ulLth$[ebp]
	mov	DWORD PTR _lTempBufferLth$[ebp], ecx
$LN23@fnAppendKe:

; 256  :                }
; 257  : 
; 258  :                // Now copy chars over, converting special ones.
; 259  :                for ( pch = pchTempValueBuffer;

	mov	edx, DWORD PTR _pchTempValueBuffer$[ebp]
	mov	DWORD PTR _pch$6[ebp], edx
	jmp	SHORT $LN7@fnAppendKe
$LN5@fnAppendKe:

; 261  :                      pchAttribValue++ )

	mov	eax, DWORD PTR _pchAttribValue$5[ebp]
	add	eax, 1
	mov	DWORD PTR _pchAttribValue$5[ebp], eax
$LN7@fnAppendKe:

; 260  :                      *pchAttribValue;

	mov	ecx, DWORD PTR _pchAttribValue$5[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN6@fnAppendKe

; 262  :                {
; 263  :                   switch ( *pchAttribValue )

	mov	eax, DWORD PTR _pchAttribValue$5[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv159[ebp], ecx
	mov	edx, DWORD PTR tv159[ebp]
	sub	edx, 9
	mov	DWORD PTR tv159[ebp], edx
	cmp	DWORD PTR tv159[ebp], 53		; 00000035H
	ja	$LN32@fnAppendKe
	mov	eax, DWORD PTR tv159[ebp]
	movzx	ecx, BYTE PTR $LN44@fnAppendKe[eax]
	jmp	DWORD PTR $LN45@fnAppendKe[ecx*4]
$LN26@fnAppendKe:

; 264  :                   {
; 265  :                      case '&':
; 266  :                         *pch++ = '&';

	mov	edx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _pch$6[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$6[ebp], eax

; 267  :                         *pch++ = 'a';

	mov	ecx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [ecx], 97			; 00000061H
	mov	edx, DWORD PTR _pch$6[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$6[ebp], edx

; 268  :                         *pch++ = 'm';

	mov	eax, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [eax], 109			; 0000006dH
	mov	ecx, DWORD PTR _pch$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$6[ebp], ecx

; 269  :                         *pch++ = 'p';

	mov	edx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [edx], 112			; 00000070H
	mov	eax, DWORD PTR _pch$6[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$6[ebp], eax

; 270  :                         *pch++ = ';';

	mov	ecx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
	mov	edx, DWORD PTR _pch$6[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$6[ebp], edx

; 271  :                         break;

	jmp	$LN8@fnAppendKe
$LN27@fnAppendKe:

; 272  : 
; 273  :                      case '<':
; 274  :                         *pch++ = '&';

	mov	eax, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _pch$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$6[ebp], ecx

; 275  :                         *pch++ = 'l';

	mov	edx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [edx], 108			; 0000006cH
	mov	eax, DWORD PTR _pch$6[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$6[ebp], eax

; 276  :                         *pch++ = 't';

	mov	ecx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [ecx], 116			; 00000074H
	mov	edx, DWORD PTR _pch$6[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$6[ebp], edx

; 277  :                         *pch++ = ';';

	mov	eax, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [eax], 59			; 0000003bH
	mov	ecx, DWORD PTR _pch$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$6[ebp], ecx

; 278  :                         break;

	jmp	$LN8@fnAppendKe
$LN28@fnAppendKe:

; 279  : 
; 280  :                      case '>':
; 281  :                         *pch++ = '&';

	mov	edx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [edx], 38			; 00000026H
	mov	eax, DWORD PTR _pch$6[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$6[ebp], eax

; 282  :                         *pch++ = 'g';

	mov	ecx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [ecx], 103			; 00000067H
	mov	edx, DWORD PTR _pch$6[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$6[ebp], edx

; 283  :                         *pch++ = 't';

	mov	eax, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [eax], 116			; 00000074H
	mov	ecx, DWORD PTR _pch$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$6[ebp], ecx

; 284  :                         *pch++ = ';';

	mov	edx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
	mov	eax, DWORD PTR _pch$6[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$6[ebp], eax

; 285  :                         break;

	jmp	$LN8@fnAppendKe
$LN29@fnAppendKe:

; 286  : 
; 287  :                      case '\'':
; 288  :                         *pch++ = '&';

	mov	ecx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [ecx], 38			; 00000026H
	mov	edx, DWORD PTR _pch$6[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$6[ebp], edx

; 289  :                         *pch++ = 'a';

	mov	eax, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [eax], 97			; 00000061H
	mov	ecx, DWORD PTR _pch$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$6[ebp], ecx

; 290  :                         *pch++ = 'p';

	mov	edx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [edx], 112			; 00000070H
	mov	eax, DWORD PTR _pch$6[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$6[ebp], eax

; 291  :                         *pch++ = 'o';

	mov	ecx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [ecx], 111			; 0000006fH
	mov	edx, DWORD PTR _pch$6[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$6[ebp], edx

; 292  :                         *pch++ = 's';

	mov	eax, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [eax], 115			; 00000073H
	mov	ecx, DWORD PTR _pch$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$6[ebp], ecx

; 293  :                         *pch++ = ';';

	mov	edx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
	mov	eax, DWORD PTR _pch$6[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$6[ebp], eax

; 294  :                         break;

	jmp	$LN8@fnAppendKe
$LN30@fnAppendKe:

; 295  : 
; 296  :                      case '\"':
; 297  :                         *pch++ = '&';

	mov	ecx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [ecx], 38			; 00000026H
	mov	edx, DWORD PTR _pch$6[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$6[ebp], edx

; 298  :                         *pch++ = 'q';

	mov	eax, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [eax], 113			; 00000071H
	mov	ecx, DWORD PTR _pch$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$6[ebp], ecx

; 299  :                         *pch++ = 'u';

	mov	edx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [edx], 117			; 00000075H
	mov	eax, DWORD PTR _pch$6[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$6[ebp], eax

; 300  :                         *pch++ = 'o';

	mov	ecx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [ecx], 111			; 0000006fH
	mov	edx, DWORD PTR _pch$6[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$6[ebp], edx

; 301  :                         *pch++ = 't';

	mov	eax, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [eax], 116			; 00000074H
	mov	ecx, DWORD PTR _pch$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$6[ebp], ecx

; 302  :                         *pch++ = ';';

	mov	edx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [edx], 59			; 0000003bH
	mov	eax, DWORD PTR _pch$6[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$6[ebp], eax

; 303  :                         break;

	jmp	$LN8@fnAppendKe
$LN31@fnAppendKe:

; 304  : 
; 305  :                      case '\n':
; 306  :                      case '\r':
; 307  :                      case '\t':
; 308  :                         *pch++ = *pchAttribValue;

	mov	ecx, DWORD PTR _pch$6[ebp]
	mov	edx, DWORD PTR _pchAttribValue$5[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	mov	ecx, DWORD PTR _pch$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$6[ebp], ecx

; 309  :                         break;

	jmp	$LN8@fnAppendKe
$LN32@fnAppendKe:

; 310  : 
; 311  :                      default:
; 312  :                         if ( *pchAttribValue < 32 || *pchAttribValue > 127 )

	mov	edx, DWORD PTR _pchAttribValue$5[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 32					; 00000020H
	jl	SHORT $LN35@fnAppendKe
	mov	ecx, DWORD PTR _pchAttribValue$5[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 127				; 0000007fH
	jle	$LN33@fnAppendKe
$LN35@fnAppendKe:

; 313  :                         {
; 314  :                            // Convert the char to '&#ddd;' where 'ddd' is its ASCII value.
; 315  :                            *pch++ = '&';

	mov	eax, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [eax], 38			; 00000026H
	mov	ecx, DWORD PTR _pch$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$6[ebp], ecx

; 316  :                            *pch++ = '#';

	mov	edx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [edx], 35			; 00000023H
	mov	eax, DWORD PTR _pch$6[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$6[ebp], eax

; 317  :                            zltoa( (zLONG) (zUCHAR) *pchAttribValue, pch );

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _pch$6[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchAttribValue$5[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	DWORD PTR __imp___ltoa
	add	esp, 12					; 0000000cH
$LN10@fnAppendKe:

; 318  :                            while ( *++pch );       // Skip to null terminator.

	mov	ecx, DWORD PTR _pch$6[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$6[ebp], ecx
	mov	edx, DWORD PTR _pch$6[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN11@fnAppendKe
	jmp	SHORT $LN10@fnAppendKe
$LN11@fnAppendKe:

; 319  :                            *pch++ = ';';

	mov	ecx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [ecx], 59			; 0000003bH
	mov	edx, DWORD PTR _pch$6[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$6[ebp], edx

; 320  :                         }

	jmp	SHORT $LN8@fnAppendKe
$LN33@fnAppendKe:

; 321  :                         else
; 322  :                            *pch++ = *pchAttribValue;

	mov	eax, DWORD PTR _pch$6[ebp]
	mov	ecx, DWORD PTR _pchAttribValue$5[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl
	mov	eax, DWORD PTR _pch$6[ebp]
	add	eax, 1
	mov	DWORD PTR _pch$6[ebp], eax
$LN8@fnAppendKe:

; 323  : 
; 324  :                         break;
; 325  : 
; 326  :                   } // switch ( *pchAttribValue )...
; 327  : 
; 328  :                } // for...

	jmp	$LN5@fnAppendKe
$LN6@fnAppendKe:

; 329  : 
; 330  :                // Now that we've translated the attribute's value into the
; 331  :                // temp buffer set attrib value ptr to point to the buffer.
; 332  :                *pch++ = 0;

	mov	ecx, DWORD PTR _pch$6[ebp]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _pch$6[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$6[ebp], edx

; 333  :                ulLth = (zLONG) (pch - pchTempValueBuffer) - 1;

	mov	eax, DWORD PTR _pch$6[ebp]
	sub	eax, DWORD PTR _pchTempValueBuffer$[ebp]
	sub	eax, 1
	mov	DWORD PTR _ulLth$[ebp], eax

; 334  :                //pchAttribValue = pchTempValueBuffer;
; 335  :                zstrcpy( szAttribIdent, pchTempValueBuffer );

	mov	ecx, DWORD PTR _pchTempValueBuffer$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szAttribIdent$7[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 336  : 
; 337  :             } // if contains special chars

	jmp	SHORT $LN19@fnAppendKe
$LN21@fnAppendKe:

; 338  :             else
; 339  :             {
; 340  :                zstrcpy( szAttribIdent, pchAttribValue );

	mov	eax, DWORD PTR _pchAttribValue$5[ebp]
	push	eax
	lea	ecx, DWORD PTR _szAttribIdent$7[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 341  :                ulLth = zstrlen( szAttribIdent );

	lea	edx, DWORD PTR _szAttribIdent$7[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax
$LN19@fnAppendKe:

; 342  :             }
; 343  : 
; 344  :          } // pchAttribValue non-NULL
; 345  : 
; 346  :       } // if ( lpViewAttrib->cType == zTYPE_STRING )...

	jmp	SHORT $LN15@fnAppendKe
$LN16@fnAppendKe:

; 347  :       else
; 348  :       {
; 349  :          // Get attr value.  If return is -1 then the attr is NULL.
; 350  :          if ( GetStringFromRecord( lpWriteInfo->vTemp, lpViewEntity, lpViewAttrib,
; 351  :                                    szAttribIdent,
; 352  :                                    sizeof( szAttribIdent ) ) == -1 )

	push	500					; 000001f4H
	lea	eax, DWORD PTR _szAttribIdent$7[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpViewAttrib$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_GetStringFromRecord@20
	movsx	edx, ax
	cmp	edx, -1
	jne	SHORT $LN36@fnAppendKe

; 353  :          {
; 354  :             // Attr is NULL.  Skip null attributes if flag is set.
; 355  :             szAttribIdent[ 0 ] = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 500			; 000001f4H
	jae	SHORT $LN42@fnAppendKe
	jmp	SHORT $LN43@fnAppendKe
$LN42@fnAppendKe:
	call	___report_rangecheckfailure
$LN43@fnAppendKe:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szAttribIdent$7[ebp+edx], 0

; 356  :             ulLth = 0;

	mov	DWORD PTR _ulLth$[ebp], 0

; 357  :          }

	jmp	SHORT $LN15@fnAppendKe
$LN36@fnAppendKe:

; 358  :          else
; 359  :          {
; 360  :             ulLth = zstrlen( szAttribIdent );

	lea	eax, DWORD PTR _szAttribIdent$7[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	DWORD PTR _ulLth$[ebp], eax
$LN15@fnAppendKe:

; 361  :          }
; 362  :       }
; 363  : 
; 364  :       // Append the key attribute name and vaue to entity buffer.
; 365  :       zsprintf( &lpWriteInfo->szBuffer[ zstrlen( lpWriteInfo->szBuffer ) ],

	lea	ecx, DWORD PTR _szAttribIdent$7[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpViewAttrib$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG13770
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	call	_strlen
	add	esp, 4
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	lea	edx, DWORD PTR [ecx+eax+20]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H

; 366  :                 " %s=\"%s\"", lpViewAttrib->szName, szAttribIdent );
; 367  : 
; 368  :    } // for each lpViewAttrib...

	jmp	$LN2@fnAppendKe
$LN3@fnAppendKe:

; 369  : 
; 370  :    nReturn = 0;

	xor	eax, eax
	mov	WORD PTR _nReturn$[ebp], ax
$EndOfFunction$46:

; 371  : 
; 372  : EndOfFunction:
; 373  :    if ( pchTempValueBuffer )

	cmp	DWORD PTR _pchTempValueBuffer$[ebp], 0
	je	SHORT $LN38@fnAppendKe

; 374  :       SysFreeMemory( hTempValueBuffer );

	mov	ecx, DWORD PTR _hTempValueBuffer$[ebp]
	push	ecx
	call	_SysFreeMemory@4
$LN38@fnAppendKe:

; 375  : 
; 376  :    return( nReturn );

	mov	ax, WORD PTR _nReturn$[ebp]
$LN39@fnAppendKe:

; 377  : 
; 378  : } // fnWriteKeyAttribs

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN45@fnAppendKe:
	DD	$LN31@fnAppendKe
	DD	$LN30@fnAppendKe
	DD	$LN26@fnAppendKe
	DD	$LN29@fnAppendKe
	DD	$LN27@fnAppendKe
	DD	$LN28@fnAppendKe
	DD	$LN32@fnAppendKe
$LN44@fnAppendKe:
	DB	0
	DB	0
	DB	6
	DB	6
	DB	0
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	1
	DB	6
	DB	6
	DB	6
	DB	2
	DB	3
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	6
	DB	4
	DB	6
	DB	5
_fnAppendKeyAttribs@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
tv68 = -12						; size = 4
_lRC$ = -8						; size = 4
_pch$ = -4						; size = 4
_pchAttribValue$ = 8					; size = 4
_fnContainsSpecialChar@4 PROC

; 143  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 144  :    zPCHAR pch;
; 145  :    zLONG  lRC = 0;

	mov	DWORD PTR _lRC$[ebp], 0

; 146  : 
; 147  :    for ( pch = pchAttribValue; *pch; pch++ )

	mov	eax, DWORD PTR _pchAttribValue$[ebp]
	mov	DWORD PTR _pch$[ebp], eax
	jmp	SHORT $LN4@fnContains
$LN2@fnContains:
	mov	ecx, DWORD PTR _pch$[ebp]
	add	ecx, 1
	mov	DWORD PTR _pch$[ebp], ecx
$LN4@fnContains:
	mov	edx, DWORD PTR _pch$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN3@fnContains

; 148  :    {
; 149  :       switch ( *pch )

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv68[ebp], edx
	mov	eax, DWORD PTR tv68[ebp]
	sub	eax, 9
	mov	DWORD PTR tv68[ebp], eax
	cmp	DWORD PTR tv68[ebp], 53			; 00000035H
	ja	SHORT $LN9@fnContains
	mov	ecx, DWORD PTR tv68[ebp]
	movzx	edx, BYTE PTR $LN13@fnContains[ecx]
	jmp	DWORD PTR $LN14@fnContains[edx*4]
$LN7@fnContains:

; 150  :       {
; 151  :          case '&':
; 152  :          case '<':
; 153  :          case '>':
; 154  :          case '\'':
; 155  :          case '\"':
; 156  :             lRC++;

	mov	eax, DWORD PTR _lRC$[ebp]
	add	eax, 1
	mov	DWORD PTR _lRC$[ebp], eax

; 157  :             break;

	jmp	SHORT $LN5@fnContains
$LN8@fnContains:

; 158  : 
; 159  :          case '\n':
; 160  :          case '\r':
; 161  :          case '\t':
; 162  :             // These chars are alright so just break.
; 163  :             break;

	jmp	SHORT $LN5@fnContains
$LN9@fnContains:

; 164  : 
; 165  :          default:
; 166  :             if ( *pch < 32 || *pch > 127 )

	mov	ecx, DWORD PTR _pch$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 32					; 00000020H
	jl	SHORT $LN11@fnContains
	mov	eax, DWORD PTR _pch$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 127				; 0000007fH
	jle	SHORT $LN5@fnContains
$LN11@fnContains:

; 167  :                lRC++;

	mov	edx, DWORD PTR _lRC$[ebp]
	add	edx, 1
	mov	DWORD PTR _lRC$[ebp], edx
$LN5@fnContains:

; 168  : 
; 169  :             break;
; 170  : 
; 171  :       } // switch ( *pchAttribValue )...
; 172  :    }

	jmp	SHORT $LN2@fnContains
$LN3@fnContains:

; 173  : 
; 174  :    return( lRC );

	mov	eax, DWORD PTR _lRC$[ebp]

; 175  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN14@fnContains:
	DD	$LN8@fnContains
	DD	$LN7@fnContains
	DD	$LN9@fnContains
$LN13@fnContains:
	DB	0
	DB	0
	DB	2
	DB	2
	DB	0
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	2
	DB	2
	DB	1
	DB	1
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	2
	DB	1
	DB	2
	DB	1
_fnContainsSpecialChar@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_lpAbstractEntity$1 = -40				; size = 4
tv180 = -36						; size = 4
tv179 = -32						; size = 4
tv155 = -28						; size = 4
tv154 = -24						; size = 4
_lSkipAttribFlag$ = -20					; size = 4
_lpViewEntity$ = -16					; size = 4
_lpAbstractChild$2 = -12				; size = 4
_pchEntityName$ = -8					; size = 4
_lpChildInstance$ = -4					; size = 4
_lpTaskView$ = 8					; size = 4
_lpWriteInfo$ = 12					; size = 4
_lpEntityInstance$ = 16					; size = 4
_fnConvertEntity@12 PROC

; 1411 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 1412 :    LPENTITYINSTANCE lpChildInstance;
; 1413 :    LPVIEWENTITY     lpViewEntity = zGETPTR( lpEntityInstance->hViewEntity );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+2]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewEntity$[ebp], eax

; 1414 :    zPCHAR           pchEntityName;
; 1415 :    zULONG           lSkipAttribFlag = 0;

	mov	DWORD PTR _lSkipAttribFlag$[ebp], 0

; 1416 : 
; 1417 :    // If entity is "dead" then don't worry about it or it's children.
; 1418 :    if ( fnEntityInstanceIsDead( lpEntityInstance ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	call	_fnEntityInstanceIsDead@4
	cwde
	test	eax, eax
	je	SHORT $LN7@fnConvertE

; 1419 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnConvertE
$LN7@fnConvertE:

; 1420 : 
; 1421 :    // Skip hidden instances unless we are sending incremental flags.
; 1422 :    if ( lpEntityInstance->u.nInd.bHidden )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 10					; 0000000aH
	and	edx, 1
	je	SHORT $LN8@fnConvertE

; 1423 :    {
; 1424 :       if ( (lpWriteInfo->lControl & zXML_INCREFLAGS) == 0 )

	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	and	ecx, 2
	jne	SHORT $LN9@fnConvertE

; 1425 :          return( 0 );  // Nope...skip hidden instances.

	xor	eax, eax
	jmp	$LN1@fnConvertE
$LN9@fnConvertE:

; 1426 : 
; 1427 :       // Turn off the hidden flag so we can write it's values.
; 1428 :       lpEntityInstance->u.nInd.bHidden = FALSE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	and	eax, -1025				; fffffbffH
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN8@fnConvertE:

; 1429 :    }
; 1430 : 
; 1431 :    // If the entity is an abstract child then the attribute values have
; 1432 :    // already been written so don't write it.
; 1433 :    // If the UPDATEDONLY flag is on we only want to write entities that have
; 1434 :    // been updated.
; 1435 :    if ( lpViewEntity->bAbstractChild == FALSE &&

	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	mov	eax, DWORD PTR [edx+239]
	shr	eax, 12					; 0000000cH
	and	eax, 1
	jne	$LN10@fnConvertE
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	and	edx, 4
	je	SHORT $LN11@fnConvertE
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 2
	and	ecx, 1
	jne	SHORT $LN11@fnConvertE
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 1
	and	eax, 1
	jne	SHORT $LN11@fnConvertE
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	jne	SHORT $LN11@fnConvertE
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 5
	and	ecx, 1
	jne	SHORT $LN11@fnConvertE
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	je	$LN10@fnConvertE
$LN11@fnConvertE:

; 1436 :         ((lpWriteInfo->lControl & zXML_UPDATEDONLY) == 0 ||
; 1437 :           lpEntityInstance->u.nInd.bUpdated  ||
; 1438 :           lpEntityInstance->u.nInd.bCreated  ||
; 1439 :           lpEntityInstance->u.nInd.bDeleted  ||
; 1440 :           lpEntityInstance->u.nInd.bIncluded ||
; 1441 :           lpEntityInstance->u.nInd.bExcluded) )
; 1442 :    {
; 1443 :       LPENTITYINSTANCE lpAbstractChild = 0;

	mov	DWORD PTR _lpAbstractChild$2[ebp], 0

; 1444 : 
; 1445 :       pchEntityName = lpViewEntity->szName;

	mov	ecx, DWORD PTR _lpViewEntity$[ebp]
	add	ecx, 14					; 0000000eH
	mov	DWORD PTR _pchEntityName$[ebp], ecx

; 1446 :       if ( (lpWriteInfo->lControl & 256 ) &&

	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 256				; 00000100H
	je	$LN12@fnConvertE
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14242
	cmp	edx, eax
	jne	SHORT $LN26@fnConvertE
	push	OFFSET $SG14243
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv155[ebp], eax
	jmp	SHORT $LN27@fnConvertE
$LN26@fnConvertE:
	mov	edx, DWORD PTR _pchEntityName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG14244
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN24@fnConvertE
	mov	DWORD PTR tv154[ebp], 1
	jmp	SHORT $LN25@fnConvertE
$LN24@fnConvertE:
	mov	DWORD PTR tv154[ebp], -1
$LN25@fnConvertE:
	mov	edx, DWORD PTR tv154[ebp]
	mov	DWORD PTR tv155[ebp], edx
$LN27@fnConvertE:
	cmp	DWORD PTR tv155[ebp], 0
	jne	SHORT $LN12@fnConvertE

; 1447 :            zstrcmp( pchEntityName, "Control" ) == 0 )
; 1448 :       {
; 1449 :          fnEstablishViewForInstance( lpWriteInfo->vOI, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1450 :          fnWriteControlEntry( lpTaskView, lpWriteInfo,

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movzx	edx, WORD PTR [ecx+58]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_fnWriteControlEntry@16

; 1451 :                               lpEntityInstance->nLevel, lpEntityInstance );
; 1452 :          lSkipAttribFlag = 1;

	mov	DWORD PTR _lSkipAttribFlag$[ebp], 1

; 1453 :       }

	jmp	$LN13@fnConvertE
$LN12@fnConvertE:

; 1454 :       else
; 1455 :          if ( (lpWriteInfo->lControl & 256 ) &&

	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+12]
	and	eax, 256				; 00000100H
	je	$LN14@fnConvertE
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	movsx	edx, BYTE PTR [ecx]
	movsx	eax, BYTE PTR $SG14247
	cmp	edx, eax
	jne	SHORT $LN30@fnConvertE
	push	OFFSET $SG14248
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	call	_strcmp
	add	esp, 8
	mov	DWORD PTR tv180[ebp], eax
	jmp	SHORT $LN31@fnConvertE
$LN30@fnConvertE:
	mov	edx, DWORD PTR _pchEntityName$[ebp]
	movsx	eax, BYTE PTR [edx]
	movsx	ecx, BYTE PTR $SG14249
	sub	eax, ecx
	test	eax, eax
	jle	SHORT $LN28@fnConvertE
	mov	DWORD PTR tv179[ebp], 1
	jmp	SHORT $LN29@fnConvertE
$LN28@fnConvertE:
	mov	DWORD PTR tv179[ebp], -1
$LN29@fnConvertE:
	mov	edx, DWORD PTR tv179[ebp]
	mov	DWORD PTR tv180[ebp], edx
$LN31@fnConvertE:
	cmp	DWORD PTR tv180[ebp], 0
	jne	SHORT $LN14@fnConvertE

; 1456 :               zstrcmp( pchEntityName, "ListEntryValue" ) == 0 )
; 1457 :          {
; 1458 :             fnEstablishViewForInstance( lpWriteInfo->vOI, 0, lpEntityInstance );

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1459 :             fnWriteListEntryValue( lpTaskView, lpWriteInfo,

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movzx	edx, WORD PTR [ecx+58]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_fnWriteListEntryValue@16

; 1460 :                                    lpEntityInstance->nLevel,
; 1461 :                                    lpEntityInstance );
; 1462 :             lSkipAttribFlag = 1;

	mov	DWORD PTR _lSkipAttribFlag$[ebp], 1

; 1463 :          }

	jmp	SHORT $LN13@fnConvertE
$LN14@fnConvertE:

; 1464 :          else
; 1465 :          {
; 1466 :             lpAbstractChild = fnWriteEntityStartTag( lpTaskView, lpWriteInfo,

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_fnWriteEntityStartTag@12
	mov	DWORD PTR _lpAbstractChild$2[ebp], eax

; 1467 :                                                      lpEntityInstance );
; 1468 : 
; 1469 :             // Write the attribs for the entity.
; 1470 :             fnWriteAttribs( lpTaskView, lpWriteInfo,

	push	0
	mov	edx, DWORD PTR _lpViewEntity$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	add	ecx, 1
	push	ecx
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpTaskView$[ebp]
	push	eax
	call	_fnWriteAttribs@20
$LN13@fnConvertE:

; 1471 :                             (zSHORT) (lpEntityInstance->nLevel + 1), lpViewEntity, 0 );
; 1472 :          }
; 1473 : 
; 1474 :       // If the entity is abstract write the attribs of the abstract child.
; 1475 :       if ( lpAbstractChild )

	cmp	DWORD PTR _lpAbstractChild$2[ebp], 0
	je	SHORT $LN10@fnConvertE

; 1476 :       {
; 1477 :          LPVIEWENTITY lpAbstractEntity = zGETPTR( lpAbstractChild->hViewEntity );

	mov	ecx, DWORD PTR _lpAbstractChild$2[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpAbstractEntity$1[ebp], eax

; 1478 : 
; 1479 :          // Set entity cursor to point to abstract child.
; 1480 :          fnEstablishViewForInstance( lpWriteInfo->vOI, 0, lpAbstractChild );

	mov	eax, DWORD PTR _lpAbstractChild$2[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_fnEstablishViewForInstance
	add	esp, 12					; 0000000cH

; 1481 : 
; 1482 :          // Write attribs for abstract child.  Note that we use the level of the parent.
; 1483 :          fnWriteAttribs( lpTaskView, lpWriteInfo,

	push	0
	mov	eax, DWORD PTR _lpAbstractEntity$1[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	add	edx, 1
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_fnWriteAttribs@20
$LN10@fnConvertE:

; 1484 :                          (zSHORT) (lpEntityInstance->nLevel + 1), lpAbstractEntity, 0 );
; 1485 :       }
; 1486 : 
; 1487 :    } // if ( lpViewEntity->bAbstractChild == FALSE )...
; 1488 : 
; 1489 :    // Now write the child instances.
; 1490 :    if ( lSkipAttribFlag == 0 )

	cmp	DWORD PTR _lSkipAttribFlag$[ebp], 0
	jne	$LN17@fnConvertE

; 1491 :    {
; 1492 :       for ( lpChildInstance = zGETPTR( lpEntityInstance->hNextHier );

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildInstance$[ebp], eax
	jmp	SHORT $LN4@fnConvertE
$LN2@fnConvertE:

; 1494 :             lpChildInstance = zGETPTR( lpChildInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpChildInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildInstance$[ebp], eax
$LN4@fnConvertE:

; 1493 :             lpChildInstance;

	cmp	DWORD PTR _lpChildInstance$[ebp], 0
	je	SHORT $LN17@fnConvertE

; 1495 :       {
; 1496 :          // If the child instance is at the same level as the current instance
; 1497 :          // then there are no more children of lpEntityInstance.
; 1498 :          if ( lpChildInstance->nLevel <= lpEntityInstance->nLevel )

	mov	eax, DWORD PTR _lpChildInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	cmp	ecx, eax
	jg	SHORT $LN18@fnConvertE

; 1499 :             break;

	jmp	SHORT $LN17@fnConvertE
$LN18@fnConvertE:

; 1500 : 
; 1501 :          // If lpChildInstance is not a direct child of lpEntityInstance then
; 1502 :          // skip it (and it's twins if it has any).
; 1503 :          if ( lpChildInstance->nLevel > lpEntityInstance->nLevel + 1 )

	mov	ecx, DWORD PTR _lpChildInstance$[ebp]
	movsx	edx, WORD PTR [ecx+58]
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	add	ecx, 1
	cmp	edx, ecx
	jle	SHORT $LN19@fnConvertE
$LN5@fnConvertE:

; 1504 :          {
; 1505 :             while ( lpChildInstance->hNextTwin )

	mov	edx, DWORD PTR _lpChildInstance$[ebp]
	cmp	DWORD PTR [edx+22], 0
	je	SHORT $LN6@fnConvertE

; 1506 :                lpChildInstance = zGETPTR( lpChildInstance->hNextTwin );

	mov	eax, DWORD PTR _lpChildInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpChildInstance$[ebp], eax
	jmp	SHORT $LN5@fnConvertE
$LN6@fnConvertE:

; 1507 : 
; 1508 :             continue;

	jmp	SHORT $LN2@fnConvertE
$LN19@fnConvertE:

; 1509 :          }
; 1510 : 
; 1511 :          // Write the child instance to the XML stream.
; 1512 :          if ( fnConvertEntity( lpTaskView, lpWriteInfo, lpChildInstance ) != 0 )

	mov	edx, DWORD PTR _lpChildInstance$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	call	_fnConvertEntity@12
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN20@fnConvertE

; 1513 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@fnConvertE
$LN20@fnConvertE:

; 1514 :       }

	jmp	SHORT $LN2@fnConvertE
$LN17@fnConvertE:

; 1515 :    }
; 1516 : 
; 1517 :    // If we wrote a start tag for this entity then we need to write an 'end' tag.
; 1518 :    if ( lpWriteInfo->pchEntityName[ lpEntityInstance->nLevel ] != 0 )

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	cmp	DWORD PTR [edx+ecx*4+10020], 0
	je	SHORT $LN21@fnConvertE

; 1519 :    {
; 1520 :       zsprintf( lpWriteInfo->szBuffer, "</%s>",

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	movsx	ecx, WORD PTR [eax+58]
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4+10020]
	push	eax
	push	OFFSET $SG14256
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	add	ecx, 20					; 00000014H
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1521 :                 lpWriteInfo->pchEntityName[ lpEntityInstance->nLevel ] );
; 1522 : 
; 1523 :       if ( (*lpWriteInfo->lpfnWrite)( lpTaskView, zXML_ENDENTITY,
; 1524 :                                       lpWriteInfo->szBuffer, 0,
; 1525 :                                       lpEntityInstance->nLevel,
; 1526 :                                       lpWriteInfo->lpPtr ) == zCALL_ERROR )

	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+10424]
	push	eax
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	movzx	edx, WORD PTR [ecx+58]
	push	edx
	push	0
	mov	eax, DWORD PTR _lpWriteInfo$[ebp]
	add	eax, 20					; 00000014H
	push	eax
	push	8
	mov	ecx, DWORD PTR _lpTaskView$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpWriteInfo$[ebp]
	mov	eax, DWORD PTR [edx+10420]
	call	eax
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN22@fnConvertE

; 1527 :       {
; 1528 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@fnConvertE
$LN22@fnConvertE:

; 1529 :       }
; 1530 : 
; 1531 :       // We've written the end tag so set the entity name in the "entity
; 1532 :       // stack" to 0 to indicate it's been written.
; 1533 :       lpWriteInfo->pchEntityName[ lpEntityInstance->nLevel ] = 0;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	movsx	eax, WORD PTR [edx+58]
	mov	ecx, DWORD PTR _lpWriteInfo$[ebp]
	mov	DWORD PTR [ecx+eax*4+10020], 0
$LN21@fnConvertE:

; 1534 :    }
; 1535 : 
; 1536 :    return( 0 );

	xor	eax, eax
$LN1@fnConvertE:

; 1537 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_fnConvertEntity@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_lpViewOD$ = -5900					; size = 4
_pchBuffer$ = -5896					; size = 4
_ulLth$ = -5892						; size = 4
tv71 = -5888						; size = 4
_bDone$ = -5884						; size = 4
_lpViewCsr$1 = -5880					; size = 4
_l$ = -5876						; size = 4
_bSystemObj$ = -5869					; size = 1
_parser$ = -5868					; size = 4
_nRC$ = -5864						; size = 2
_ParserInfo$ = -5860					; size = 4853
_szMsg$2 = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_lppView$ = 8						; size = 4
_pchOD_Name$ = 12					; size = 4
_vSubtask$ = 16						; size = 4
_lControl$ = 20						; size = 4
_pfnRead$ = 24						; size = 4
_lpPtr$ = 28						; size = 4
_ActivateOI_FromXML@24 PROC

; 2582 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 5900				; 0000170cH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2583 :    zPCHAR           pchBuffer;
; 2584 :    zULONG           ulLth;
; 2585 :    zLONG            l;
; 2586 :    zBOOL            bSystemObj;
; 2587 :    LPVIEWOD         lpViewOD;
; 2588 :    int              bDone      = FALSE;

	mov	DWORD PTR _bDone$[ebp], 0

; 2589 :    XML_Parser       parser     = XML_ParserCreate( 0 );

	push	0
	call	_XML_ParserCreate
	add	esp, 4
	mov	DWORD PTR _parser$[ebp], eax

; 2590 :    ParserInfoRecord ParserInfo = { 0 };

	xor	eax, eax
	mov	WORD PTR _ParserInfo$[ebp], ax
	push	4851					; 000012f3H
	push	0
	lea	ecx, DWORD PTR _ParserInfo$[ebp+2]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 2591 :    zSHORT           nRC        = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 2592 : 
; 2593 :    bSystemObj = (lControl & zACTIVATE_SYSTEM) ? TRUE : FALSE;

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 536870912				; 20000000H
	je	SHORT $LN25@ActivateOI
	mov	DWORD PTR tv71[ebp], 1
	jmp	SHORT $LN26@ActivateOI
$LN25@ActivateOI:
	mov	DWORD PTR tv71[ebp], 0
$LN26@ActivateOI:
	mov	cl, BYTE PTR tv71[ebp]
	mov	BYTE PTR _bSystemObj$[ebp], cl

; 2594 : 
; 2595 :    // Verify only one zLEVEL_ option requested
; 2596 :    l = lControl & (zLEVEL_APPLICATION | zLEVEL_SYSTEM | zLEVEL_SAME);

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1036				; 0000040cH
	mov	DWORD PTR _l$[ebp], edx

; 2597 :    if ( l && (-l & l) != l )

	je	SHORT $LN6@ActivateOI
	mov	eax, DWORD PTR _l$[ebp]
	neg	eax
	and	eax, DWORD PTR _l$[ebp]
	cmp	eax, DWORD PTR _l$[ebp]
	je	SHORT $LN6@ActivateOI

; 2598 :    {
; 2599 :       // error, More than one zLEVEL_ option requested
; 2600 :       // "KZOEE023 - Invalid parameter, "
; 2601 :       fnIssueCoreError( zGETPTR( vSubtask->hTask ), vSubtask, 8, 23, 0,

	push	0
	push	OFFSET $SG14795
	push	0
	push	23					; 00000017H
	push	8
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	mov	eax, DWORD PTR [edx+14]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2602 :                         "More than one zLEVEL_ option requested", 0 );
; 2603 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ActivateOI
$LN6@ActivateOI:

; 2604 :    }
; 2605 : 
; 2606 :    // If zLEVEL_SAME is requested
; 2607 :    if ( lControl & zLEVEL_SAME )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 1024				; 00000400H
	je	$LN7@ActivateOI

; 2608 :    {
; 2609 :       if ( vSubtask == 0 || vSubtask->hSubtask )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $LN10@ActivateOI
	mov	edx, DWORD PTR _vSubtask$[ebp]
	cmp	DWORD PTR [edx+18], 0
	je	SHORT $LN8@ActivateOI
$LN10@ActivateOI:

; 2610 :       {
; 2611 :          // "KZOEE100 - Invalid View, view is a Subtask View"
; 2612 :          fnIssueCoreError( zGETPTR( vSubtask->hTask ), vSubtask, 8, 100, 0,

	push	OFFSET $SG14800
	push	OFFSET $SG14801
	push	0
	push	100					; 00000064H
	push	8
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	push	eax
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2613 :                            "vSubtask", "with zLEVEL_SAME" );
; 2614 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ActivateOI

; 2615 :       }

	jmp	$LN7@ActivateOI
$LN8@ActivateOI:

; 2616 :       else
; 2617 :       {
; 2618 :          LPVIEWCSR lpViewCsr;
; 2619 : 
; 2620 :          // Turn off the 'same' indicator
; 2621 :          lControl ^= zLEVEL_SAME;

	mov	eax, DWORD PTR _lControl$[ebp]
	xor	eax, 1024				; 00000400H
	mov	DWORD PTR _lControl$[ebp], eax

; 2622 :          // To determine what the level is of the qualifying view
; 2623 :          //   1. Change vSubtask to point to the initial
; 2624 :          //      view created for the object instance
; 2625 :          //   2. Check for application level, if there use
; 2626 :          //      zLEVEL_APPLICATION.
; 2627 :          //   3. Check if the view task is the main task, if so use
; 2628 :          //      zLEVEL_SYSTEM.
; 2629 :          //   4. Use the task level...
; 2630 :          lpViewCsr = zGETPTR( vSubtask->hViewCsr );

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax
$LN2@ActivateOI:

; 2631 :          while ( lpViewCsr->hNextViewCsr )

	mov	eax, DWORD PTR _lpViewCsr$1[ebp]
	cmp	DWORD PTR [eax+2], 0
	je	SHORT $LN3@ActivateOI

; 2632 :             lpViewCsr = zGETPTR( lpViewCsr->hNextViewCsr );

	mov	ecx, DWORD PTR _lpViewCsr$1[ebp]
	mov	edx, DWORD PTR [ecx+2]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$1[ebp], eax
	jmp	SHORT $LN2@ActivateOI
$LN3@ActivateOI:

; 2633 : 
; 2634 :          vSubtask = zGETPTR( lpViewCsr->hView );

	mov	eax, DWORD PTR _lpViewCsr$1[ebp]
	mov	ecx, DWORD PTR [eax+6]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _vSubtask$[ebp], eax

; 2635 :          if ( vSubtask->bApplicationView )

	mov	edx, DWORD PTR _vSubtask$[ebp]
	mov	eax, DWORD PTR [edx+30]
	shr	eax, 3
	and	eax, 1
	je	SHORT $LN11@ActivateOI

; 2636 :             lControl |= zLEVEL_APPLICATION;

	mov	ecx, DWORD PTR _lControl$[ebp]
	or	ecx, 4
	mov	DWORD PTR _lControl$[ebp], ecx
	jmp	SHORT $LN7@ActivateOI
$LN11@ActivateOI:

; 2637 :          else
; 2638 :          if ( vSubtask->hTask == AnchorBlock->hMainTask )

	mov	edx, DWORD PTR _vSubtask$[ebp]
	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [edx+14]
	cmp	ecx, DWORD PTR [eax+106]
	jne	SHORT $LN7@ActivateOI

; 2639 :             lControl |= zLEVEL_SYSTEM;

	mov	edx, DWORD PTR _lControl$[ebp]
	or	edx, 8
	mov	DWORD PTR _lControl$[ebp], edx
$LN7@ActivateOI:

; 2640 :       }
; 2641 :    }
; 2642 : 
; 2643 :    // Make sure request is for valid OD.
; 2644 :    lpViewOD = ActivateViewObject( vSubtask, pchOD_Name, bSystemObj );

	movzx	eax, BYTE PTR _bSystemObj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_ActivateViewObject@12
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 2645 :    if ( lpViewOD == 0 )

	cmp	DWORD PTR _lpViewOD$[ebp], 0
	jne	SHORT $LN14@ActivateOI

; 2646 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ActivateOI
$LN14@ActivateOI:

; 2647 : 
; 2648 :    ParserInfo.vSubtask = vSubtask;

	mov	eax, DWORD PTR _vSubtask$[ebp]
	mov	DWORD PTR _ParserInfo$[ebp+2], eax

; 2649 :    ParserInfo.nDepth   = 0;

	xor	ecx, ecx
	mov	WORD PTR _ParserInfo$[ebp], cx

; 2650 : 
; 2651 :    if ( pchOD_Name && *pchOD_Name )

	cmp	DWORD PTR _pchOD_Name$[ebp], 0
	je	SHORT $LN15@ActivateOI
	mov	edx, DWORD PTR _pchOD_Name$[ebp]
	movsx	eax, BYTE PTR [edx]
	test	eax, eax
	je	SHORT $LN15@ActivateOI

; 2652 :    {
; 2653 :       ParserInfo.lpViewOD = ActivateViewObject( vSubtask, pchOD_Name, 0 );

	push	0
	mov	ecx, DWORD PTR _pchOD_Name$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_ActivateViewObject@12
	mov	DWORD PTR _ParserInfo$[ebp+10], eax

; 2654 :       if ( ParserInfo.lpViewOD == 0 )

	cmp	DWORD PTR _ParserInfo$[ebp+10], 0
	jne	SHORT $LN15@ActivateOI

; 2655 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ActivateOI
$LN15@ActivateOI:

; 2656 :    }
; 2657 : 
; 2658 :    XML_SetUserData( parser, &ParserInfo );

	lea	eax, DWORD PTR _ParserInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _parser$[ebp]
	push	ecx
	call	_XML_SetUserData
	add	esp, 8

; 2659 :    XML_SetElementHandler( parser, startElement, endElement );

	push	OFFSET _endElement
	push	OFFSET _startElement
	mov	edx, DWORD PTR _parser$[ebp]
	push	edx
	call	_XML_SetElementHandler
	add	esp, 12					; 0000000cH

; 2660 :    XML_SetCharacterDataHandler( parser, GetElementData );

	push	OFFSET _GetElementData
	mov	eax, DWORD PTR _parser$[ebp]
	push	eax
	call	_XML_SetCharacterDataHandler
	add	esp, 8

; 2661 :    XML_SetUnknownEncodingHandler( parser, unknownEncodingHandler, 0 );

	push	0
	push	OFFSET _unknownEncodingHandler
	mov	ecx, DWORD PTR _parser$[ebp]
	push	ecx
	call	_XML_SetUnknownEncodingHandler
	add	esp, 12					; 0000000cH
$LN4@ActivateOI:

; 2662 : 
; 2663 :    while ( bDone == FALSE )

	cmp	DWORD PTR _bDone$[ebp], 0
	jne	$LN5@ActivateOI

; 2664 :    {
; 2665 :       bDone = (int) (*pfnRead)( *lppView, &pchBuffer, &ulLth, lpPtr );

	mov	edx, DWORD PTR _lpPtr$[ebp]
	push	edx
	lea	eax, DWORD PTR _ulLth$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lppView$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	DWORD PTR _pfnRead$[ebp]
	movsx	ecx, ax
	mov	DWORD PTR _bDone$[ebp], ecx

; 2666 :       if ( bDone )

	cmp	DWORD PTR _bDone$[ebp], 0
	je	SHORT $LN17@ActivateOI

; 2667 :          pchBuffer[ ulLth ] = 0;

	mov	edx, DWORD PTR _pchBuffer$[ebp]
	add	edx, DWORD PTR _ulLth$[ebp]
	mov	BYTE PTR [edx], 0
$LN17@ActivateOI:

; 2668 : 
; 2669 :       if ( !XML_Parse( parser, pchBuffer, ulLth, bDone ) )

	mov	eax, DWORD PTR _bDone$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ulLth$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _parser$[ebp]
	push	eax
	call	_XML_Parse
	add	esp, 16					; 00000010H
	test	eax, eax
	jne	SHORT $LN18@ActivateOI

; 2670 :       {
; 2671 :          zCHAR szMsg[ 1000 ];
; 2672 : 
; 2673 :          zsprintf( szMsg, "%s at line %d",

	mov	ecx, DWORD PTR _parser$[ebp]
	push	ecx
	call	_XML_GetCurrentLineNumber
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR _parser$[ebp]
	push	edx
	call	_XML_GetErrorCode
	add	esp, 4
	push	eax
	call	_XML_ErrorString
	add	esp, 4
	push	eax
	push	OFFSET $SG14810
	lea	eax, DWORD PTR _szMsg$2[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 2674 :                    XML_ErrorString( XML_GetErrorCode( parser ) ),
; 2675 :                    XML_GetCurrentLineNumber( parser ) );
; 2676 :          TraceLineS( "(xml) Error txt: ", szMsg );

	lea	ecx, DWORD PTR _szMsg$2[ebp]
	push	ecx
	push	OFFSET $SG14811
	call	_TraceLineS@8

; 2677 : 
; 2678 :          SysMessageBox( *lppView, "Error", "Error parsing XML", 1 );

	push	1
	push	OFFSET $SG14812
	push	OFFSET $SG14813
	mov	edx, DWORD PTR _lppView$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SysMessageBox@16

; 2679 :          nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 2680 :          break;

	jmp	SHORT $LN5@ActivateOI
$LN18@ActivateOI:

; 2681 :       }
; 2682 :    }

	jmp	$LN4@ActivateOI
$LN5@ActivateOI:

; 2683 : 
; 2684 :    XML_ParserFree( parser );

	mov	edx, DWORD PTR _parser$[ebp]
	push	edx
	call	_XML_ParserFree
	add	esp, 4

; 2685 : 
; 2686 :    if ( ParserInfo.pchAttributeBuffer )

	cmp	DWORD PTR _ParserInfo$[ebp+834], 0
	je	SHORT $LN19@ActivateOI

; 2687 :       free( ParserInfo.pchAttributeBuffer );

	mov	eax, DWORD PTR _ParserInfo$[ebp+834]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN19@ActivateOI:

; 2688 : 
; 2689 :    if ( ParserInfo.bFatalError )

	movzx	ecx, BYTE PTR _ParserInfo$[ebp+4850]
	test	ecx, ecx
	je	SHORT $LN20@ActivateOI

; 2690 :       nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx
$LN20@ActivateOI:

; 2691 : 
; 2692 :    if ( nRC == zCALL_ERROR )

	movsx	eax, WORD PTR _nRC$[ebp]
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN21@ActivateOI

; 2693 :    {
; 2694 :       if ( ParserInfo.vOI )

	cmp	DWORD PTR _ParserInfo$[ebp+6], 0
	je	SHORT $LN23@ActivateOI

; 2695 :          fnDropView( ParserInfo.vOI );

	mov	ecx, DWORD PTR _ParserInfo$[ebp+6]
	push	ecx
	call	_fnDropView@4
$LN23@ActivateOI:

; 2696 : 
; 2697 :       *lppView = 0;

	mov	edx, DWORD PTR _lppView$[ebp]
	mov	DWORD PTR [edx], 0

; 2698 :    }

	jmp	SHORT $LN22@ActivateOI
$LN21@ActivateOI:

; 2699 :    else
; 2700 :    {
; 2701 :       *lppView = ParserInfo.vOI;

	mov	eax, DWORD PTR _lppView$[ebp]
	mov	ecx, DWORD PTR _ParserInfo$[ebp+6]
	mov	DWORD PTR [eax], ecx

; 2702 :       fnResetView( *lppView, 0 );

	push	0
	mov	edx, DWORD PTR _lppView$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_fnResetView
	add	esp, 8
$LN22@ActivateOI:

; 2703 :    }
; 2704 : 
; 2705 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@ActivateOI:

; 2706 : 
; 2707 : } // ActivateOI_FromXML

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_ActivateOI_FromXML@24 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_lpViewOD$ = -11464					; size = 4
_lpApp$ = -11460					; size = 4
_lpViewOI$ = -11456					; size = 4
_lpViewCsr$ = -11452					; size = 4
_pch$ = -11448						; size = 4
_lpCurrentTask$ = -11444				; size = 4
_lpEntityInstance$ = -11440				; size = 4
_k$ = -11436						; size = 2
_WriteInfo$ = -11432					; size = 10428
_szBuffer$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_vOI$ = 8						; size = 4
_nViewCount$ = 12					; size = 2
_lControl$ = 16						; size = 4
_lpfnWrite$ = 20					; size = 4
_lpPtr$ = 24						; size = 4
_WriteMultipleOIs_ToXML@20 PROC

; 1770 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 11464				; 00002cc8H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1771 :    LPTASK            lpCurrentTask;
; 1772 :    zCHAR             szBuffer[ 1000 ];
; 1773 :    LPVIEWOI          lpViewOI;
; 1774 :    LPVIEWCSR         lpViewCsr;
; 1775 :    LPVIEWOD          lpViewOD;
; 1776 :    LPENTITYINSTANCE  lpEntityInstance;
; 1777 :    LPAPP             lpApp;
; 1778 :    WriteInfoRecord   WriteInfo = { 0 };

	mov	DWORD PTR _WriteInfo$[ebp], 0
	push	10424					; 000028b8H
	push	0
	lea	eax, DWORD PTR _WriteInfo$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1779 :    zPCHAR            pch;
; 1780 :    zSHORT            k;
; 1781 : 
; 1782 :    if ( nViewCount == 0 )

	movsx	ecx, WORD PTR _nViewCount$[ebp]
	test	ecx, ecx
	jne	SHORT $LN17@WriteMulti

; 1783 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@WriteMulti
$LN17@WriteMulti:

; 1784 : 
; 1785 :    // If task not active or disabled, return zCALL_ERROR.
; 1786 :    if ( (lpCurrentTask = fnOperationCall( iWriteOI_ToXML, vOI[ 0 ], 0 )) == 0 )

	push	0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _vOI$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	push	550					; 00000226H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN18@WriteMulti

; 1787 :    {
; 1788 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@WriteMulti
$LN18@WriteMulti:

; 1789 :    }
; 1790 : 
; 1791 :    for ( k = 0; k < nViewCount; k++ )

	xor	eax, eax
	mov	WORD PTR _k$[ebp], ax
	jmp	SHORT $LN4@WriteMulti
$LN2@WriteMulti:
	mov	cx, WORD PTR _k$[ebp]
	add	cx, 1
	mov	WORD PTR _k$[ebp], cx
$LN4@WriteMulti:
	movsx	edx, WORD PTR _k$[ebp]
	movsx	eax, WORD PTR _nViewCount$[ebp]
	cmp	edx, eax
	jge	SHORT $LN3@WriteMulti

; 1792 :    {
; 1793 :       if ( fnValidView( lpCurrentTask, vOI[ k ] ) == 0 )

	movsx	ecx, WORD PTR _k$[ebp]
	mov	edx, DWORD PTR _vOI$[ebp]
	mov	eax, DWORD PTR [edx+ecx*4]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidView
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN19@WriteMulti

; 1794 :       {
; 1795 :          fnOperationReturn( iWriteOI_ToXML, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	550					; 00000226H
	call	_fnOperationReturn
	add	esp, 8

; 1796 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@WriteMulti
$LN19@WriteMulti:

; 1797 :       }
; 1798 :    }

	jmp	SHORT $LN2@WriteMulti
$LN3@WriteMulti:

; 1799 : 
; 1800 :    lpViewOD = (LPVIEWOD) zGETPTR( vOI[ 0 ]->hViewOD );

	mov	ecx, 4
	imul	edx, ecx, 0
	mov	eax, DWORD PTR _vOI$[ebp]
	mov	ecx, DWORD PTR [eax+edx]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 1801 : 
; 1802 :    pch = "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>";

	mov	DWORD PTR _pch$[ebp], OFFSET $SG14402

; 1803 :    if ( (*lpfnWrite)( vOI[ 0 ], 0, pch, 0, 0, lpPtr ) == zCALL_ERROR )

	mov	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _pch$[ebp]
	push	ecx
	push	0
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _vOI$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	DWORD PTR _lpfnWrite$[ebp]
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN20@WriteMulti

; 1804 :    {
; 1805 :       fnOperationReturn( iWriteOI_ToXML, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	550					; 00000226H
	call	_fnOperationReturn
	add	esp, 8

; 1806 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@WriteMulti
$LN20@WriteMulti:

; 1807 :    }
; 1808 : 
; 1809 :    if ( lControl & zXML_ZEIDONINFO )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 1
	je	$LN21@WriteMulti

; 1810 :    {
; 1811 :       SfGetApplicationForSubtask( &lpApp, vOI[ 0 ] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _vOI$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	lea	ecx, DWORD PTR _lpApp$[ebp]
	push	ecx
	call	_SfGetApplicationForSubtask@8

; 1812 : 
; 1813 :       if ( lControl & zXML_INCREFLAGS )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2
	je	SHORT $LN22@WriteMulti

; 1814 :          zsprintf( szBuffer, "<zOI zObjectName=\"%s\" zAppName=\"%s\" "

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG14407
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN23@WriteMulti
$LN22@WriteMulti:

; 1815 :                    "zIncreFlags=\"Y\">", lpViewOD->szName, lpApp->szName );
; 1816 :       else
; 1817 :          zsprintf( szBuffer, "<zOI zObjectName=\"%s\" zAppName=\"%s\">",

	mov	eax, DWORD PTR _lpApp$[ebp]
	add	eax, 6
	push	eax
	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	add	ecx, 10					; 0000000aH
	push	ecx
	push	OFFSET $SG14408
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
$LN23@WriteMulti:

; 1818 :                    lpViewOD->szName, lpApp->szName );
; 1819 : 
; 1820 :       if ( (*lpfnWrite)( vOI[ 0 ], zXML_STARTOI, szBuffer, 0, 0, lpPtr ) == zCALL_ERROR )

	mov	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	push	1
	mov	edx, 4
	imul	eax, edx, 0
	mov	ecx, DWORD PTR _vOI$[ebp]
	mov	edx, DWORD PTR [ecx+eax]
	push	edx
	call	DWORD PTR _lpfnWrite$[ebp]
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN21@WriteMulti

; 1821 :       {
; 1822 :          fnOperationReturn( iWriteOI_ToXML, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	550					; 00000226H
	call	_fnOperationReturn
	add	esp, 8

; 1823 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@WriteMulti
$LN21@WriteMulti:

; 1824 :       }
; 1825 :    }
; 1826 : 
; 1827 :    WriteInfo.lControl  = lControl;

	mov	edx, DWORD PTR _lControl$[ebp]
	mov	DWORD PTR _WriteInfo$[ebp+12], edx

; 1828 :    WriteInfo.lpfnWrite = lpfnWrite;

	mov	eax, DWORD PTR _lpfnWrite$[ebp]
	mov	DWORD PTR _WriteInfo$[ebp+10420], eax

; 1829 :    WriteInfo.lpPtr     = lpPtr;

	mov	ecx, DWORD PTR _lpPtr$[ebp]
	mov	DWORD PTR _WriteInfo$[ebp+10424], ecx

; 1830 : 
; 1831 :    for ( k = 0; k < nViewCount; k++ )

	xor	edx, edx
	mov	WORD PTR _k$[ebp], dx
	jmp	SHORT $LN7@WriteMulti
$LN5@WriteMulti:
	mov	ax, WORD PTR _k$[ebp]
	add	ax, 1
	mov	WORD PTR _k$[ebp], ax
$LN7@WriteMulti:
	movsx	ecx, WORD PTR _k$[ebp]
	movsx	edx, WORD PTR _nViewCount$[ebp]
	cmp	ecx, edx
	jge	$LN6@WriteMulti

; 1832 :    {
; 1833 :       lpViewCsr = (LPVIEWCSR) zGETPTR( vOI[ k ]->hViewCsr );

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _vOI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1834 :       lpViewOI  = (LPVIEWOI)  zGETPTR( lpViewCsr->hViewOI );

	mov	ecx, DWORD PTR _lpViewCsr$[ebp]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1835 : 
; 1836 :       WriteInfo.vOI = vOI[ k ];

	movsx	eax, WORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _vOI$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR _WriteInfo$[ebp], edx

; 1837 : 
; 1838 :       for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	eax, DWORD PTR _lpViewOI$[ebp]
	mov	ecx, DWORD PTR [eax+26]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN10@WriteMulti
$LN8@WriteMulti:

; 1840 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN10@WriteMulti:

; 1839 :             lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN9@WriteMulti

; 1841 :       {
; 1842 :          if ( fnConvertEntity( vOI[ 0 ], &WriteInfo, lpEntityInstance ) != 0 )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	push	ecx
	lea	edx, DWORD PTR _WriteInfo$[ebp]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _vOI$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	call	_fnConvertEntity@12
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN25@WriteMulti

; 1843 :          {
; 1844 :             fnOperationReturn( iWriteOI_ToXML, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	550					; 00000226H
	call	_fnOperationReturn
	add	esp, 8

; 1845 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@WriteMulti
$LN25@WriteMulti:

; 1846 :          }
; 1847 :       }

	jmp	SHORT $LN8@WriteMulti
$LN9@WriteMulti:

; 1848 :    }

	jmp	$LN5@WriteMulti
$LN6@WriteMulti:

; 1849 : 
; 1850 :    if ( lControl & zXML_ZEIDONINFO )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1
	je	SHORT $LN26@WriteMulti

; 1851 :    {
; 1852 :       pch = "</zOI>";

	mov	DWORD PTR _pch$[ebp], OFFSET $SG14412

; 1853 :       if ( (*lpfnWrite)( vOI[ 0 ], zXML_ENDOI, pch, 0, 0, lpPtr ) == zCALL_ERROR )

	mov	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	push	2
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _vOI$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	call	DWORD PTR _lpfnWrite$[ebp]
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN26@WriteMulti

; 1854 :       {
; 1855 :          fnOperationReturn( iWriteOI_ToXML, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	550					; 00000226H
	call	_fnOperationReturn
	add	esp, 8

; 1856 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@WriteMulti
$LN26@WriteMulti:

; 1857 :       }
; 1858 :    }
; 1859 : 
; 1860 :    // If we are writing incre flags then we might have turned off some hidden
; 1861 :    // flags.  Turn them back on.
; 1862 :    if ( lControl & zXML_INCREFLAGS )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 2
	je	$LN28@WriteMulti

; 1863 :    {
; 1864 :       for ( k = 0; k < nViewCount; k++ )

	xor	ecx, ecx
	mov	WORD PTR _k$[ebp], cx
	jmp	SHORT $LN13@WriteMulti
$LN11@WriteMulti:
	mov	dx, WORD PTR _k$[ebp]
	add	dx, 1
	mov	WORD PTR _k$[ebp], dx
$LN13@WriteMulti:
	movsx	eax, WORD PTR _k$[ebp]
	movsx	ecx, WORD PTR _nViewCount$[ebp]
	cmp	eax, ecx
	jge	$LN28@WriteMulti

; 1865 :       {
; 1866 :          lpViewCsr = (LPVIEWCSR) zGETPTR( vOI[ k ]->hViewCsr );

	movsx	edx, WORD PTR _k$[ebp]
	mov	eax, DWORD PTR _vOI$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	edx, DWORD PTR [ecx+10]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1867 :          lpViewOI  = (LPVIEWOI)  zGETPTR( lpViewCsr->hViewOI );

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1868 : 
; 1869 :          for ( lpEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN16@WriteMulti
$LN14@WriteMulti:

; 1871 :                lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN16@WriteMulti:

; 1870 :                lpEntityInstance;

	cmp	DWORD PTR _lpEntityInstance$[ebp], 0
	je	SHORT $LN15@WriteMulti

; 1872 :          {
; 1873 :             if ( lpEntityInstance->u.nInd.bDeleted ||

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 3
	and	ecx, 1
	jne	SHORT $LN30@WriteMulti
	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	shr	eax, 4
	and	eax, 1
	je	SHORT $LN29@WriteMulti
$LN30@WriteMulti:

; 1874 :                  lpEntityInstance->u.nInd.bExcluded )
; 1875 :             {
; 1876 :                lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	or	edx, 1024				; 00000400H
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [eax+6], edx
$LN29@WriteMulti:

; 1877 :             }
; 1878 :          }

	jmp	SHORT $LN14@WriteMulti
$LN15@WriteMulti:

; 1879 :       }

	jmp	$LN11@WriteMulti
$LN28@WriteMulti:

; 1880 :    }
; 1881 : 
; 1882 :    fnOperationReturn( iWriteOI_ToXML, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	550					; 00000226H
	call	_fnOperationReturn
	add	esp, 8

; 1883 :    return( 0 );

	xor	eax, eax
$LN1@WriteMulti:

; 1884 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_WriteMultipleOIs_ToXML@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_lpCurrentTask$ = -8					; size = 4
_nRC$ = -4						; size = 2
_vOI$ = 8						; size = 4
_lControl$ = 12						; size = 4
_lpfnWrite$ = 16					; size = 4
_lpPtr$ = 20						; size = 4
_WriteOI_ToXML@16 PROC

; 1748 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1749 :    LPTASK            lpCurrentTask;
; 1750 :    zSHORT            nRC;
; 1751 : 
; 1752 :    // If task not active or disabled, return zCALL_ERROR.
; 1753 :    if ( (lpCurrentTask = fnOperationCall( iWriteOI_ToXML, vOI, 0 )) == 0 )

	push	0
	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	push	550					; 00000226H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@WriteOI_To

; 1754 :    {
; 1755 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@WriteOI_To
$LN2@WriteOI_To:

; 1756 :    }
; 1757 : 
; 1758 :    nRC = WriteSubobjectToXML( vOI, 0, lControl, lpfnWrite, lpPtr );

	mov	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpfnWrite$[ebp]
	push	edx
	mov	eax, DWORD PTR _lControl$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_WriteSubobjectToXML@20
	mov	WORD PTR _nRC$[ebp], ax

; 1759 : 
; 1760 :    fnOperationReturn( iWriteOI_ToXML, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	550					; 00000226H
	call	_fnOperationReturn
	add	esp, 8

; 1761 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@WriteOI_To:

; 1762 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_WriteOI_ToXML@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_lpViewOI$ = -11484					; size = 4
_lpViewCsr$ = -11480					; size = 4
_lpApp$ = -11476					; size = 4
_pch$ = -11472						; size = 4
_lpViewOD$ = -11468					; size = 4
_lpViewEntityCsr$1 = -11464				; size = 4
_lpEndEntityInstance$ = -11460				; size = 4
_lpSearch$2 = -11456					; size = 4
_nRC$ = -11452						; size = 2
_lpCurrentTask$ = -11448				; size = 4
_lpStartEntityInstance$ = -11444			; size = 4
_lpEntityInstance$ = -11440				; size = 4
_bCloseZOI$ = -11433					; size = 1
_WriteInfo$ = -11432					; size = 10428
_szBuffer$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_vOI$ = 8						; size = 4
_pchEntityName$ = 12					; size = 4
_lControl$ = 16						; size = 4
_lpfnWrite$ = 20					; size = 4
_lpPtr$ = 24						; size = 4
_WriteSubobjectToXML@20 PROC

; 1577 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 11484				; 00002cdcH
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1578 :    LPTASK            lpCurrentTask;
; 1579 :    zCHAR             szBuffer[ 1000 ];
; 1580 :    LPVIEWOI          lpViewOI;
; 1581 :    LPVIEWCSR         lpViewCsr;
; 1582 :    LPVIEWOD          lpViewOD;
; 1583 :    LPENTITYINSTANCE  lpEntityInstance;
; 1584 :    LPENTITYINSTANCE  lpStartEntityInstance;
; 1585 :    LPENTITYINSTANCE  lpEndEntityInstance;
; 1586 :    LPAPP             lpApp;
; 1587 :    zBOOL             bCloseZOI = FALSE;

	mov	BYTE PTR _bCloseZOI$[ebp], 0

; 1588 :    WriteInfoRecord   WriteInfo = { 0 };

	mov	DWORD PTR _WriteInfo$[ebp], 0
	push	10424					; 000028b8H
	push	0
	lea	eax, DWORD PTR _WriteInfo$[ebp+4]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 1589 :    zPCHAR            pch;
; 1590 :    zSHORT            nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], cx

; 1591 : 
; 1592 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 1593 :    if ( (lpCurrentTask = fnOperationCall( iWriteSubobjectToXML, vOI,
; 1594 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	push	553					; 00000229H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN11@WriteSubob

; 1595 :    {
; 1596 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@WriteSubob
$LN11@WriteSubob:

; 1597 :    }
; 1598 : 
; 1599 :    lpViewCsr = (LPVIEWCSR) zGETPTR( vOI->hViewCsr );

	mov	eax, DWORD PTR _vOI$[ebp]
	mov	ecx, DWORD PTR [eax+10]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewCsr$[ebp], eax

; 1600 :    lpViewOI  = (LPVIEWOI)  zGETPTR( lpViewCsr->hViewOI );

	mov	edx, DWORD PTR _lpViewCsr$[ebp]
	mov	eax, DWORD PTR [edx+10]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOI$[ebp], eax

; 1601 :    lpViewOD  = (LPVIEWOD)  zGETPTR( vOI->hViewOD );

	mov	ecx, DWORD PTR _vOI$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpViewOD$[ebp], eax

; 1602 : 
; 1603 :    // If the entity name was supplied, then verify it.
; 1604 :    if ( pchEntityName && pchEntityName[ 0 ] )

	cmp	DWORD PTR _pchEntityName$[ebp], 0
	je	$LN12@WriteSubob
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pchEntityName$[ebp]
	movsx	eax, BYTE PTR [edx+ecx]
	test	eax, eax
	je	$LN12@WriteSubob

; 1605 :    {
; 1606 :       LPVIEWENTITYCSR lpViewEntityCsr;
; 1607 : 
; 1608 :       if ( fnValidViewEntity( &lpViewEntityCsr, vOI, pchEntityName, 0 ) == 0 )

	push	0
	mov	ecx, DWORD PTR _pchEntityName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpViewEntityCsr$1[ebp]
	push	eax
	call	_fnValidViewEntity@16
	test	eax, eax
	jne	SHORT $LN14@WriteSubob

; 1609 :       {
; 1610 :          fnOperationReturn( iWriteSubobjectToXML, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	553					; 00000229H
	call	_fnOperationReturn
	add	esp, 8

; 1611 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@WriteSubob
$LN14@WriteSubob:

; 1612 :       }
; 1613 : 
; 1614 :       if ( lpViewEntityCsr->hEntityInstance == UNSET_CSR )

	mov	edx, DWORD PTR _lpViewEntityCsr$1[ebp]
	cmp	DWORD PTR [edx+26], 1
	jne	SHORT $LN15@WriteSubob

; 1615 :          fnEstablishCursorForView( lpViewEntityCsr );

	mov	eax, DWORD PTR _lpViewEntityCsr$1[ebp]
	push	eax
	call	_fnEstablishCursorForView
	add	esp, 4
$LN15@WriteSubob:

; 1616 : 
; 1617 :       lpStartEntityInstance = zGETPTR( lpViewEntityCsr->hEntityInstance );

	mov	ecx, DWORD PTR _lpViewEntityCsr$1[ebp]
	mov	edx, DWORD PTR [ecx+26]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartEntityInstance$[ebp], eax

; 1618 :       lpEndEntityInstance   = zGETPTR( lpStartEntityInstance->hNextTwin );

	mov	eax, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+22]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEndEntityInstance$[ebp], eax

; 1619 :    }

	jmp	SHORT $LN13@WriteSubob
$LN12@WriteSubob:

; 1620 :    else
; 1621 :    {
; 1622 :       lpStartEntityInstance = zGETPTR( lpViewOI->hRootEntityInstance );

	mov	edx, DWORD PTR _lpViewOI$[ebp]
	mov	eax, DWORD PTR [edx+26]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpStartEntityInstance$[ebp], eax

; 1623 :       lpEndEntityInstance   = 0;

	mov	DWORD PTR _lpEndEntityInstance$[ebp], 0
$LN13@WriteSubob:

; 1624 :    }
; 1625 : 
; 1626 :    // If we are only writing the root of the subobject then stop at the next twin.
; 1627 :    if ( lControl & zXML_ROOTONLY )

	mov	ecx, DWORD PTR _lControl$[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN16@WriteSubob

; 1628 :       lpEndEntityInstance = zGETPTR( lpStartEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEndEntityInstance$[ebp], eax
$LN16@WriteSubob:

; 1629 : 
; 1630 :    pch = "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>";

	mov	DWORD PTR _pch$[ebp], OFFSET $SG14316

; 1631 :    if ( (*lpfnWrite)( vOI, 0, pch, 0, 0, lpPtr ) == zCALL_ERROR )

	mov	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	DWORD PTR _lpfnWrite$[ebp]
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN17@WriteSubob

; 1632 :    {
; 1633 :       fnOperationReturn( iWriteSubobjectToXML, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	553					; 00000229H
	call	_fnOperationReturn
	add	esp, 8

; 1634 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@WriteSubob
$LN17@WriteSubob:

; 1635 :    }
; 1636 : 
; 1637 :    if ( lControl & zXML_ZEIDONINFO )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 1
	je	$LN18@WriteSubob

; 1638 :    {
; 1639 :       lpApp = zGETPTR( lpViewOD->hApp );

	mov	ecx, DWORD PTR _lpViewOD$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$[ebp], eax

; 1640 : 
; 1641 :       if ( lControl & zXML_INCREFLAGS )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 2
	je	SHORT $LN20@WriteSubob

; 1642 :          zsprintf( szBuffer, "<zOI zObjectName=\"%s\" zAppName=\"%s\" "

	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 6
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG14322
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
	jmp	SHORT $LN21@WriteSubob
$LN20@WriteSubob:

; 1643 :                    "zIncreFlags=\"Y\">", lpViewOD->szName, lpApp->szName );
; 1644 :       else
; 1645 :          zsprintf( szBuffer, "<zOI zObjectName=\"%s\" zAppName=\"%s\">",

	mov	ecx, DWORD PTR _lpApp$[ebp]
	add	ecx, 6
	push	ecx
	mov	edx, DWORD PTR _lpViewOD$[ebp]
	add	edx, 10					; 0000000aH
	push	edx
	push	OFFSET $SG14323
	lea	eax, DWORD PTR _szBuffer$[ebp]
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H
$LN21@WriteSubob:

; 1646 :                    lpViewOD->szName, lpApp->szName );
; 1647 : 
; 1648 :       if ( (*lpfnWrite)( vOI, zXML_STARTOI, szBuffer, 0, 0, lpPtr ) == zCALL_ERROR )

	mov	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	push	0
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	push	1
	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	DWORD PTR _lpfnWrite$[ebp]
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN22@WriteSubob

; 1649 :       {
; 1650 :          fnOperationReturn( iWriteSubobjectToXML, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	553					; 00000229H
	call	_fnOperationReturn
	add	esp, 8

; 1651 :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@WriteSubob
$LN22@WriteSubob:

; 1652 :       }
; 1653 : 
; 1654 :       bCloseZOI = TRUE;

	mov	BYTE PTR _bCloseZOI$[ebp], 1

; 1655 :    }

	jmp	$LN19@WriteSubob
$LN18@WriteSubob:

; 1656 :    else
; 1657 :    // If we are writing multiple root entities then we'll write an enclosing tag.
; 1658 :    if ( (lControl & zXML_ROOTONLY ) == 0 && lpStartEntityInstance->hNextTwin )

	mov	eax, DWORD PTR _lControl$[ebp]
	and	eax, 32					; 00000020H
	jne	$LN19@WriteSubob
	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	cmp	DWORD PTR [ecx+22], 0
	je	$LN19@WriteSubob

; 1659 :    {
; 1660 :       LPENTITYINSTANCE lpSearch;
; 1661 : 
; 1662 :       // Check to see if there's a non-hidden EI
; 1663 :       for ( lpSearch = zGETPTR( lpStartEntityInstance->hNextTwin );

	mov	edx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearch$2[ebp], eax
	jmp	SHORT $LN4@WriteSubob
$LN2@WriteSubob:

; 1665 :             lpSearch = zGETPTR( lpSearch->hNextTwin ) )

	mov	ecx, DWORD PTR _lpSearch$2[ebp]
	mov	edx, DWORD PTR [ecx+22]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpSearch$2[ebp], eax
$LN4@WriteSubob:

; 1664 :             lpSearch;

	cmp	DWORD PTR _lpSearch$2[ebp], 0
	je	SHORT $LN19@WriteSubob

; 1666 :       {
; 1667 :          // If it's hidden, skip it.
; 1668 :          if ( lpSearch->u.nInd.bHidden )

	mov	eax, DWORD PTR _lpSearch$2[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 10					; 0000000aH
	and	ecx, 1
	je	SHORT $LN24@WriteSubob

; 1669 :             continue;

	jmp	SHORT $LN2@WriteSubob
$LN24@WriteSubob:

; 1670 : 
; 1671 :          // Entity isn't hidden so write the root tag and break out.
; 1672 :          zstrcpy( szBuffer, "<zOI>" );

	push	OFFSET $SG14327
	lea	edx, DWORD PTR _szBuffer$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 1673 :          if ( (*lpfnWrite)( vOI, zXML_STARTOI, szBuffer, 0, 0, lpPtr ) == zCALL_ERROR )

	mov	eax, DWORD PTR _lpPtr$[ebp]
	push	eax
	push	0
	push	0
	lea	ecx, DWORD PTR _szBuffer$[ebp]
	push	ecx
	push	1
	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	call	DWORD PTR _lpfnWrite$[ebp]
	cwde
	cmp	eax, -16				; fffffff0H
	jne	SHORT $LN25@WriteSubob

; 1674 :          {
; 1675 :             fnOperationReturn( iWriteSubobjectToXML, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	553					; 00000229H
	call	_fnOperationReturn
	add	esp, 8

; 1676 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@WriteSubob
$LN25@WriteSubob:

; 1677 :          }
; 1678 : 
; 1679 :          bCloseZOI = TRUE;

	mov	BYTE PTR _bCloseZOI$[ebp], 1

; 1680 : 
; 1681 :          break;

	jmp	SHORT $LN19@WriteSubob

; 1682 :       }

	jmp	$LN2@WriteSubob
$LN19@WriteSubob:

; 1683 :    }
; 1684 : 
; 1685 :    WriteInfo.vOI             = vOI;

	mov	edx, DWORD PTR _vOI$[ebp]
	mov	DWORD PTR _WriteInfo$[ebp], edx

; 1686 :    WriteInfo.lpViewCsr       = lpViewCsr;

	mov	eax, DWORD PTR _lpViewCsr$[ebp]
	mov	DWORD PTR _WriteInfo$[ebp+8], eax

; 1687 :    WriteInfo.lControl        = lControl;

	mov	ecx, DWORD PTR _lControl$[ebp]
	mov	DWORD PTR _WriteInfo$[ebp+12], ecx

; 1688 :    WriteInfo.lpfnWrite       = lpfnWrite;

	mov	edx, DWORD PTR _lpfnWrite$[ebp]
	mov	DWORD PTR _WriteInfo$[ebp+10420], edx

; 1689 :    WriteInfo.lpPtr           = lpPtr;

	mov	eax, DWORD PTR _lpPtr$[ebp]
	mov	DWORD PTR _WriteInfo$[ebp+10424], eax

; 1690 :    WriteInfo.lpSubobjectRoot = lpStartEntityInstance;

	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	DWORD PTR _WriteInfo$[ebp+16], ecx

; 1691 :    CreateViewFromViewForTask( &WriteInfo.vTemp, vOI, 0 );

	push	0
	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	lea	eax, DWORD PTR _WriteInfo$[ebp+4]
	push	eax
	call	_CreateViewFromViewForTask@12

; 1692 : 
; 1693 :    // Loop through the EIs and write them out.
; 1694 :    for ( lpEntityInstance = lpStartEntityInstance;

	mov	ecx, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], ecx
	jmp	SHORT $LN7@WriteSubob
$LN5@WriteSubob:

; 1696 :          lpEntityInstance = zGETPTR( lpEntityInstance->hNextTwin ) )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+22]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN7@WriteSubob:

; 1695 :          lpEntityInstance != lpEndEntityInstance;

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	cmp	ecx, DWORD PTR _lpEndEntityInstance$[ebp]
	je	SHORT $LN6@WriteSubob

; 1697 :    {
; 1698 :       if ( fnConvertEntity( vOI, &WriteInfo, lpEntityInstance ) != 0 )

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	push	edx
	lea	eax, DWORD PTR _WriteInfo$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_fnConvertEntity@12
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN26@WriteSubob

; 1699 :          goto EndOfFunction;

	jmp	$EndOfFunction$34
$LN26@WriteSubob:

; 1700 :    }

	jmp	SHORT $LN5@WriteSubob
$LN6@WriteSubob:

; 1701 : 
; 1702 :    if ( bCloseZOI )

	movzx	eax, BYTE PTR _bCloseZOI$[ebp]
	test	eax, eax
	je	SHORT $LN27@WriteSubob

; 1703 :    {
; 1704 :       pch = "</zOI>";

	mov	DWORD PTR _pch$[ebp], OFFSET $SG14331

; 1705 :       if ( (*lpfnWrite)( vOI, zXML_ENDOI, pch, 0, 0, lpPtr ) == zCALL_ERROR )

	mov	ecx, DWORD PTR _lpPtr$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _pch$[ebp]
	push	edx
	push	2
	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	DWORD PTR _lpfnWrite$[ebp]
	movsx	ecx, ax
	cmp	ecx, -16				; fffffff0H
	jne	SHORT $LN27@WriteSubob

; 1706 :          goto EndOfFunction;

	jmp	SHORT $EndOfFunction$34
$LN27@WriteSubob:

; 1707 :    }
; 1708 : 
; 1709 :    // If we are writing incre flags then we might have turned off some hidden
; 1710 :    // flags.  Turn them back on.
; 1711 :    if ( lControl & zXML_INCREFLAGS )

	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 2
	je	SHORT $LN29@WriteSubob

; 1712 :    {
; 1713 :       for ( lpEntityInstance = lpStartEntityInstance;

	mov	eax, DWORD PTR _lpStartEntityInstance$[ebp]
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
	jmp	SHORT $LN10@WriteSubob
$LN8@WriteSubob:

; 1715 :             lpEntityInstance = zGETPTR( lpEntityInstance->hNextHier ) )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+14]
	push	edx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpEntityInstance$[ebp], eax
$LN10@WriteSubob:

; 1714 :             lpEntityInstance != lpEndEntityInstance;

	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	cmp	eax, DWORD PTR _lpEndEntityInstance$[ebp]
	je	SHORT $LN29@WriteSubob

; 1716 :       {
; 1717 :          if ( lpEntityInstance->u.nInd.bDeleted || lpEntityInstance->u.nInd.bExcluded )

	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	edx, DWORD PTR [ecx+6]
	shr	edx, 3
	and	edx, 1
	jne	SHORT $LN31@WriteSubob
	mov	eax, DWORD PTR _lpEntityInstance$[ebp]
	mov	ecx, DWORD PTR [eax+6]
	shr	ecx, 4
	and	ecx, 1
	je	SHORT $LN30@WriteSubob
$LN31@WriteSubob:

; 1718 :             lpEntityInstance->u.nInd.bHidden = TRUE;

	mov	edx, DWORD PTR _lpEntityInstance$[ebp]
	mov	eax, DWORD PTR [edx+6]
	or	eax, 1024				; 00000400H
	mov	ecx, DWORD PTR _lpEntityInstance$[ebp]
	mov	DWORD PTR [ecx+6], eax
$LN30@WriteSubob:

; 1719 :       }

	jmp	SHORT $LN8@WriteSubob
$LN29@WriteSubob:

; 1720 :    }
; 1721 : 
; 1722 :    nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx
$EndOfFunction$34:

; 1723 : 
; 1724 : EndOfFunction:
; 1725 :    if ( WriteInfo.vTemp != 0 )

	cmp	DWORD PTR _WriteInfo$[ebp+4], 0
	je	SHORT $LN32@WriteSubob

; 1726 :       fnDropView( WriteInfo.vTemp );

	mov	eax, DWORD PTR _WriteInfo$[ebp+4]
	push	eax
	call	_fnDropView@4
$LN32@WriteSubob:

; 1727 : 
; 1728 :    fnOperationReturn( iWriteSubobjectToXML, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	553					; 00000229H
	call	_fnOperationReturn
	add	esp, 8

; 1729 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@WriteSubob:

; 1730 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_WriteSubobjectToXML@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
$T1 = -284						; size = 4
_lpCurrentTask$ = -280					; size = 4
_hFile$ = -276						; size = 4
_lpApp$2 = -272						; size = 4
_nRC$ = -268						; size = 2
_szOpenFileName$ = -264					; size = 257
__$ArrayPad$ = -4					; size = 4
_vOI$ = 8						; size = 4
_pchFileName$ = 12					; size = 4
_pchSubobjectRoot$ = 16					; size = 4
_nFlags$ = 20						; size = 4
_CommitSubobjectToXML_File@16 PROC

; 2890 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2891 :    LPTASK lpCurrentTask;
; 2892 :    zCHAR  szOpenFileName[ zMAX_FILENAME_LTH + 1 ];
; 2893 :    zLONG  hFile;
; 2894 :    zSHORT nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 2895 : 
; 2896 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 2897 :    if ( (lpCurrentTask = fnOperationCall( iCommitSubobjectToXML_File, vOI,
; 2898 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	push	554					; 0000022aH
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@CommitSubo

; 2899 :    {
; 2900 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN9@CommitSubo
$LN2@CommitSubo:

; 2901 :    }
; 2902 : 
; 2903 :    // If the file name is not qualfied, use the object dir for the application.
; 2904 :    if ( !zstrchr( (zPCHAR) pchFileName, cDirSep ) )

	movsx	edx, BYTE PTR _cDirSep
	push	edx
	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN3@CommitSubo

; 2905 :    {
; 2906 :       LPAPP lpApp;
; 2907 : 
; 2908 :       fnGetApplicationForSubtask( &lpApp, vOI );

	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	lea	edx, DWORD PTR _lpApp$2[ebp]
	push	edx
	call	_fnGetApplicationForSubtask@8

; 2909 :       if ( lpApp )

	cmp	DWORD PTR _lpApp$2[ebp], 0
	je	SHORT $LN5@CommitSubo

; 2910 :          zstrcpy( szOpenFileName, lpApp->szObjectDir );

	mov	eax, DWORD PTR _lpApp$2[ebp]
	add	eax, 347				; 0000015bH
	push	eax
	lea	ecx, DWORD PTR _szOpenFileName$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN6@CommitSubo
$LN5@CommitSubo:

; 2911 :       else
; 2912 :       {
; 2913 :          lpApp = zGETPTR( AnchorBlock->hSystemApp );

	mov	edx, DWORD PTR _AnchorBlock
	mov	eax, DWORD PTR [edx+110]
	push	eax
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$2[ebp], eax

; 2914 :          zstrcpy( szOpenFileName, lpApp->szObjectDir );

	mov	ecx, DWORD PTR _lpApp$2[ebp]
	add	ecx, 347				; 0000015bH
	push	ecx
	lea	edx, DWORD PTR _szOpenFileName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
$LN6@CommitSubo:

; 2915 :       }
; 2916 : 
; 2917 :       SysAppendcDirSep( szOpenFileName );

	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	call	_SysAppendcDirSep@4

; 2918 :    }

	jmp	SHORT $LN4@CommitSubo
$LN3@CommitSubo:

; 2919 :    else
; 2920 :       szOpenFileName[ 0 ] = 0;

	mov	ecx, 1
	imul	edx, ecx, 0
	mov	DWORD PTR $T1[ebp], edx
	cmp	DWORD PTR $T1[ebp], 257			; 00000101H
	jae	SHORT $LN10@CommitSubo
	jmp	SHORT $LN11@CommitSubo
$LN10@CommitSubo:
	call	___report_rangecheckfailure
$LN11@CommitSubo:
	mov	eax, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szOpenFileName$[ebp+eax], 0
$LN4@CommitSubo:

; 2921 : 
; 2922 :    zstrcat( szOpenFileName, pchFileName );

	mov	ecx, DWORD PTR _pchFileName$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szOpenFileName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 2923 : 
; 2924 :    hFile = SysOpenFile( vOI, szOpenFileName, COREFILE_WRITE );

	push	64					; 00000040H
	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_SysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 2925 :    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN7@CommitSubo

; 2926 :    {
; 2927 :       //  "KZOEE071 - Error opening instance file "
; 2928 :       fnIssueCoreError( lpCurrentTask, vOI, 16, 71, 0, pchFileName, 0 );

	push	0
	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	push	0
	push	71					; 00000047H
	push	16					; 00000010H
	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2929 :    }

	jmp	SHORT $LN8@CommitSubo
$LN7@CommitSubo:

; 2930 :    else
; 2931 :    {
; 2932 :       nRC = WriteSubobjectToXML( vOI, pchSubobjectRoot, nFlags,

	lea	edx, DWORD PTR _hFile$[ebp]
	push	edx
	push	OFFSET _fnWriteXML_ToFile@24
	mov	eax, DWORD PTR _nFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchSubobjectRoot$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	call	_WriteSubobjectToXML@20
	mov	WORD PTR _nRC$[ebp], ax

; 2933 :                                  fnWriteXML_ToFile, (zPVOID) &hFile );
; 2934 :       SysCloseFile( vOI, hFile, 0 );

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_SysCloseFile@12
$LN8@CommitSubo:

; 2935 :    }
; 2936 : 
; 2937 :    fnOperationReturn( iCommitSubobjectToXML_File, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	554					; 0000022aH
	call	_fnOperationReturn
	add	esp, 8

; 2938 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN9@CommitSubo:

; 2939 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_CommitSubobjectToXML_File@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
$T1 = -284						; size = 4
_lpCurrentTask$ = -280					; size = 4
_hFile$ = -276						; size = 4
_lpApp$2 = -272						; size = 4
_nRC$ = -268						; size = 2
_szOpenFileName$ = -264					; size = 257
__$ArrayPad$ = -4					; size = 4
_vOI$ = 8						; size = 4
_pchFileName$ = 12					; size = 4
_nFlags$ = 16						; size = 4
_CommitOI_ToXML_File@12 PROC

; 2829 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 284				; 0000011cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2830 :    LPTASK lpCurrentTask;
; 2831 :    zCHAR  szOpenFileName[ zMAX_FILENAME_LTH + 1 ];
; 2832 :    zLONG  hFile;
; 2833 :    zSHORT nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 2834 : 
; 2835 :    if ( vOI == 0 )

	cmp	DWORD PTR _vOI$[ebp], 0
	jne	SHORT $LN2@CommitOI_T

; 2836 :    {
; 2837 :       TraceLineS( "Invalid view for CommitOI_ToXML_File: ", pchFileName );

	mov	ecx, DWORD PTR _pchFileName$[ebp]
	push	ecx
	push	OFFSET $SG14900
	call	_TraceLineS@8

; 2838 :       return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
	jmp	$LN10@CommitOI_T
$LN2@CommitOI_T:

; 2839 :    }
; 2840 : 
; 2841 :    // If task not active or disabled, or view invalid, return zCALL_ERROR.
; 2842 :    if ( (lpCurrentTask = fnOperationCall( iCommitOI_ToXML_File, vOI,
; 2843 :                                           zVALID_VIEW )) == 0 )

	push	1
	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	push	552					; 00000228H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN3@CommitOI_T

; 2844 :    {
; 2845 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN10@CommitOI_T
$LN3@CommitOI_T:

; 2846 :    }
; 2847 : 
; 2848 :    // If the file name is not qualfied, use the object dir for the application.
; 2849 :    if ( zstrchr( pchFileName, cDirSep ) == 0 )

	movsx	eax, BYTE PTR _cDirSep
	push	eax
	mov	ecx, DWORD PTR _pchFileName$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN4@CommitOI_T

; 2850 :    {
; 2851 :       LPAPP lpApp;
; 2852 : 
; 2853 :       fnGetApplicationForSubtask( &lpApp, vOI );

	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	lea	eax, DWORD PTR _lpApp$2[ebp]
	push	eax
	call	_fnGetApplicationForSubtask@8

; 2854 :       if ( lpApp )

	cmp	DWORD PTR _lpApp$2[ebp], 0
	je	SHORT $LN6@CommitOI_T

; 2855 :          zstrcpy( szOpenFileName, lpApp->szObjectDir );

	mov	ecx, DWORD PTR _lpApp$2[ebp]
	add	ecx, 347				; 0000015bH
	push	ecx
	lea	edx, DWORD PTR _szOpenFileName$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8
	jmp	SHORT $LN7@CommitOI_T
$LN6@CommitOI_T:

; 2856 :       else
; 2857 :       {
; 2858 :          lpApp = zGETPTR( AnchorBlock->hSystemApp );

	mov	eax, DWORD PTR _AnchorBlock
	mov	ecx, DWORD PTR [eax+110]
	push	ecx
	call	DWORD PTR _g_pfnGetPtr
	mov	DWORD PTR _lpApp$2[ebp], eax

; 2859 :          zstrcpy( szOpenFileName, lpApp->szObjectDir );

	mov	edx, DWORD PTR _lpApp$2[ebp]
	add	edx, 347				; 0000015bH
	push	edx
	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8
$LN7@CommitOI_T:

; 2860 :       }
; 2861 : 
; 2862 :       SysAppendcDirSep( szOpenFileName );

	lea	ecx, DWORD PTR _szOpenFileName$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 2863 :    }

	jmp	SHORT $LN5@CommitOI_T
$LN4@CommitOI_T:

; 2864 :    else
; 2865 :       szOpenFileName[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 257			; 00000101H
	jae	SHORT $LN11@CommitOI_T
	jmp	SHORT $LN12@CommitOI_T
$LN11@CommitOI_T:
	call	___report_rangecheckfailure
$LN12@CommitOI_T:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _szOpenFileName$[ebp+ecx], 0
$LN5@CommitOI_T:

; 2866 : 
; 2867 :    zstrcat( szOpenFileName, pchFileName );

	mov	edx, DWORD PTR _pchFileName$[ebp]
	push	edx
	lea	eax, DWORD PTR _szOpenFileName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 2868 : 
; 2869 :    hFile = SysOpenFile( vOI, szOpenFileName, COREFILE_WRITE );

	push	64					; 00000040H
	lea	ecx, DWORD PTR _szOpenFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	call	_SysOpenFile@12
	mov	DWORD PTR _hFile$[ebp], eax

; 2870 :    if ( hFile == -1 )

	cmp	DWORD PTR _hFile$[ebp], -1
	jne	SHORT $LN8@CommitOI_T

; 2871 :    {
; 2872 :       //  "KZOEE071 - Error opening instance file "
; 2873 :       fnIssueCoreError( lpCurrentTask, vOI, 16, 71, 0, pchFileName, 0 );

	push	0
	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	push	0
	push	71					; 00000047H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2874 :    }

	jmp	SHORT $LN9@CommitOI_T
$LN8@CommitOI_T:

; 2875 :    else
; 2876 :    {
; 2877 :       nRC = WriteOI_ToXML( vOI, nFlags, fnWriteXML_ToFile, (zPVOID) &hFile );

	lea	eax, DWORD PTR _hFile$[ebp]
	push	eax
	push	OFFSET _fnWriteXML_ToFile@24
	mov	ecx, DWORD PTR _nFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	call	_WriteOI_ToXML@16
	mov	WORD PTR _nRC$[ebp], ax

; 2878 :       SysCloseFile( vOI, hFile, 0 );

	push	0
	mov	eax, DWORD PTR _hFile$[ebp]
	push	eax
	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_SysCloseFile@12
$LN9@CommitOI_T:

; 2879 :    }
; 2880 : 
; 2881 :    fnOperationReturn( iCommitOI_ToXML_File, lpCurrentTask );

	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	push	552					; 00000228H
	call	_fnOperationReturn
	add	esp, 8

; 2882 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN10@CommitOI_T:

; 2883 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_CommitOI_ToXML_File@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\kzoexmla.c
_TEXT	SEGMENT
_lpCurrentTask$ = -5016					; size = 4
_nRC$ = -5012						; size = 2
_XMLData$ = -5008					; size = 5004
__$ArrayPad$ = -4					; size = 4
_pvOI$ = 8						; size = 4
_pchOD_Name$ = 12					; size = 4
_vSubtask$ = 16						; size = 4
_pchFileName$ = 20					; size = 4
_lControl$ = 24						; size = 4
_ActivateOI_FromXML_File@20 PROC

; 2754 : {

	push	ebp
	mov	ebp, esp
	mov	eax, 5016				; 00001398H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 2755 :    LPTASK  lpCurrentTask;
; 2756 :    XMLDATA XMLData;
; 2757 :    zSHORT  nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 2758 : 
; 2759 :    // If task not active or disabled, return zCALL_ERROR.
; 2760 :    if ( (lpCurrentTask = fnOperationCall( iActivateOI_FromXML_File,
; 2761 :                                           vSubtask, 0 )) == 0 )

	push	0
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	push	551					; 00000227H
	call	_fnOperationCall
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _lpCurrentTask$[ebp], eax
	cmp	DWORD PTR _lpCurrentTask$[ebp], 0
	jne	SHORT $LN2@ActivateOI

; 2762 :    {
; 2763 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ActivateOI
$LN2@ActivateOI:

; 2764 :    }
; 2765 : 
; 2766 :    if ( (vSubtask || (lControl & zACTIVATE_SYSTEM) == 0) &&

	cmp	DWORD PTR _vSubtask$[ebp], 0
	jne	SHORT $LN4@ActivateOI
	mov	edx, DWORD PTR _lControl$[ebp]
	and	edx, 536870912				; 20000000H
	jne	SHORT $LN3@ActivateOI
$LN4@ActivateOI:
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	call	_fnValidView
	add	esp, 8
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN3@ActivateOI

; 2767 :         fnValidView( lpCurrentTask, vSubtask ) == 0 )
; 2768 :    {
; 2769 :       fnOperationReturn( iActivateOI_FromXML_File, lpCurrentTask );

	mov	eax, DWORD PTR _lpCurrentTask$[ebp]
	push	eax
	push	551					; 00000227H
	call	_fnOperationReturn
	add	esp, 8

; 2770 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@ActivateOI
$LN3@ActivateOI:

; 2771 :    }
; 2772 : 
; 2773 :    XMLData.hFile = SysOpenFile( vSubtask, pchFileName, COREFILE_READ );

	push	128					; 00000080H
	mov	ecx, DWORD PTR _pchFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_SysOpenFile@12
	mov	DWORD PTR _XMLData$[ebp+5000], eax

; 2774 :    if ( XMLData.hFile == -1 )

	cmp	DWORD PTR _XMLData$[ebp+5000], -1
	jne	SHORT $LN5@ActivateOI

; 2775 :    {
; 2776 :       //  "KZOEE071 - Error opening instance file "
; 2777 :       fnIssueCoreError( lpCurrentTask, vSubtask, 16, 71, 0, pchFileName, 0 );

	push	0
	mov	eax, DWORD PTR _pchFileName$[ebp]
	push	eax
	push	0
	push	71					; 00000047H
	push	16					; 00000010H
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpCurrentTask$[ebp]
	push	edx
	call	_fnIssueCoreError
	add	esp, 28					; 0000001cH

; 2778 :    }

	jmp	SHORT $LN6@ActivateOI
$LN5@ActivateOI:

; 2779 :    else
; 2780 :    {
; 2781 :       nRC = ActivateOI_FromXML( pvOI, (zPCHAR) pchOD_Name, vSubtask, lControl,

	lea	eax, DWORD PTR _XMLData$[ebp]
	push	eax
	push	OFFSET _fnReadXMLData@16
	mov	ecx, DWORD PTR _lControl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchOD_Name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pvOI$[ebp]
	push	ecx
	call	_ActivateOI_FromXML@24
	mov	WORD PTR _nRC$[ebp], ax

; 2782 :                                 fnReadXMLData, (zPVOID) &XMLData );
; 2783 : 
; 2784 :       SysCloseFile( vSubtask, XMLData.hFile, 0 );

	push	0
	mov	edx, DWORD PTR _XMLData$[ebp+5000]
	push	edx
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_SysCloseFile@12
$LN6@ActivateOI:

; 2785 :    }
; 2786 : 
; 2787 :    fnOperationReturn( iActivateOI_FromXML_File, lpCurrentTask );

	mov	ecx, DWORD PTR _lpCurrentTask$[ebp]
	push	ecx
	push	551					; 00000227H
	call	_fnOperationReturn
	add	esp, 8

; 2788 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@ActivateOI:

; 2789 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_ActivateOI_FromXML_File@20 ENDP
_TEXT	ENDS
END
