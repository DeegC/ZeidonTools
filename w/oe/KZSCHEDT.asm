; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\w\oe\KZSCHEDT.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	_g_DoWork
PUBLIC	_g_szClassName
PUBLIC	_g_bRunningTest
PUBLIC	_g_ulTestCount
PUBLIC	_g_bContinueThreadTest
PUBLIC	_g_bTestThreadStarted
PUBLIC	_g_hTestThread
PUBLIC	_g_dwTestThreadID
PUBLIC	_bThreadRegistered
_DATA	SEGMENT
COMM	_g_hInst:DWORD
COMM	_g_hInstRes:DWORD
COMM	_g_hWndMain:DWORD
COMM	_g_wClientMessage:WORD
COMM	_g_nNoUnregister:DWORD
COMM	_g_vSubtask:DWORD
_DATA	ENDS
_BSS	SEGMENT
_g_bRunningTest DB 01H DUP (?)
	ALIGN	4

_g_ulTestCount DD 01H DUP (?)
_g_bContinueThreadTest DB 01H DUP (?)
	ALIGN	4

_g_bTestThreadStarted DB 01H DUP (?)
	ALIGN	4

_g_hTestThread DD 01H DUP (?)
_g_dwTestThreadID DD 01H DUP (?)
$SG93990 DB	01H DUP (?)
	ALIGN	4

$SG94061 DB	01H DUP (?)
_BSS	ENDS
_TLS	SEGMENT
_bThreadRegistered DB 00H
_TLS	ENDS
_DATA	SEGMENT
_g_DoWork DB	01H
	ORG $+3
_g_szClassName DB 'TaskSchedulerClass', 00H
	ORG $+1
$SG93889 DB	'Starting thread test', 00H
	ORG $+3
$SG93892 DB	'\\ePamms\', 00H
	ORG $+2
$SG93893 DB	'Completed thread register', 00H
	ORG $+2
$SG93894 DB	'mUser', 00H
	ORG $+2
$SG93897 DB	'----- ERROR activating mUser --------- ', 00H
$SG93898 DB	'Thread test #%d, rc = %d', 00H
	ORG $+3
$SG93900 DB	'Completed thread UN(!)register', 00H
	ORG $+1
$SG93901 DB	'Completed thread test', 00H
	ORG $+2
$SG93926 DB	'ZEIDON_MONITOR', 00H
	ORG $+1
$SG93939 DB	'KZSchedT.exe', 00H
	ORG $+3
$SG93989 DB	'Done with test %u', 00H
	ORG $+2
$SG94012 DB	'Close running test', 00H
	ORG $+1
$SG94013 DB	'Test In Progress', 00H
	ORG $+3
$SG94015 DB	'zWinSock', 00H
	ORG $+3
$SG94016 DB	'zWinSock', 00H
	ORG $+3
$SG94039 DB	'KZSCHEDT', 00H
	ORG $+3
$SG94055 DB	'KZSCHEDT', 00H
	ORG $+3
$SG94056 DB	'Task Scheduler', 00H
	ORG $+1
$SG94058 DB	'KZSCHEDT', 00H
	ORG $+3
$SG94060 DB	'\\ePamms\', 00H
	ORG $+2
$SG94062 DB	'Done registering', 00H
_DATA	ENDS
PUBLIC	_WinMain@16
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_InitInstance
PUBLIC	_InitApplication
PUBLIC	_MainWndProc@16
PUBLIC	_fnThreadProc2@4
PUBLIC	_TrayMessage
PUBLIC	_SetupSysTray
PUBLIC	_DetachSysTray
PUBLIC	_PostBuild@4
PUBLIC	_Cleanup@4
PUBLIC	_Exit@4
PUBLIC	_HandlePopupMenu@12
PUBLIC	_TimerProc@16
EXTRN	_strncpy:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__LoadLibraryExA@12:PROC
EXTRN	__imp__GetStockObject@4:PROC
EXTRN	__imp__RegisterWindowMessageA@4:PROC
EXTRN	__imp__GetMessageA@16:PROC
EXTRN	__imp__TranslateMessage@4:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__PostQuitMessage@4:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__IsWindowVisible@4:PROC
EXTRN	__imp__SetTimer@16:PROC
EXTRN	__imp__KillTimer@8:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__LoadMenuA@8:PROC
EXTRN	__imp__GetSubMenu@8:PROC
EXTRN	__imp__TrackPopupMenu@28:PROC
EXTRN	__imp__SetForegroundWindow@4:PROC
EXTRN	__imp__GetWindowTextA@12:PROC
EXTRN	__imp__GetCursorPos@4:PROC
EXTRN	__imp__GetWindowLongA@8:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__LoadIconA@8:PROC
EXTRN	__imp__DestroyIcon@4:PROC
EXTRN	__imp__Shell_NotifyIconA@8:PROC
EXTRN	___stdio_common_vsprintf:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_ActivateObjectInstance@20:PROC
EXTRN	_DropView@4:PROC
EXTRN	_NetClose@8:PROC
EXTRN	_NetStatus@8:PROC
EXTRN	_RegisterZeidonApplication@28:PROC
EXTRN	_ProcessZeidonMessage@8:PROC
EXTRN	_UnregisterZeidonApplication@4:PROC
EXTRN	_SysGetDateTime@4:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	__beginthreadex:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzschedt.c
_TEXT	SEGMENT
_szMsg$ = -104						; size = 100
__$ArrayPad$ = -4					; size = 4
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_idEvent$ = 16						; size = 4
_dwTime$ = 20						; size = 4
_TimerProc@16 PROC

; 351  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 352  :    zCHAR  szMsg[ 100 ];
; 353  : #if 0
; 354  :    zVIEW  vView;
; 355  :    zVIEW  vLocalSubtask;
; 356  : 
; 357  :    SfCreateSubtask( &vLocalSubtask, g_vSubtask, "ePamms" );
; 358  :    if ( vLocalSubtask )
; 359  :    {
; 360  :       zCHAR szDateTime[ 30 ];
; 361  : 
; 362  :       SysGetDateTime( szDateTime );
; 363  :       TraceLineI( szDateTime, 0 );
; 364  : 
; 365  :       ActivateObjectInstance( &vView, "mMedCode", vLocalSubtask, 0, zSINGLE );
; 366  :       DropView( vView );
; 367  :       SfDropSubtask( vLocalSubtask, 0 );
; 368  :    }
; 369  : #endif
; 370  : 
; 371  :    // DoWork( vSubtask );
; 372  :    g_ulTestCount++;

	mov	eax, DWORD PTR _g_ulTestCount
	add	eax, 1
	mov	DWORD PTR _g_ulTestCount, eax

; 373  : 
; 374  :    zsprintf( szMsg, "Done with test %u", g_ulTestCount );

	mov	ecx, DWORD PTR _g_ulTestCount
	push	ecx
	push	OFFSET $SG93989
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 375  :    TraceLineS( szMsg, "" );

	push	OFFSET $SG93990
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	_TraceLineS@8

; 376  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TimerProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzschedt.c
_TEXT	SEGMENT
_bIsVisible$ = -12					; size = 4
_hMenuTrackPopup$ = -8					; size = 4
_hMenu$ = -4						; size = 4
_hWnd$ = 8						; size = 4
_point$ = 12						; size = 8
_HandlePopupMenu@12 PROC

; 274  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 275  : 
; 276  :    HMENU hMenu;
; 277  :    HMENU hMenuTrackPopup;
; 278  :    BOOL  bIsVisible;
; 279  : 
; 280  :    // Get the menu for the windows.
; 281  :    hMenu = LoadMenu( g_hInstRes, MAKEINTRESOURCE( ID_SYSTRAY_MNU ) );

	push	323					; 00000143H
	mov	eax, DWORD PTR _g_hInstRes
	push	eax
	call	DWORD PTR __imp__LoadMenuA@8
	mov	DWORD PTR _hMenu$[ebp], eax

; 282  : 
; 283  :    if ( hMenu == 0 )

	cmp	DWORD PTR _hMenu$[ebp], 0
	jne	SHORT $LN2@HandlePopu

; 284  :       return;

	jmp	SHORT $LN1@HandlePopu
$LN2@HandlePopu:

; 285  : 
; 286  :    // Get the first menu in it which we will use for the call to TrackPopup( ).
; 287  :    // This could also have been created on the fly using CreatePopupMenu and
; 288  :    // then we could have used InsertMenu( ) or AppendMenu.
; 289  :    hMenuTrackPopup = GetSubMenu( hMenu, 0 );

	push	0
	mov	ecx, DWORD PTR _hMenu$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetSubMenu@8
	mov	DWORD PTR _hMenuTrackPopup$[ebp], eax

; 290  : 
; 291  :    // This is required when using a notify icon -- see KB article
; 292  :    // PRB: Menus for Notification Icons Don't Work Correctly
; 293  :    SetForegroundWindow( hWnd );

	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__SetForegroundWindow@4

; 294  : 
; 295  :    bIsVisible = IsWindowVisible( hWnd );

	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__IsWindowVisible@4
	mov	DWORD PTR _bIsVisible$[ebp], eax

; 296  : 
; 297  :    TrackPopupMenu( hMenuTrackPopup, TPM_LEFTBUTTON | TPM_RIGHTBUTTON,

	push	0
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR _point$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _point$[ebp]
	push	eax
	push	2
	mov	ecx, DWORD PTR _hMenuTrackPopup$[ebp]
	push	ecx
	call	DWORD PTR __imp__TrackPopupMenu@28

; 298  :                    point.x, point.y, 0, hWnd, NULL );
; 299  : 
; 300  :    // This is required when using a notify icon -- see KB article
; 301  :    // PRB: Menus for Notification Icons Don't Work Correctly
; 302  :    PostMessage( hWnd, WM_USER, 0, 0 );

	push	0
	push	0
	push	1024					; 00000400H
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__PostMessageA@16
$LN1@HandlePopu:

; 303  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_HandlePopupMenu@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzschedt.c
_TEXT	SEGMENT
_vSubtask$ = 8						; size = 4
_Exit@4	PROC

; 256  : {

	push	ebp
	mov	ebp, esp

; 257  :    g_DoWork = FALSE;

	mov	BYTE PTR _g_DoWork, 0

; 258  :    Cleanup( vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_Cleanup@4

; 259  : 
; 260  :    return( 0 );

	xor	eax, eax

; 261  : }

	pop	ebp
	ret	4
_Exit@4	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzschedt.c
_TEXT	SEGMENT
_vSubtask$ = 8						; size = 4
_Cleanup@4 PROC

; 243  : {

	push	ebp
	mov	ebp, esp

; 244  :    DetachSysTray( ); // remove Icon from systray

	call	_DetachSysTray

; 245  : 
; 246  :    return( 0 );

	xor	eax, eax

; 247  : }

	pop	ebp
	ret	4
_Cleanup@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzschedt.c
_TEXT	SEGMENT
_hInst$ = -8						; size = 4
_hLibrary$ = -4						; size = 4
_vSubtask$ = 8						; size = 4
_PostBuild@4 PROC

; 214  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 215  :    HMODULE   hLibrary;
; 216  :    HINSTANCE hInst;
; 217  : // zULONG ulWindowHandle;
; 218  : 
; 219  : // g_hWndMain = GetConsoleWindow( );
; 220  : 
; 221  : // GetWindowHandle( &ulWindowHandle, 0, vSubtask, 0 );
; 222  : // g_hWndMain = (HWND) ulWindowHandle;
; 223  : 
; 224  :    hInst = (HINSTANCE) GetWindowLong( g_hWndMain, GWL_HINSTANCE );

	push	-6					; fffffffaH
	mov	eax, DWORD PTR _g_hWndMain
	push	eax
	call	DWORD PTR __imp__GetWindowLongA@8
	mov	DWORD PTR _hInst$[ebp], eax

; 225  : 
; 226  :    ShowWindow( g_hWndMain, SW_HIDE );

	push	0
	mov	ecx, DWORD PTR _g_hWndMain
	push	ecx
	call	DWORD PTR __imp__ShowWindow@8

; 227  : 
; 228  :    hLibrary = LoadLibraryEx( "KZSchedT.exe", 0, LOAD_LIBRARY_AS_DATAFILE );

	push	2
	push	0
	push	OFFSET $SG93939
	call	DWORD PTR __imp__LoadLibraryExA@12
	mov	DWORD PTR _hLibrary$[ebp], eax

; 229  :    g_hInstRes = (HINSTANCE) hLibrary;

	mov	edx, DWORD PTR _hLibrary$[ebp]
	mov	DWORD PTR _g_hInstRes, edx

; 230  : 
; 231  :    SetupSysTray( g_hInstRes );

	mov	eax, DWORD PTR _g_hInstRes
	push	eax
	call	_SetupSysTray
	add	esp, 4

; 232  : 
; 233  :    return( 0 );

	xor	eax, eax

; 234  : }

	mov	esp, ebp
	pop	ebp
	ret	4
_PostBuild@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzschedt.c
_TEXT	SEGMENT
_DetachSysTray PROC

; 203  : {

	push	ebp
	mov	ebp, esp

; 204  :    TrayMessage( NIM_DELETE, zTRAY_MESSAGE_SHOW, NULL, NULL );

	push	0
	push	0
	push	2
	push	2
	call	_TrayMessage
	add	esp, 16					; 00000010H

; 205  : }

	pop	ebp
	ret	0
_DetachSysTray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzschedt.c
_TEXT	SEGMENT
_hIcon$ = -140						; size = 4
_bReturn$ = -133					; size = 1
_szTip$ = -132						; size = 128
__$ArrayPad$ = -4					; size = 4
_hInst$ = 8						; size = 4
_SetupSysTray PROC

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 140				; 0000008cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 184  :    zBOOL bReturn = FALSE;

	mov	BYTE PTR _bReturn$[ebp], 0

; 185  :    HICON hIcon = NULL;

	mov	DWORD PTR _hIcon$[ebp], 0

; 186  :    char szTip[ 128 ];
; 187  : 
; 188  :    hIcon = LoadIcon( hInst, "ZEIDON_MONITOR" );

	push	OFFSET $SG93926
	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	call	DWORD PTR __imp__LoadIconA@8
	mov	DWORD PTR _hIcon$[ebp], eax

; 189  :    GetWindowText( g_hWndMain, szTip, 127 );

	push	127					; 0000007fH
	lea	ecx, DWORD PTR _szTip$[ebp]
	push	ecx
	mov	edx, DWORD PTR _g_hWndMain
	push	edx
	call	DWORD PTR __imp__GetWindowTextA@12

; 190  :    bReturn = TrayMessage( NIM_ADD, zTRAY_MESSAGE_SHOW, hIcon, szTip );

	lea	eax, DWORD PTR _szTip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hIcon$[ebp]
	push	ecx
	push	2
	push	0
	call	_TrayMessage
	add	esp, 16					; 00000010H
	mov	BYTE PTR _bReturn$[ebp], al

; 191  : 
; 192  :    return( bReturn );

	mov	al, BYTE PTR _bReturn$[ebp]

; 193  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_SetupSysTray ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzschedt.c
_TEXT	SEGMENT
_bRC$ = -513						; size = 1
_tnd$ = -512						; size = 508
__$ArrayPad$ = -4					; size = 4
_dwMessage$ = 8						; size = 4
_uID$ = 12						; size = 4
_hIcon$ = 16						; size = 4
_pszTip$ = 20						; size = 4
_TrayMessage PROC

; 148  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 516				; 00000204H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 149  :    NOTIFYICONDATA tnd;
; 150  :    zBOOL bRC;
; 151  : 
; 152  :    tnd.cbSize      = sizeof( NOTIFYICONDATA );

	mov	DWORD PTR _tnd$[ebp], 508		; 000001fcH

; 153  :    tnd.hWnd        = g_hWndMain;

	mov	eax, DWORD PTR _g_hWndMain
	mov	DWORD PTR _tnd$[ebp+4], eax

; 154  :    tnd.uID         = uID;

	mov	ecx, DWORD PTR _uID$[ebp]
	mov	DWORD PTR _tnd$[ebp+8], ecx

; 155  :    tnd.uFlags      = NIF_MESSAGE | NIF_ICON | NIF_TIP;

	mov	DWORD PTR _tnd$[ebp+12], 7

; 156  :    tnd.uCallbackMessage = zWM_NOTIFYICON;  // notification message for message loop

	mov	DWORD PTR _tnd$[ebp+16], 32868		; 00008064H

; 157  :    tnd.hIcon      = hIcon;

	mov	edx, DWORD PTR _hIcon$[ebp]
	mov	DWORD PTR _tnd$[ebp+20], edx

; 158  :    if ( pszTip )

	cmp	DWORD PTR _pszTip$[ebp], 0
	je	SHORT $LN2@TrayMessag

; 159  :    {
; 160  :       zstrncpy( tnd.szTip, pszTip, sizeof( tnd.szTip ) );

	push	128					; 00000080H
	mov	eax, DWORD PTR _pszTip$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tnd$[ebp+24]
	push	ecx
	call	_strncpy
	add	esp, 12					; 0000000cH

; 161  :    }

	jmp	SHORT $LN3@TrayMessag
$LN2@TrayMessag:

; 162  :    else
; 163  :    {
; 164  :       tnd.szTip[ 0 ] = 0;

	mov	edx, 1
	imul	eax, edx, 0
	mov	BYTE PTR _tnd$[ebp+eax+24], 0
$LN3@TrayMessag:

; 165  :    }
; 166  : 
; 167  :    bRC = Shell_NotifyIcon( dwMessage, &tnd );

	lea	ecx, DWORD PTR _tnd$[ebp]
	push	ecx
	mov	edx, DWORD PTR _dwMessage$[ebp]
	push	edx
	call	DWORD PTR __imp__Shell_NotifyIconA@8
	mov	BYTE PTR _bRC$[ebp], al

; 168  : 
; 169  :    if ( hIcon )

	cmp	DWORD PTR _hIcon$[ebp], 0
	je	SHORT $LN4@TrayMessag

; 170  :        DestroyIcon( hIcon );

	mov	eax, DWORD PTR _hIcon$[ebp]
	push	eax
	call	DWORD PTR __imp__DestroyIcon@4
$LN4@TrayMessag:

; 171  : 
; 172  :    return( bRC );

	mov	al, BYTE PTR _bRC$[ebp]

; 173  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TrayMessage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzschedt.c
_TEXT	SEGMENT
tv148 = -260						; size = 4
_vView$ = -256						; size = 4
_vSubtask$ = -252					; size = 4
_nCount$ = -248						; size = 4
_nRC$ = -244						; size = 2
_nThreadNumber$ = -240					; size = 2
_szMsg$ = -236						; size = 200
_szDateTime$1 = -36					; size = 30
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_fnThreadProc2@4 PROC

; 71   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 72   :    zVIEW  vSubtask;
; 73   :    zLONG  nCount = 0;

	mov	DWORD PTR _nCount$[ebp], 0

; 74   :    zVIEW  vView;
; 75   :    char   szMsg[ 200 ];
; 76   :    zSHORT nRC;
; 77   :    zSHORT nThreadNumber = (zSHORT) p;

	mov	ax, WORD PTR _p$[ebp]
	mov	WORD PTR _nThreadNumber$[ebp], ax

; 78   : 
; 79   :    TraceLineI( "Starting thread test", nThreadNumber );

	movsx	ecx, WORD PTR _nThreadNumber$[ebp]
	push	ecx
	push	OFFSET $SG93889
	call	_TraceLineI@8
$LN2@fnThreadPr:

; 80   : 
; 81   :    while ( g_bContinueThreadTest )

	movzx	edx, BYTE PTR _g_bContinueThreadTest
	test	edx, edx
	je	$LN3@fnThreadPr

; 82   :    {
; 83   :       zCHAR szDateTime[ 30 ];
; 84   : 
; 85   :       if ( !bThreadRegistered )

	mov	eax, DWORD PTR __tls_index
	mov	ecx, DWORD PTR fs:__tls_array
	mov	edx, DWORD PTR [ecx+eax*4]
	movzx	eax, BYTE PTR _bThreadRegistered[edx]
	test	eax, eax
	jne	SHORT $LN4@fnThreadPr

; 86   :       {
; 87   :          if ( RegisterZeidonApplication( &vSubtask,
; 88   :                                          (zLONG) g_hInst,
; 89   :                                          (zLONG) g_hWndMain,
; 90   :                                          (zLONG) g_wClientMessage,
; 91   :                                          "\\\\ePamms\\", 0, 0 ) == zCALL_ERROR )

	push	0
	push	0
	push	OFFSET $SG93892
	movzx	ecx, WORD PTR _g_wClientMessage
	push	ecx
	mov	edx, DWORD PTR _g_hWndMain
	push	edx
	mov	eax, DWORD PTR _g_hInst
	push	eax
	lea	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_RegisterZeidonApplication@28
	movsx	edx, ax
	cmp	edx, -16				; fffffff0H
	jne	SHORT $LN5@fnThreadPr

; 92   :          {
; 93   :             g_dwTestThreadID = 0;

	mov	DWORD PTR _g_dwTestThreadID, 0

; 94   :             return( 0 );

	xor	eax, eax
	jmp	$LN1@fnThreadPr
$LN5@fnThreadPr:

; 95   :          }
; 96   : 
; 97   :          bThreadRegistered = TRUE;

	mov	eax, DWORD PTR __tls_index
	mov	ecx, DWORD PTR fs:__tls_array
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	BYTE PTR _bThreadRegistered[edx], 1

; 98   :          TraceLineI( "Completed thread register", nThreadNumber );

	movsx	eax, WORD PTR _nThreadNumber$[ebp]
	push	eax
	push	OFFSET $SG93893
	call	_TraceLineI@8
$LN4@fnThreadPr:

; 99   :       }
; 100  : 
; 101  :    // if ( nThreadNumber == 2 )
; 102  :    //    Sleep( 500 );
; 103  :       Sleep( 100 * ((nThreadNumber % 5) + 1) );

	movsx	eax, WORD PTR _nThreadNumber$[ebp]
	cdq
	mov	ecx, 5
	idiv	ecx
	add	edx, 1
	imul	edx, edx, 100
	push	edx
	call	DWORD PTR __imp__Sleep@4

; 104  : 
; 105  :    // SysMutexLock( "KZSCHEDT/1", 0, 0 );
; 106  :    // TraceLineI( "Mutex locked", nThreadNumber );
; 107  : 
; 108  :       SysGetDateTime( szDateTime );

	lea	eax, DWORD PTR _szDateTime$1[ebp]
	push	eax
	call	_SysGetDateTime@4

; 109  :       TraceLineI( szDateTime, nThreadNumber );

	movsx	ecx, WORD PTR _nThreadNumber$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szDateTime$1[ebp]
	push	edx
	call	_TraceLineI@8

; 110  : 
; 111  :       nRC = ActivateObjectInstance( &vView, "mUser", vSubtask, 0, zSINGLE );

	push	0
	push	0
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	push	OFFSET $SG93894
	lea	ecx, DWORD PTR _vView$[ebp]
	push	ecx
	call	_ActivateObjectInstance@20
	mov	WORD PTR _nRC$[ebp], ax

; 112  :       if ( nRC >= 0 )

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	SHORT $LN6@fnThreadPr

; 113  :          DropView( vView );

	mov	eax, DWORD PTR _vView$[ebp]
	push	eax
	call	_DropView@4
	jmp	SHORT $LN7@fnThreadPr
$LN6@fnThreadPr:

; 114  :       else
; 115  :          TraceLineI( "----- ERROR activating mUser --------- ", nThreadNumber );

	movsx	ecx, WORD PTR _nThreadNumber$[ebp]
	push	ecx
	push	OFFSET $SG93897
	call	_TraceLineI@8
$LN7@fnThreadPr:

; 116  : 
; 117  :       zsprintf( szMsg, "Thread test #%d, rc = %d", nCount++, nRC );

	mov	edx, DWORD PTR _nCount$[ebp]
	mov	DWORD PTR tv148[ebp], edx
	movsx	eax, WORD PTR _nRC$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv148[ebp]
	push	ecx
	push	OFFSET $SG93898
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_sprintf
	add	esp, 16					; 00000010H
	mov	eax, DWORD PTR _nCount$[ebp]
	add	eax, 1
	mov	DWORD PTR _nCount$[ebp], eax

; 118  :       TraceLineI( szMsg, nThreadNumber );

	movsx	ecx, WORD PTR _nThreadNumber$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szMsg$[ebp]
	push	edx
	call	_TraceLineI@8

; 119  : 
; 120  :    // SysMutexUnlock( "KZSCHEDT/1" );
; 121  :    // TraceLineI( "Mutex unlocked", nThreadNumber );
; 122  :    }

	jmp	$LN2@fnThreadPr
$LN3@fnThreadPr:

; 123  : 
; 124  :    if ( bThreadRegistered )

	mov	eax, DWORD PTR __tls_index
	mov	ecx, DWORD PTR fs:__tls_array
	mov	edx, DWORD PTR [ecx+eax*4]
	movzx	eax, BYTE PTR _bThreadRegistered[edx]
	test	eax, eax
	je	SHORT $LN8@fnThreadPr

; 125  :    {
; 126  :       UnregisterZeidonApplication( vSubtask );

	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_UnregisterZeidonApplication@4

; 127  :       vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 128  :       bThreadRegistered = FALSE;

	mov	edx, DWORD PTR __tls_index
	mov	eax, DWORD PTR fs:__tls_array
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	BYTE PTR _bThreadRegistered[ecx], 0

; 129  :       TraceLineI( "Completed thread UN(!)register", nThreadNumber );

	movsx	edx, WORD PTR _nThreadNumber$[ebp]
	push	edx
	push	OFFSET $SG93900
	call	_TraceLineI@8
$LN8@fnThreadPr:

; 130  :    }
; 131  : 
; 132  :    g_dwTestThreadID = 0;

	mov	DWORD PTR _g_dwTestThreadID, 0

; 133  :    TraceLineI( "Completed thread test", nThreadNumber );

	movsx	eax, WORD PTR _nThreadNumber$[ebp]
	push	eax
	push	OFFSET $SG93901
	call	_TraceLineI@8

; 134  : 
; 135  :    return( 0 );

	xor	eax, eax
$LN1@fnThreadPr:

; 136  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnThreadProc2@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzschedt.c
_TEXT	SEGMENT
_point$1 = -16						; size = 8
_k$2 = -8						; size = 4
tv64 = -4						; size = 4
_hWnd$ = 8						; size = 4
_uMsg$ = 12						; size = 4
_wParam$ = 16						; size = 4
_lParam$ = 20						; size = 4
_MainWndProc@16 PROC

; 390  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 391  :    switch ( uMsg )

	mov	eax, DWORD PTR _uMsg$[ebp]
	mov	DWORD PTR tv64[ebp], eax
	cmp	DWORD PTR tv64[ebp], 260		; 00000104H
	ja	SHORT $LN26@MainWndPro
	cmp	DWORD PTR tv64[ebp], 260		; 00000104H
	je	$LN19@MainWndPro
	cmp	DWORD PTR tv64[ebp], 2
	je	$LN11@MainWndPro
	cmp	DWORD PTR tv64[ebp], 16			; 00000010H
	je	SHORT $LN7@MainWndPro
	cmp	DWORD PTR tv64[ebp], 256		; 00000100H
	je	$LN19@MainWndPro
	jmp	$LN23@MainWndPro
$LN26@MainWndPro:
	cmp	DWORD PTR tv64[ebp], 273		; 00000111H
	je	$LN12@MainWndPro
	cmp	DWORD PTR tv64[ebp], 32868		; 00008064H
	je	$LN21@MainWndPro
	jmp	$LN23@MainWndPro
$LN7@MainWndPro:

; 392  :    {
; 393  :       case WM_CLOSE:
; 394  :          // Check to see if the network is up.
; 395  :          if ( g_bRunningTest )

	movzx	ecx, BYTE PTR _g_bRunningTest
	test	ecx, ecx
	je	SHORT $LN8@MainWndPro

; 396  :          {
; 397  :             SysMessageBox( 0, "Test In Progress", "Close running test", -1 );

	push	-1
	push	OFFSET $SG94012
	push	OFFSET $SG94013
	push	0
	call	_SysMessageBox@16

; 398  :             return( 0 );

	xor	eax, eax
	jmp	$LN1@MainWndPro
$LN8@MainWndPro:

; 399  :          }
; 400  : 
; 401  :          KillTimer( hWnd, 14 );  // 14 just picked out of the hat

	push	14					; 0000000eH
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__KillTimer@8

; 402  :          Exit( g_vSubtask );

	mov	eax, DWORD PTR _g_vSubtask
	push	eax
	call	_Exit@4

; 403  : 
; 404  :          if ( g_vSubtask && NetStatus( g_vSubtask, "zWinSock" ) != 0 )

	cmp	DWORD PTR _g_vSubtask, 0
	je	SHORT $LN9@MainWndPro
	push	OFFSET $SG94015
	mov	ecx, DWORD PTR _g_vSubtask
	push	ecx
	call	_NetStatus@8
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN9@MainWndPro

; 405  :             NetClose( g_vSubtask, "zWinSock" );

	push	OFFSET $SG94016
	mov	eax, DWORD PTR _g_vSubtask
	push	eax
	call	_NetClose@8
$LN9@MainWndPro:

; 406  : 
; 407  :          // It's OK to leave, shut down Object Services.
; 408  :          if ( g_nNoUnregister != 99 && g_vSubtask )

	cmp	DWORD PTR _g_nNoUnregister, 99		; 00000063H
	je	SHORT $LN10@MainWndPro
	cmp	DWORD PTR _g_vSubtask, 0
	je	SHORT $LN10@MainWndPro

; 409  :             UnregisterZeidonApplication( g_vSubtask );

	mov	ecx, DWORD PTR _g_vSubtask
	push	ecx
	call	_UnregisterZeidonApplication@4
$LN10@MainWndPro:

; 410  : 
; 411  :          return( DefWindowProc( hWnd, uMsg, wParam, lParam ));

	mov	edx, DWORD PTR _lParam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	mov	ecx, DWORD PTR _uMsg$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__DefWindowProcA@16
	jmp	$LN1@MainWndPro
$LN11@MainWndPro:

; 412  : 
; 413  :       case WM_DESTROY:         // window being destroyed
; 414  :          PostQuitMessage( 0 );

	push	0
	call	DWORD PTR __imp__PostQuitMessage@4

; 415  :          break;

	jmp	$LN2@MainWndPro
$LN12@MainWndPro:

; 416  : 
; 417  :       case WM_COMMAND:
; 418  :          if ( wParam == 114 )  // exit

	cmp	DWORD PTR _wParam$[ebp], 114		; 00000072H
	jne	SHORT $LN13@MainWndPro

; 419  :          {
; 420  :             PostMessage( hWnd, WM_CLOSE, 0, 0L );

	push	0
	push	0
	push	16					; 00000010H
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	DWORD PTR __imp__PostMessageA@16

; 421  :          }

	jmp	$LN14@MainWndPro
$LN13@MainWndPro:

; 422  :          else
; 423  :          if ( wParam == 115 )  // ID_TEST

	cmp	DWORD PTR _wParam$[ebp], 115		; 00000073H
	jne	SHORT $LN14@MainWndPro

; 424  :          {
; 425  :             if ( g_bRunningTest )

	movzx	ecx, BYTE PTR _g_bRunningTest
	test	ecx, ecx
	je	SHORT $LN16@MainWndPro

; 426  :             {
; 427  :                g_bRunningTest = FALSE;

	mov	BYTE PTR _g_bRunningTest, 0

; 428  :                g_bContinueThreadTest = FALSE;

	mov	BYTE PTR _g_bContinueThreadTest, 0

; 429  :             }

	jmp	SHORT $LN14@MainWndPro
$LN16@MainWndPro:

; 430  :             else
; 431  :             {
; 432  :                int k;
; 433  : 
; 434  :                g_bRunningTest = TRUE;

	mov	BYTE PTR _g_bRunningTest, 1

; 435  :             // SetTimer( hWnd, 0, 100, (TIMERPROC) TimerProc );
; 436  : 
; 437  :                g_bContinueThreadTest = TRUE;

	mov	BYTE PTR _g_bContinueThreadTest, 1

; 438  : 
; 439  :                for ( k = 1; k <= NUM_THREADS; k++ )

	mov	DWORD PTR _k$2[ebp], 1
	jmp	SHORT $LN6@MainWndPro
$LN4@MainWndPro:
	mov	edx, DWORD PTR _k$2[ebp]
	add	edx, 1
	mov	DWORD PTR _k$2[ebp], edx
$LN6@MainWndPro:
	cmp	DWORD PTR _k$2[ebp], 1
	jg	SHORT $LN14@MainWndPro

; 440  :                {
; 441  :                   g_hTestThread = _beginthreadex( NULL, 0, fnThreadProc2,

	push	OFFSET _g_dwTestThreadID
	push	0
	mov	eax, DWORD PTR _k$2[ebp]
	push	eax
	push	OFFSET _fnThreadProc2@4
	push	0
	push	0
	call	__beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR _g_hTestThread, eax

; 442  :                                                   (void *) k, 0, &g_dwTestThreadID );
; 443  :                   if ( g_hTestThread )

	cmp	DWORD PTR _g_hTestThread, 0
	je	SHORT $LN18@MainWndPro

; 444  :                      CloseHandle( (HANDLE) g_hTestThread );

	mov	ecx, DWORD PTR _g_hTestThread
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4
$LN18@MainWndPro:

; 445  :                }

	jmp	SHORT $LN4@MainWndPro
$LN14@MainWndPro:

; 446  :             }
; 447  :          }
; 448  : 
; 449  :          break;

	jmp	SHORT $LN2@MainWndPro
$LN19@MainWndPro:

; 450  : 
; 451  :       case WM_KEYDOWN:
; 452  :       case WM_SYSKEYDOWN:
; 453  :          if ( wParam == VK_F3 )

	cmp	DWORD PTR _wParam$[ebp], 114		; 00000072H
	jne	SHORT $LN20@MainWndPro

; 454  :             PostMessage( hWnd, WM_CLOSE, 0, 0L );

	push	0
	push	0
	push	16					; 00000010H
	mov	edx, DWORD PTR _hWnd$[ebp]
	push	edx
	call	DWORD PTR __imp__PostMessageA@16
$LN20@MainWndPro:

; 455  : 
; 456  :          break;

	jmp	SHORT $LN2@MainWndPro
$LN21@MainWndPro:

; 457  : 
; 458  :       // entry for systray notifications
; 459  :       case zWM_NOTIFYICON:
; 460  :          if ( lParam == WM_RBUTTONDOWN )

	cmp	DWORD PTR _lParam$[ebp], 516		; 00000204H
	jne	SHORT $LN22@MainWndPro

; 461  :          {
; 462  :             POINT point;
; 463  : 
; 464  :             GetCursorPos( &point );

	lea	eax, DWORD PTR _point$1[ebp]
	push	eax
	call	DWORD PTR __imp__GetCursorPos@4

; 465  :             HandlePopupMenu( hWnd, point );

	mov	ecx, DWORD PTR _point$1[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _point$1[ebp]
	push	edx
	mov	eax, DWORD PTR _hWnd$[ebp]
	push	eax
	call	_HandlePopupMenu@12
$LN22@MainWndPro:

; 466  :          }
; 467  : 
; 468  :          break;

	jmp	SHORT $LN2@MainWndPro
$LN23@MainWndPro:

; 469  : 
; 470  :       default:
; 471  :          if ( uMsg == g_wClientMessage )

	movzx	ecx, WORD PTR _g_wClientMessage
	cmp	DWORD PTR _uMsg$[ebp], ecx
	jne	SHORT $LN2@MainWndPro

; 472  :             ProcessZeidonMessage( wParam, lParam );

	mov	edx, DWORD PTR _lParam$[ebp]
	push	edx
	mov	eax, DWORD PTR _wParam$[ebp]
	push	eax
	call	_ProcessZeidonMessage@8
$LN2@MainWndPro:

; 473  : 
; 474  :          break;
; 475  :    }
; 476  : 
; 477  :    return( DefWindowProc( hWnd, uMsg, wParam, lParam ));

	mov	ecx, DWORD PTR _lParam$[ebp]
	push	ecx
	mov	edx, DWORD PTR _wParam$[ebp]
	push	edx
	mov	eax, DWORD PTR _uMsg$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hWnd$[ebp]
	push	ecx
	call	DWORD PTR __imp__DefWindowProcA@16
$LN1@MainWndPro:

; 478  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_MainWndProc@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzschedt.c
_TEXT	SEGMENT
_wc$ = -40						; size = 40
_hInst$ = 8						; size = 4
_InitApplication PROC

; 489  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 490  :    WNDCLASS  wc;
; 491  : 
; 492  :    // Fill in window class structure with parameters that describe the main window.
; 493  : 
; 494  :    wc.style = 0;                       // Class style(s).

	mov	DWORD PTR _wc$[ebp], 0

; 495  :    wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for

	mov	DWORD PTR _wc$[ebp+4], OFFSET _MainWndProc@16

; 496  :                                        // windows of this class.
; 497  :    wc.cbClsExtra = 0;                  // No per-class extra data.

	mov	DWORD PTR _wc$[ebp+8], 0

; 498  :    wc.cbWndExtra = 0;                  // No per-window extra data.

	mov	DWORD PTR _wc$[ebp+12], 0

; 499  :    wc.hInstance = hInst;           // Application that owns the class.

	mov	eax, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR _wc$[ebp+16], eax

; 500  :    wc.hIcon = LoadIcon( hInst, "KZSCHEDT" );

	push	OFFSET $SG94039
	mov	ecx, DWORD PTR _hInst$[ebp]
	push	ecx
	call	DWORD PTR __imp__LoadIconA@8
	mov	DWORD PTR _wc$[ebp+20], eax

; 501  :    wc.hCursor = LoadCursor( 0, IDC_ARROW );

	push	32512					; 00007f00H
	push	0
	call	DWORD PTR __imp__LoadCursorA@8
	mov	DWORD PTR _wc$[ebp+24], eax

; 502  :    wc.hbrBackground = GetStockObject( WHITE_BRUSH );

	push	0
	call	DWORD PTR __imp__GetStockObject@4
	mov	DWORD PTR _wc$[ebp+28], eax

; 503  :    wc.lpszMenuName =  0;               // Name of menu resource in .RC file.

	mov	DWORD PTR _wc$[ebp+32], 0

; 504  :    wc.lpszClassName = g_szClassName;     // Name used in call to CreateWindow.

	mov	DWORD PTR _wc$[ebp+36], OFFSET _g_szClassName

; 505  : 
; 506  :    // Register the window class and return success/failure code.
; 507  :    return( RegisterClass( &wc ) );

	lea	edx, DWORD PTR _wc$[ebp]
	push	edx
	call	DWORD PTR __imp__RegisterClassA@4
	movzx	eax, ax

; 508  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_InitApplication ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzschedt.c
_TEXT	SEGMENT
_nPosX$ = -16						; size = 4
_nPosY$ = -12						; size = 4
_nWidth$ = -8						; size = 4
_nHeight$ = -4						; size = 4
_hInst$ = 8						; size = 4
_nCmdShow$ = 12						; size = 4
_lpCmdLine$ = 16					; size = 4
_InitInstance PROC

; 530  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 531  :    int   nHeight, nPosY;
; 532  :    int   nWidth, nPosX;
; 533  : 
; 534  :    // Save the instance handle in static variable, which will be used in many subsequent
; 535  :    // calls from this application to Windows.
; 536  : 
; 537  :    g_hInst = hInst;

	mov	eax, DWORD PTR _hInst$[ebp]
	mov	DWORD PTR _g_hInst, eax

; 538  : 
; 539  :    // Get the dimensions of the screen.
; 540  :    nWidth = GetSystemMetrics( SM_CXSCREEN );

	push	0
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _nWidth$[ebp], eax

; 541  :    nHeight = GetSystemMetrics( SM_CYSCREEN );

	push	1
	call	DWORD PTR __imp__GetSystemMetrics@4
	mov	DWORD PTR _nHeight$[ebp], eax

; 542  :    nWidth /= 4;

	mov	eax, DWORD PTR _nWidth$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _nWidth$[ebp], eax

; 543  :    nHeight /= 4;

	mov	eax, DWORD PTR _nHeight$[ebp]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	mov	DWORD PTR _nHeight$[ebp], eax

; 544  :    nWidth -= 40;

	mov	ecx, DWORD PTR _nWidth$[ebp]
	sub	ecx, 40					; 00000028H
	mov	DWORD PTR _nWidth$[ebp], ecx

; 545  :    nHeight -= 20;

	mov	edx, DWORD PTR _nHeight$[ebp]
	sub	edx, 20					; 00000014H
	mov	DWORD PTR _nHeight$[ebp], edx

; 546  :    nPosX = nWidth / 2;

	mov	eax, DWORD PTR _nWidth$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nPosX$[ebp], eax

; 547  :    nPosY = nHeight / 2;

	mov	eax, DWORD PTR _nHeight$[ebp]
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _nPosY$[ebp], eax

; 548  :    nPosX -= 8; // so it doesn't occupy same space as object services

	mov	eax, DWORD PTR _nPosX$[ebp]
	sub	eax, 8
	mov	DWORD PTR _nPosX$[ebp], eax

; 549  :    nPosY -= 8;

	mov	ecx, DWORD PTR _nPosY$[ebp]
	sub	ecx, 8
	mov	DWORD PTR _nPosY$[ebp], ecx

; 550  : 
; 551  :    // Create a main window for this application instance.
; 552  :    g_hWndMain = CreateWindow( g_szClassName,                // see RegisterClass( ) call

	push	0
	mov	edx, DWORD PTR _hInst$[ebp]
	push	edx
	push	OFFSET $SG94055
	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	call	DWORD PTR __imp__LoadMenuA@8
	push	eax
	push	0
	mov	ecx, DWORD PTR _nHeight$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nWidth$[ebp]
	push	edx
	mov	eax, DWORD PTR _nPosY$[ebp]
	push	eax
	mov	ecx, DWORD PTR _nPosX$[ebp]
	push	ecx
	push	13565952				; 00cf0000H
	push	OFFSET $SG94056
	push	OFFSET _g_szClassName
	push	0
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	DWORD PTR _g_hWndMain, eax

; 553  :                             "Task Scheduler",               // text for window title bar
; 554  :                             WS_OVERLAPPEDWINDOW,            // window style
; 555  :                             nPosX,                          // default horizontal position
; 556  :                             nPosY,                          // default vertical position
; 557  :                             nWidth,                         // default width
; 558  :                             nHeight,                        // default height
; 559  :                             0,                              // overlapped windows have no parent
; 560  :                             LoadMenu( hInst, "KZSCHEDT" ),  // menu for task scheduler window
; 561  :                          // 0,                              // use default menu
; 562  :                             hInst,                          // this instance owns this window
; 563  :                             0 );                            // pointer not needed
; 564  : 
; 565  : 
; 566  :    if ( g_hWndMain == 0 )  // if window could not be created, return "failure"

	cmp	DWORD PTR _g_hWndMain, 0
	jne	SHORT $LN2@InitInstan

; 567  :       return( FALSE );

	xor	eax, eax
	jmp	$LN1@InitInstan
$LN2@InitInstan:

; 568  : 
; 569  :    g_wClientMessage = RegisterWindowMessage( "KZSCHEDT" );

	push	OFFSET $SG94058
	call	DWORD PTR __imp__RegisterWindowMessageA@4
	mov	WORD PTR _g_wClientMessage, ax

; 570  : 
; 571  :    if ( RegisterZeidonApplication( &g_vSubtask, (zLONG) g_hInst,
; 572  :                                    (zLONG) g_hWndMain,
; 573  :                                    (zLONG) g_wClientMessage,
; 574  :                                    "\\\\ePamms\\", 0, 0 ) != 0 )

	push	0
	push	0
	push	OFFSET $SG94060
	movzx	edx, WORD PTR _g_wClientMessage
	push	edx
	mov	eax, DWORD PTR _g_hWndMain
	push	eax
	mov	ecx, DWORD PTR _g_hInst
	push	ecx
	push	OFFSET _g_vSubtask
	call	_RegisterZeidonApplication@28
	movsx	edx, ax
	test	edx, edx
	je	SHORT $LN3@InitInstan

; 575  :                                    //lpCmdLine, 0, 0 ) != 0 )
; 576  :    {
; 577  :       DestroyWindow( g_hWndMain );

	mov	eax, DWORD PTR _g_hWndMain
	push	eax
	call	DWORD PTR __imp__DestroyWindow@4

; 578  :       return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@InitInstan
$LN3@InitInstan:

; 579  :    }
; 580  : 
; 581  :    // Make the window visible ... will be undone in PostBuild.
; 582  :    ShowWindow( g_hWndMain, SW_SHOW );  // show the window

	push	5
	mov	ecx, DWORD PTR _g_hWndMain
	push	ecx
	call	DWORD PTR __imp__ShowWindow@8

; 583  :    TraceLineS( "Done registering", "" );

	push	OFFSET $SG94061
	push	OFFSET $SG94062
	call	_TraceLineS@8

; 584  : 
; 585  : // PostBuild( g_vSubtask );
; 586  :    SetTimer( g_hWndMain, 14, 5000, (TIMERPROC) TimerProc );    // 14 just picked out of the hat ... 5 second timeout

	push	OFFSET _TimerProc@16
	push	5000					; 00001388H
	push	14					; 0000000eH
	mov	edx, DWORD PTR _g_hWndMain
	push	edx
	call	DWORD PTR __imp__SetTimer@16

; 587  : 
; 588  :    return( g_hWndMain );

	mov	eax, DWORD PTR _g_hWndMain
$LN1@InitInstan:

; 589  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_InitInstance ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	___stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\kzschedt.c
_TEXT	SEGMENT
_msg$ = -32						; size = 28
_hWnd$ = -4						; size = 4
_hInst$ = 8						; size = 4
_hPrevInstance$ = 12					; size = 4
_lpCmdLine$ = 16					; size = 4
_nCmdShow$ = 20						; size = 4
_WinMain@16 PROC

; 318  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H

; 319  :    MSG msg;                       // message
; 320  :    HWND hWnd;                     // main window handle
; 321  : 
; 322  :    if ( hPrevInstance == 0 )      // other instances of app running?

	cmp	DWORD PTR _hPrevInstance$[ebp], 0
	jne	SHORT $LN4@WinMain

; 323  :    {
; 324  :       if ( InitApplication( hInst ) == 0 ) // initialize shared things

	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	call	_InitApplication
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN4@WinMain

; 325  :          return( FALSE );                  // exit if unable to initialize

	xor	eax, eax
	jmp	SHORT $LN1@WinMain
$LN4@WinMain:

; 326  :    }
; 327  : 
; 328  :    // Perform initializations that apply to a specific instance.
; 329  : 
; 330  :    if ( (hWnd = InitInstance( hInst, nCmdShow, lpCmdLine )) == 0 )

	mov	ecx, DWORD PTR _lpCmdLine$[ebp]
	push	ecx
	mov	edx, DWORD PTR _nCmdShow$[ebp]
	push	edx
	mov	eax, DWORD PTR _hInst$[ebp]
	push	eax
	call	_InitInstance
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _hWnd$[ebp], eax
	cmp	DWORD PTR _hWnd$[ebp], 0
	jne	SHORT $LN6@WinMain

; 331  :       return( FALSE );

	xor	eax, eax
	jmp	SHORT $LN1@WinMain
$LN6@WinMain:

; 332  : 
; 333  :    // Set g_nNoUnregister to 0.
; 334  :    g_nNoUnregister = 0;

	mov	DWORD PTR _g_nNoUnregister, 0
$LN2@WinMain:

; 335  : 
; 336  :    // Acquire and dispatch messages until a WM_QUIT message is received.
; 337  :    while ( GetMessage( &msg,    // message structure

	push	0
	push	0
	push	0
	lea	ecx, DWORD PTR _msg$[ebp]
	push	ecx
	call	DWORD PTR __imp__GetMessageA@16
	test	eax, eax
	je	SHORT $LN3@WinMain

; 338  :                        0,       // handle of window receiving the message
; 339  :                        0,       // lowest message to examine
; 340  :                        0 ) )    // highest message to examine
; 341  :    {
; 342  :       TranslateMessage( &msg ); // translate message

	lea	edx, DWORD PTR _msg$[ebp]
	push	edx
	call	DWORD PTR __imp__TranslateMessage@4

; 343  :       DispatchMessage( &msg );  // dispatches message to window

	lea	eax, DWORD PTR _msg$[ebp]
	push	eax
	call	DWORD PTR __imp__DispatchMessageA@4

; 344  :    }

	jmp	SHORT $LN2@WinMain
$LN3@WinMain:

; 345  : 
; 346  :    return( msg.wParam );        // returns the value from PostQuitMessage

	mov	eax, DWORD PTR _msg$[ebp+8]
$LN1@WinMain:

; 347  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_WinMain@16 ENDP
_TEXT	ENDS
END
