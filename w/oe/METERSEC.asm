; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\w\oe\METERSEC.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG85559 DB	'DKC_MSECT_EVT_%s', 00H
	ORG $+3
$SG85589 DB	'DKC_MSECT_MMF_%s', 00H
_DATA	ENDS
PUBLIC	_CreateMeteredSection
PUBLIC	_OpenMeteredSection
PUBLIC	_EnterMeteredSection
PUBLIC	_LeaveMeteredSection
PUBLIC	_CloseMeteredSection
PUBLIC	_InitMeteredSection
PUBLIC	_CreateMetSectEvent
PUBLIC	_CreateMetSectFileView
PUBLIC	_GetMeteredSectionLock
PUBLIC	_ReleaseMeteredSectionLock
EXTRN	_strlen:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__SetLastError@4:PROC
EXTRN	__imp__SetEvent@4:PROC
EXTRN	__imp__ResetEvent@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateEventA@16:PROC
EXTRN	__imp__OpenEventA@12:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__MapViewOfFile@20:PROC
EXTRN	__imp__UnmapViewOfFile@4:PROC
EXTRN	__imp__CreateFileMappingA@24:PROC
EXTRN	__imp__OpenFileMappingA@12:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	___security_cookie:DWORD
; Function compile flags: /Odtp
; File c:\10c\w\oe\metersec.c
_TEXT	SEGMENT
_lpMetSect$ = 8						; size = 4
_ReleaseMeteredSectionLock PROC

; 283  : {

	push	ebp
	mov	ebp, esp

; 284  :     InterlockedExchange(&(lpMetSect->lpSharedInfo->lSpinLock), 0);

	xor	eax, eax
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 4
	xchg	DWORD PTR [edx], eax

; 285  : }

	pop	ebp
	ret	0
_ReleaseMeteredSectionLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\metersec.c
_TEXT	SEGMENT
_lpMetSect$ = 8						; size = 4
_GetMeteredSectionLock PROC

; 273  : {

	push	ebp
	mov	ebp, esp
$LN2@GetMetered:

; 274  :     // Spin and get access to the metered section lock
; 275  :     while (InterlockedExchange(&(lpMetSect->lpSharedInfo->lSpinLock), 1) != 0)

	mov	eax, 1
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, 4
	xchg	DWORD PTR [edx], eax
	test	eax, eax
	je	SHORT $LN1@GetMetered

; 276  :         Sleep(0);

	push	0
	call	DWORD PTR __imp__Sleep@4
	jmp	SHORT $LN2@GetMetered
$LN1@GetMetered:

; 277  : }

	pop	ebp
	ret	0
_GetMeteredSectionLock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\metersec.c
_TEXT	SEGMENT
_dwLastError$ = -268					; size = 4
_sz$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_lpMetSect$ = 8						; size = 4
_lInitialCount$ = 12					; size = 4
_lMaximumCount$ = 16					; size = 4
_lpName$ = 20						; size = 4
_bOpenOnly$ = 24					; size = 4
_CreateMetSectFileView PROC

; 216  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 217  :     TCHAR sz[MAX_PATH];
; 218  :     DWORD dwLastError;
; 219  : 
; 220  :     if (lpName)

	cmp	DWORD PTR _lpName$[ebp], 0
	je	SHORT $LN4@CreateMetS

; 221  :     {
; 222  :         wsprintf(sz, _TEXT("DKC_MSECT_MMF_%s"), lpName);

	mov	eax, DWORD PTR _lpName$[ebp]
	push	eax
	push	OFFSET $SG85589
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 223  : 
; 224  : #ifndef _WIN32_WCE
; 225  :         if (bOpenOnly)

	cmp	DWORD PTR _bOpenOnly$[ebp], 0
	je	SHORT $LN6@CreateMetS

; 226  :         {
; 227  :             lpMetSect->hFileMap = OpenFileMapping(0, FALSE, sz);

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	0
	push	0
	call	DWORD PTR __imp__OpenFileMappingA@12
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 228  :         }

	jmp	SHORT $LN7@CreateMetS
$LN6@CreateMetS:

; 229  :         else
; 230  :         {
; 231  : #endif
; 232  :             // Create a named file mapping
; 233  :             lpMetSect->hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(METSECT_SHARED_INFO), sz);

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	20					; 00000014H
	push	0
	push	4
	push	0
	push	-1
	call	DWORD PTR __imp__CreateFileMappingA@24
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	DWORD PTR [ecx+4], eax
$LN7@CreateMetS:

; 234  : #ifndef _WIN32_WCE
; 235  :         }
; 236  : #endif
; 237  :     }

	jmp	SHORT $LN5@CreateMetS
$LN4@CreateMetS:

; 238  :     else
; 239  :     {
; 240  :         // Create an unnamed file mapping
; 241  :         lpMetSect->hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(METSECT_SHARED_INFO), NULL);

	push	0
	push	20					; 00000014H
	push	0
	push	4
	push	0
	push	-1
	call	DWORD PTR __imp__CreateFileMappingA@24
	mov	edx, DWORD PTR _lpMetSect$[ebp]
	mov	DWORD PTR [edx+4], eax
$LN5@CreateMetS:

; 242  :     }
; 243  : 
; 244  :     // Map a view of the file
; 245  :     if (lpMetSect->hFileMap)

	mov	eax, DWORD PTR _lpMetSect$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	$LN8@CreateMetS

; 246  :     {
; 247  :         dwLastError = GetLastError( );

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dwLastError$[ebp], eax

; 248  :         lpMetSect->lpSharedInfo = (LPMETSECT_SHARED_INFO) MapViewOfFile(lpMetSect->hFileMap, FILE_MAP_WRITE, 0, 0, 0);

	push	0
	push	0
	push	0
	push	2
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__MapViewOfFile@20
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 249  :         if (lpMetSect->lpSharedInfo)

	mov	edx, DWORD PTR _lpMetSect$[ebp]
	cmp	DWORD PTR [edx+8], 0
	je	SHORT $LN8@CreateMetS

; 250  :         {
; 251  :             if (dwLastError != ERROR_ALREADY_EXISTS)

	cmp	DWORD PTR _dwLastError$[ebp], 183	; 000000b7H
	je	SHORT $LN2@CreateMetS

; 252  :             {
; 253  :                 lpMetSect->lpSharedInfo->lSpinLock = 0;

	mov	eax, DWORD PTR _lpMetSect$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], 0

; 254  :                 lpMetSect->lpSharedInfo->lThreadsWaiting = 0;

	mov	edx, DWORD PTR _lpMetSect$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], 0

; 255  :                 lpMetSect->lpSharedInfo->lAvailableCount = lInitialCount;

	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _lInitialCount$[ebp]
	mov	DWORD PTR [edx+12], eax

; 256  :                 lpMetSect->lpSharedInfo->lMaximumCount = lMaximumCount;

	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _lMaximumCount$[ebp]
	mov	DWORD PTR [edx+16], eax

; 257  :                 InterlockedExchange(&(lpMetSect->lpSharedInfo->fInitialized), TRUE);

	mov	ecx, 1
	mov	edx, DWORD PTR _lpMetSect$[ebp]
	mov	eax, DWORD PTR [edx+8]
	xchg	DWORD PTR [eax], ecx

; 258  :             }

	jmp	SHORT $LN11@CreateMetS
$LN2@CreateMetS:

; 259  :             else
; 260  :             {   // already exists; wait for it to be initialized by the creator
; 261  :               while (!lpMetSect->lpSharedInfo->fInitialized) Sleep(0);

	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN11@CreateMetS
	push	0
	call	DWORD PTR __imp__Sleep@4
	jmp	SHORT $LN2@CreateMetS
$LN11@CreateMetS:

; 262  :             }
; 263  :             return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@CreateMetS
$LN8@CreateMetS:

; 264  :         }
; 265  :     }
; 266  :     return( FALSE );

	xor	eax, eax
$LN1@CreateMetS:

; 267  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CreateMetSectFileView ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\metersec.c
_TEXT	SEGMENT
tv88 = -268						; size = 4
_sz$ = -264						; size = 260
__$ArrayPad$ = -4					; size = 4
_lpMetSect$ = 8						; size = 4
_lpName$ = 12						; size = 4
_bOpenOnly$ = 16					; size = 4
_CreateMetSectEvent PROC

; 183  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 268				; 0000010cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 184  :     TCHAR sz[MAX_PATH];
; 185  :     if (lpName)

	cmp	DWORD PTR _lpName$[ebp], 0
	je	SHORT $LN2@CreateMetS

; 186  :     {
; 187  :         wsprintf(sz, _TEXT("DKC_MSECT_EVT_%s"), lpName);

	mov	eax, DWORD PTR _lpName$[ebp]
	push	eax
	push	OFFSET $SG85559
	lea	ecx, DWORD PTR _sz$[ebp]
	push	ecx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 188  : 
; 189  : #ifndef _WIN32_WCE
; 190  :         if (bOpenOnly)

	cmp	DWORD PTR _bOpenOnly$[ebp], 0
	je	SHORT $LN4@CreateMetS

; 191  :         {
; 192  :             lpMetSect->hEvent = OpenEvent(0, FALSE, sz);

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	0
	push	0
	call	DWORD PTR __imp__OpenEventA@12
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	DWORD PTR [ecx], eax

; 193  :         }

	jmp	SHORT $LN5@CreateMetS
$LN4@CreateMetS:

; 194  :         else
; 195  :         {
; 196  : #endif
; 197  :             // Create an auto-reset named event object
; 198  :             lpMetSect->hEvent = CreateEvent(NULL, FALSE, FALSE, sz);

	lea	edx, DWORD PTR _sz$[ebp]
	push	edx
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventA@16
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	DWORD PTR [ecx], eax
$LN5@CreateMetS:

; 199  : #ifndef _WIN32_WCE
; 200  :         }
; 201  : #endif
; 202  :     }

	jmp	SHORT $LN3@CreateMetS
$LN2@CreateMetS:

; 203  :     else
; 204  :     {
; 205  :         // Create an auto-reset unnamed event object
; 206  :         lpMetSect->hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	push	0
	push	0
	push	0
	push	0
	call	DWORD PTR __imp__CreateEventA@16
	mov	edx, DWORD PTR _lpMetSect$[ebp]
	mov	DWORD PTR [edx], eax
$LN3@CreateMetS:

; 207  :     }
; 208  :     return(lpMetSect->hEvent ? TRUE : FALSE);

	mov	eax, DWORD PTR _lpMetSect$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN7@CreateMetS
	mov	DWORD PTR tv88[ebp], 1
	jmp	SHORT $LN8@CreateMetS
$LN7@CreateMetS:
	mov	DWORD PTR tv88[ebp], 0
$LN8@CreateMetS:
	mov	eax, DWORD PTR tv88[ebp]

; 209  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_CreateMetSectEvent ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\metersec.c
_TEXT	SEGMENT
_lpMetSect$ = 8						; size = 4
_lInitialCount$ = 12					; size = 4
_lMaximumCount$ = 16					; size = 4
_lpName$ = 20						; size = 4
_bOpenOnly$ = 24					; size = 4
_InitMeteredSection PROC

; 164  : {

	push	ebp
	mov	ebp, esp

; 165  :     // Try to create the event object
; 166  :     if (CreateMetSectEvent(lpMetSect, lpName, bOpenOnly))

	mov	eax, DWORD PTR _bOpenOnly$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMetSect$[ebp]
	push	edx
	call	_CreateMetSectEvent
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN2@InitMetere

; 167  :     {
; 168  :         // Try to create the memory mapped file
; 169  :         if (CreateMetSectFileView(lpMetSect, lInitialCount, lMaximumCount, lpName, bOpenOnly))

	mov	eax, DWORD PTR _bOpenOnly$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lMaximumCount$[ebp]
	push	edx
	mov	eax, DWORD PTR _lInitialCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	push	ecx
	call	_CreateMetSectFileView
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN2@InitMetere

; 170  :         {
; 171  :             return( TRUE );

	mov	eax, 1
	jmp	SHORT $LN1@InitMetere
$LN2@InitMetere:

; 172  :         }
; 173  :     }
; 174  : 
; 175  :     // Error occurred, return FALSE so the caller knows to clean up
; 176  :     return( FALSE );

	xor	eax, eax
$LN1@InitMetere:

; 177  : }

	pop	ebp
	ret	0
_InitMeteredSection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\metersec.c
_TEXT	SEGMENT
_lpMetSect$ = 8						; size = 4
_CloseMeteredSection PROC

; 148  : {

	push	ebp
	mov	ebp, esp

; 149  :     if (lpMetSect)

	cmp	DWORD PTR _lpMetSect$[ebp], 0
	je	SHORT $LN1@CloseMeter

; 150  :     {
; 151  :         // Clean up
; 152  :         if (lpMetSect->lpSharedInfo) UnmapViewOfFile(lpMetSect->lpSharedInfo);

	mov	eax, DWORD PTR _lpMetSect$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@CloseMeter
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	call	DWORD PTR __imp__UnmapViewOfFile@4
$LN3@CloseMeter:

; 153  :         if (lpMetSect->hFileMap) CloseHandle(lpMetSect->hFileMap);

	mov	eax, DWORD PTR _lpMetSect$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN4@CloseMeter
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
$LN4@CloseMeter:

; 154  :         if (lpMetSect->hEvent) CloseHandle(lpMetSect->hEvent);

	mov	eax, DWORD PTR _lpMetSect$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@CloseMeter
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
$LN5@CloseMeter:

; 155  :         free(lpMetSect);

	mov	eax, DWORD PTR _lpMetSect$[ebp]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4
$LN1@CloseMeter:

; 156  :     }
; 157  : }

	pop	ebp
	ret	0
_CloseMeteredSection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\metersec.c
_TEXT	SEGMENT
tv87 = -8						; size = 4
_iCount$ = -4						; size = 4
_lpMetSect$ = 8						; size = 4
_lReleaseCount$ = 12					; size = 4
_lpPreviousCount$ = 16					; size = 4
_LeaveMeteredSection PROC

; 109  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 110  :     int iCount;
; 111  :     GetMeteredSectionLock(lpMetSect);

	mov	eax, DWORD PTR _lpMetSect$[ebp]
	push	eax
	call	_GetMeteredSectionLock
	add	esp, 4

; 112  : 
; 113  :     // Save the old value if they want it
; 114  :     if (lpPreviousCount)

	cmp	DWORD PTR _lpPreviousCount$[ebp], 0
	je	SHORT $LN5@LeaveMeter

; 115  :     {
; 116  :         *lpPreviousCount = lpMetSect->lpSharedInfo->lAvailableCount;

	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _lpPreviousCount$[ebp]
	mov	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax], ecx
$LN5@LeaveMeter:

; 117  :     }
; 118  : 
; 119  :     // We have access to the metered section, everything we do now will be atomic
; 120  :     if ((lReleaseCount < 0) ||

	cmp	DWORD PTR _lReleaseCount$[ebp], 0
	jl	SHORT $LN7@LeaveMeter
	mov	edx, DWORD PTR _lpMetSect$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _lReleaseCount$[ebp]
	mov	edx, DWORD PTR _lpMetSect$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	ecx, DWORD PTR [eax+16]
	jle	SHORT $LN6@LeaveMeter
$LN7@LeaveMeter:

; 121  :         (lpMetSect->lpSharedInfo->lAvailableCount+lReleaseCount >
; 122  :          lpMetSect->lpSharedInfo->lMaximumCount))
; 123  :     {
; 124  :         ReleaseMeteredSectionLock(lpMetSect);

	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	push	ecx
	call	_ReleaseMeteredSectionLock
	add	esp, 4

; 125  :         SetLastError(ERROR_INVALID_PARAMETER);

	push	87					; 00000057H
	call	DWORD PTR __imp__SetLastError@4

; 126  :         return( FALSE );

	xor	eax, eax
	jmp	$LN1@LeaveMeter
$LN6@LeaveMeter:

; 127  :     }
; 128  :     lpMetSect->lpSharedInfo->lAvailableCount += lReleaseCount;

	mov	edx, DWORD PTR _lpMetSect$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+12]
	add	ecx, DWORD PTR _lReleaseCount$[ebp]
	mov	edx, DWORD PTR _lpMetSect$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+12], ecx

; 129  : 
; 130  :     // Set the event the appropriate number of times
; 131  :     lReleaseCount = min(lReleaseCount,lpMetSect->lpSharedInfo->lThreadsWaiting);

	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR _lReleaseCount$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jge	SHORT $LN10@LeaveMeter
	mov	ecx, DWORD PTR _lReleaseCount$[ebp]
	mov	DWORD PTR tv87[ebp], ecx
	jmp	SHORT $LN11@LeaveMeter
$LN10@LeaveMeter:
	mov	edx, DWORD PTR _lpMetSect$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv87[ebp], ecx
$LN11@LeaveMeter:
	mov	edx, DWORD PTR tv87[ebp]
	mov	DWORD PTR _lReleaseCount$[ebp], edx

; 132  :     if (lpMetSect->lpSharedInfo->lThreadsWaiting)

	mov	eax, DWORD PTR _lpMetSect$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	cmp	DWORD PTR [ecx+8], 0
	je	SHORT $LN8@LeaveMeter

; 133  :     {
; 134  :         for (iCount=0; iCount < lReleaseCount ; iCount++)

	mov	DWORD PTR _iCount$[ebp], 0
	jmp	SHORT $LN4@LeaveMeter
$LN2@LeaveMeter:
	mov	edx, DWORD PTR _iCount$[ebp]
	add	edx, 1
	mov	DWORD PTR _iCount$[ebp], edx
$LN4@LeaveMeter:
	mov	eax, DWORD PTR _iCount$[ebp]
	cmp	eax, DWORD PTR _lReleaseCount$[ebp]
	jge	SHORT $LN8@LeaveMeter

; 135  :         {
; 136  :             lpMetSect->lpSharedInfo->lThreadsWaiting--;

	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax

; 137  :             SetEvent(lpMetSect->hEvent);

	mov	eax, DWORD PTR _lpMetSect$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__SetEvent@4

; 138  :         }

	jmp	SHORT $LN2@LeaveMeter
$LN8@LeaveMeter:

; 139  :     }
; 140  :     ReleaseMeteredSectionLock(lpMetSect);

	mov	edx, DWORD PTR _lpMetSect$[ebp]
	push	edx
	call	_ReleaseMeteredSectionLock
	add	esp, 4

; 141  :     return( TRUE );

	mov	eax, 1
$LN1@LeaveMeter:

; 142  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_LeaveMeteredSection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\metersec.c
_TEXT	SEGMENT
_lpMetSect$ = 8						; size = 4
_dwMilliseconds$ = 12					; size = 4
_EnterMeteredSection PROC

; 81   : {

	push	ebp
	mov	ebp, esp
$LN2@EnterMeter:

; 82   :     while (TRUE)

	mov	eax, 1
	test	eax, eax
	je	$LN1@EnterMeter

; 83   :     {
; 84   :         GetMeteredSectionLock(lpMetSect);

	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	push	ecx
	call	_GetMeteredSectionLock
	add	esp, 4

; 85   : 
; 86   :         // We have access to the metered section, everything we do now will be atomic
; 87   :         if (lpMetSect->lpSharedInfo->lAvailableCount >= 1)

	mov	edx, DWORD PTR _lpMetSect$[ebp]
	mov	eax, DWORD PTR [edx+8]
	cmp	DWORD PTR [eax+12], 1
	jl	SHORT $LN4@EnterMeter

; 88   :         {
; 89   :             lpMetSect->lpSharedInfo->lAvailableCount--;

	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+12]
	sub	eax, 1
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+12], eax

; 90   :             ReleaseMeteredSectionLock(lpMetSect);

	mov	eax, DWORD PTR _lpMetSect$[ebp]
	push	eax
	call	_ReleaseMeteredSectionLock
	add	esp, 4

; 91   :             return WAIT_OBJECT_0;

	xor	eax, eax
	jmp	SHORT $LN1@EnterMeter
$LN4@EnterMeter:

; 92   :         }
; 93   : 
; 94   :         // Couldn't get in.  Wait on the event object
; 95   :         lpMetSect->lpSharedInfo->lThreadsWaiting++;

	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+8]
	add	eax, 1
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax

; 96   :         ResetEvent(lpMetSect->hEvent);

	mov	eax, DWORD PTR _lpMetSect$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	DWORD PTR __imp__ResetEvent@4

; 97   :         ReleaseMeteredSectionLock(lpMetSect);

	mov	edx, DWORD PTR _lpMetSect$[ebp]
	push	edx
	call	_ReleaseMeteredSectionLock
	add	esp, 4

; 98   :         if (WaitForSingleObject(lpMetSect->hEvent, dwMilliseconds) == WAIT_TIMEOUT)

	mov	eax, DWORD PTR _dwMilliseconds$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8
	cmp	eax, 258				; 00000102H
	jne	SHORT $LN5@EnterMeter

; 99   :         {
; 100  :             return WAIT_TIMEOUT;

	mov	eax, 258				; 00000102H
	jmp	SHORT $LN1@EnterMeter
$LN5@EnterMeter:

; 101  :         }
; 102  :     }

	jmp	$LN2@EnterMeter
$LN1@EnterMeter:

; 103  : }

	pop	ebp
	ret	0
_EnterMeteredSection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\metersec.c
_TEXT	SEGMENT
_lpMetSect$ = -4					; size = 4
_lpName$ = 8						; size = 4
_OpenMeteredSection PROC

; 55   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 56   :     LPMETERED_SECTION lpMetSect = NULL;

	mov	DWORD PTR _lpMetSect$[ebp], 0

; 57   : 
; 58   :     if (lpName)

	cmp	DWORD PTR _lpName$[ebp], 0
	je	SHORT $LN2@OpenMetere

; 59   :     {
; 60   :         lpMetSect = (LPMETERED_SECTION)malloc(sizeof(METERED_SECTION));

	push	12					; 0000000cH
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _lpMetSect$[ebp], eax

; 61   : 
; 62   :         // If the memory for the metered section was allocated okay
; 63   :         if (lpMetSect)

	cmp	DWORD PTR _lpMetSect$[ebp], 0
	je	SHORT $LN2@OpenMetere

; 64   :         {
; 65   :             if (!InitMeteredSection(lpMetSect, 0, 0, lpName, TRUE))

	push	1
	mov	eax, DWORD PTR _lpName$[ebp]
	push	eax
	push	0
	push	0
	mov	ecx, DWORD PTR _lpMetSect$[ebp]
	push	ecx
	call	_InitMeteredSection
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN2@OpenMetere

; 66   :             {
; 67   :                 // Metered section failed to initialize
; 68   :                 CloseMeteredSection(lpMetSect);

	mov	edx, DWORD PTR _lpMetSect$[ebp]
	push	edx
	call	_CloseMeteredSection
	add	esp, 4

; 69   :                 lpMetSect = NULL;

	mov	DWORD PTR _lpMetSect$[ebp], 0
$LN2@OpenMetere:

; 70   :             }
; 71   :         }
; 72   :     }
; 73   :     return lpMetSect;

	mov	eax, DWORD PTR _lpMetSect$[ebp]

; 74   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_OpenMeteredSection ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\metersec.c
_TEXT	SEGMENT
_lpMetSect$ = -4					; size = 4
_lInitialCount$ = 8					; size = 4
_lMaximumCount$ = 12					; size = 4
_lpName$ = 16						; size = 4
_CreateMeteredSection PROC

; 22   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 23   :     LPMETERED_SECTION lpMetSect;
; 24   : 
; 25   :     // Verify the parameters
; 26   :     if ((lMaximumCount < 1)             ||
; 27   :         (lInitialCount > lMaximumCount) ||
; 28   :         (lInitialCount < 0)             ||

	cmp	DWORD PTR _lMaximumCount$[ebp], 1
	jl	SHORT $LN3@CreateMete
	mov	eax, DWORD PTR _lInitialCount$[ebp]
	cmp	eax, DWORD PTR _lMaximumCount$[ebp]
	jg	SHORT $LN3@CreateMete
	cmp	DWORD PTR _lInitialCount$[ebp], 0
	jl	SHORT $LN3@CreateMete
	cmp	DWORD PTR _lpName$[ebp], 0
	je	SHORT $LN2@CreateMete
	mov	ecx, DWORD PTR _lpName$[ebp]
	push	ecx
	call	_strlen
	add	esp, 4
	cmp	eax, 128				; 00000080H
	jbe	SHORT $LN2@CreateMete
$LN3@CreateMete:

; 29   :         ((lpName) && (_tcslen(lpName) > MAX_METSECT_NAMELEN)))
; 30   :     {
; 31   :         SetLastError(ERROR_INVALID_PARAMETER);

	push	87					; 00000057H
	call	DWORD PTR __imp__SetLastError@4

; 32   :         return NULL;

	xor	eax, eax
	jmp	SHORT $LN1@CreateMete
$LN2@CreateMete:

; 33   :     }
; 34   : 
; 35   :     // Allocate memory for the metered section
; 36   :     lpMetSect = (LPMETERED_SECTION)malloc(sizeof(METERED_SECTION));

	push	12					; 0000000cH
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _lpMetSect$[ebp], eax

; 37   : 
; 38   :     // If the memory for the metered section was allocated okay, initialize it
; 39   :     if (lpMetSect)

	cmp	DWORD PTR _lpMetSect$[ebp], 0
	je	SHORT $LN4@CreateMete

; 40   :     {
; 41   :         if (!InitMeteredSection(lpMetSect, lInitialCount, lMaximumCount, lpName, FALSE))

	push	0
	mov	edx, DWORD PTR _lpName$[ebp]
	push	edx
	mov	eax, DWORD PTR _lMaximumCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lInitialCount$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpMetSect$[ebp]
	push	edx
	call	_InitMeteredSection
	add	esp, 20					; 00000014H
	test	eax, eax
	jne	SHORT $LN4@CreateMete

; 42   :         {
; 43   :             CloseMeteredSection(lpMetSect);

	mov	eax, DWORD PTR _lpMetSect$[ebp]
	push	eax
	call	_CloseMeteredSection
	add	esp, 4

; 44   :             lpMetSect = NULL;

	mov	DWORD PTR _lpMetSect$[ebp], 0
$LN4@CreateMete:

; 45   :         }
; 46   :     }
; 47   :     return lpMetSect;

	mov	eax, DWORD PTR _lpMetSect$[ebp]
$LN1@CreateMete:

; 48   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_CreateMeteredSection ENDP
_TEXT	ENDS
END
