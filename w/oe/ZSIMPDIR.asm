; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\A\oe\ZSIMPDIR.C
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG12851 DB	'Zeidon DBHandler Work Object', 00H
	ORG $+3
$SG12852 DB	'Zeidon DBH', 00H
	ORG $+1
$SG12854 DB	'ApplServ', 00H
	ORG $+3
$SG12855 DB	'Name', 00H
	ORG $+3
$SG12856 DB	'Group', 00H
	ORG $+2
$SG12857 DB	'Group', 00H
	ORG $+2
$SG12858 DB	'ApplServ', 00H
	ORG $+3
$SG12859 DB	'Name', 00H
	ORG $+3
$SG12860 DB	'Group', 00H
	ORG $+2
$SG12868 DB	'Key', 00H
$SG12861 DB	'Set from zSimpDir.DLL to determine the address of the ap'
	DB	'plication server.', 00H
	ORG $+2
$SG12862 DB	'Desc', 00H
	ORG $+3
$SG12863 DB	'Group', 00H
	ORG $+2
$SG12866 DB	'ServerAddress', 00H
	ORG $+2
$SG12867 DB	'Name', 00H
	ORG $+3
$SG12869 DB	'Key', 00H
$SG12870 DB	'ServerAddress', 00H
	ORG $+2
$SG12871 DB	'Name', 00H
	ORG $+3
$SG12872 DB	'Key', 00H
$SG12873 DB	'Current address of the appl server', 00H
	ORG $+1
$SG12874 DB	'Desc', 00H
	ORG $+3
$SG12875 DB	'Key', 00H
$SG12876 DB	'[%s]', 00H
	ORG $+3
$SG12877 DB	'ApplServer', 00H
	ORG $+1
$SG12878 DB	'Value', 00H
	ORG $+2
$SG12879 DB	'Key', 00H
$SG12880 DB	'Value', 00H
	ORG $+2
$SG12881 DB	'Key', 00H
$SG12882 DB	'Zeidon DBH', 00H
_DATA	ENDS
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	_zServerDirInit@16
PUBLIC	_zServerDirClose@12
PUBLIC	_zServerDirGetAddr@20
EXTRN	_strcpy:PROC
EXTRN	_GetViewByName@16:PROC
EXTRN	_CreateEntity@12:PROC
EXTRN	_SetCursorFirstEntityByString@20:PROC
EXTRN	_GetStringFromAttribute@16:PROC
EXTRN	_SetAttributeFromString@16:PROC
EXTRN	_SysMutexLock@16:PROC
EXTRN	_SysMutexUnlock@12:PROC
EXTRN	_SysGetPointerFromHandle@4:PROC
EXTRN	_SysReadZeidonIni@16:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__chkstk:PROC
EXTRN	___security_cookie:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\zsimpdir.c
_TEXT	SEGMENT
_vTask$ = -4112						; size = 4
_lpBaseInfo$ = -4108					; size = 4
_vOI$ = -4104						; size = 4
_szGroup$1 = -4100					; size = 4096
__$ArrayPad$ = -4					; size = 4
_lpTask$ = 8						; size = 4
_pchReturnAddress$ = 12					; size = 4
_pvData$ = 16						; size = 4
_lRequest$ = 20						; size = 4
_pvInfoStruct$ = 24					; size = 4
_zServerDirGetAddr@20 PROC

; 58   : {

	push	ebp
	mov	ebp, esp
	mov	eax, 4112				; 00001010H
	call	__chkstk
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 59   :    LPSERVDIRBASE lpBaseInfo = (LPSERVDIRBASE) pvInfoStruct;

	mov	eax, DWORD PTR _pvInfoStruct$[ebp]
	mov	DWORD PTR _lpBaseInfo$[ebp], eax

; 60   :    zVIEW         vTask;
; 61   :    zVIEW         vOI;
; 62   : 
; 63   :    // We'll only allow one attempt to the server, so if the RETRY flag is
; 64   :    // set, we'll return an error.
; 65   :    if ( lRequest & zAPPLREQ_RETRY )

	mov	ecx, DWORD PTR _lRequest$[ebp]
	and	ecx, 65536				; 00010000H
	je	SHORT $LN2@zServerDir

; 66   :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@zServerDir
$LN2@zServerDir:

; 67   : 
; 68   :    // If the user supplied an address, we can just use that address.
; 69   :    if ( lpBaseInfo->pszUserSuppliedAddress &&

	mov	edx, DWORD PTR _lpBaseInfo$[ebp]
	cmp	DWORD PTR [edx+4], 0
	je	SHORT $LN3@zServerDir
	mov	eax, 1
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _lpBaseInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	movsx	ecx, BYTE PTR [eax+ecx]
	test	ecx, ecx
	je	SHORT $LN3@zServerDir

; 70   :         lpBaseInfo->pszUserSuppliedAddress[ 0 ] )
; 71   :    {
; 72   :       zstrcpy( pchReturnAddress, lpBaseInfo->pszUserSuppliedAddress );

	mov	edx, DWORD PTR _lpBaseInfo$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pchReturnAddress$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 73   :       return( 0 );

	xor	eax, eax
	jmp	$LN1@zServerDir
$LN3@zServerDir:

; 74   :    }
; 75   : 
; 76   :    // Set lock so nobody can modify the OI while we're using it.
; 77   :    vTask = SysGetPointerFromHandle( lpTask->hFirstView );

	mov	edx, DWORD PTR _lpTask$[ebp]
	mov	eax, DWORD PTR [edx+106]
	push	eax
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _vTask$[ebp], eax

; 78   :    GetViewByName( &vOI, "Zeidon DBHandler Work Object", vTask, zLEVEL_SYSTEM );

	push	8
	mov	ecx, DWORD PTR _vTask$[ebp]
	push	ecx
	push	OFFSET $SG12851
	lea	edx, DWORD PTR _vOI$[ebp]
	push	edx
	call	_GetViewByName@16

; 79   :    SysMutexLock( vTask, "Zeidon DBH", 0, 0 );

	push	0
	push	0
	push	OFFSET $SG12852
	mov	eax, DWORD PTR _vTask$[ebp]
	push	eax
	call	_SysMutexLock@16

; 80   : 
; 81   :    // Have we already created the Group for ApplServ?
; 82   :    if ( SetCursorFirstEntityByString( vOI, "Group", "Name",
; 83   :                                       "ApplServ", 0 ) < zCURSOR_SET )

	push	0
	push	OFFSET $SG12854
	push	OFFSET $SG12855
	push	OFFSET $SG12856
	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByString@20
	movsx	edx, ax
	test	edx, edx
	jge	SHORT $LN4@zServerDir

; 84   :    {
; 85   :       // No...create it.
; 86   :       CreateEntity( vOI, "Group", zPOS_LAST );

	push	2
	push	OFFSET $SG12857
	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	_CreateEntity@12

; 87   :       SetAttributeFromString( vOI, "Group", "Name", "ApplServ" );

	push	OFFSET $SG12858
	push	OFFSET $SG12859
	push	OFFSET $SG12860
	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 88   :       SetAttributeFromString( vOI, "Group", "Desc",

	push	OFFSET $SG12861
	push	OFFSET $SG12862
	push	OFFSET $SG12863
	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	call	_SetAttributeFromString@16
$LN4@zServerDir:

; 89   :                               "Set from zSimpDir.DLL to determine the address "
; 90   :                               "of the application server." );
; 91   :    }
; 92   : 
; 93   :    // Have we already created the key name for the server address?
; 94   :    if ( SetCursorFirstEntityByString( vOI, "Key", "Name",
; 95   :                                       "ServerAddress", 0 ) < zCURSOR_SET )

	push	0
	push	OFFSET $SG12866
	push	OFFSET $SG12867
	push	OFFSET $SG12868
	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	movsx	ecx, ax
	test	ecx, ecx
	jge	$LN5@zServerDir

; 96   :    {
; 97   :       zCHAR szGroup[ 4096 ];
; 98   : 
; 99   :       // No...create it and retrieve the original value from the INI file.
; 100  :       CreateEntity( vOI, "Key", zPOS_LAST );

	push	2
	push	OFFSET $SG12869
	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	call	_CreateEntity@12

; 101  :       SetAttributeFromString( vOI, "Key", "Name", "ServerAddress" );

	push	OFFSET $SG12870
	push	OFFSET $SG12871
	push	OFFSET $SG12872
	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 102  :       SetAttributeFromString( vOI, "Key", "Desc",

	push	OFFSET $SG12873
	push	OFFSET $SG12874
	push	OFFSET $SG12875
	mov	ecx, DWORD PTR _vOI$[ebp]
	push	ecx
	call	_SetAttributeFromString@16

; 103  :                               "Current address of the appl server" );
; 104  : 
; 105  :       // Read the address from the zeidon ini.
; 106  :       zsprintf( szGroup, "[%s]", lpBaseInfo->pszNetworkName );

	mov	edx, DWORD PTR _lpBaseInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET $SG12876
	lea	ecx, DWORD PTR _szGroup$1[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 107  :       SysReadZeidonIni( -1, szGroup, "ApplServer", pchReturnAddress );

	mov	edx, DWORD PTR _pchReturnAddress$[ebp]
	push	edx
	push	OFFSET $SG12877
	lea	eax, DWORD PTR _szGroup$1[ebp]
	push	eax
	push	-1
	call	_SysReadZeidonIni@16

; 108  :       SetAttributeFromString( vOI, "Key", "Value", pchReturnAddress );

	mov	ecx, DWORD PTR _pchReturnAddress$[ebp]
	push	ecx
	push	OFFSET $SG12878
	push	OFFSET $SG12879
	mov	edx, DWORD PTR _vOI$[ebp]
	push	edx
	call	_SetAttributeFromString@16

; 109  :    }

	jmp	SHORT $LN6@zServerDir
$LN5@zServerDir:

; 110  :    else
; 111  :       GetStringFromAttribute( pchReturnAddress, vOI, "Key", "Value" );

	push	OFFSET $SG12880
	push	OFFSET $SG12881
	mov	eax, DWORD PTR _vOI$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchReturnAddress$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16
$LN6@zServerDir:

; 112  : 
; 113  :    SysMutexUnlock( vTask, "Zeidon DBH", 0 );

	push	0
	push	OFFSET $SG12882
	mov	edx, DWORD PTR _vTask$[ebp]
	push	edx
	call	_SysMutexUnlock@12

; 114  : 
; 115  :    return( 0 );

	xor	eax, eax
$LN1@zServerDir:

; 116  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_zServerDirGetAddr@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\zsimpdir.c
_TEXT	SEGMENT
_lpTask$ = 8						; size = 4
_pvData$ = 12						; size = 4
_lControl$ = 16						; size = 4
_zServerDirClose@12 PROC

; 46   : {

	push	ebp
	mov	ebp, esp

; 47   :    // No close to do.
; 48   :    return( 0 );

	xor	eax, eax

; 49   : }

	pop	ebp
	ret	12					; 0000000cH
_zServerDirClose@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\a\oe\zsimpdir.c
_TEXT	SEGMENT
_lpTask$ = 8						; size = 4
_pchNetworkName$ = 12					; size = 4
_pvData$ = 16						; size = 4
_lControl$ = 20						; size = 4
_zServerDirInit@16 PROC

; 35   : {

	push	ebp
	mov	ebp, esp

; 36   :    // No init to do.
; 37   :    *pvData = 0;

	mov	eax, DWORD PTR _pvData$[ebp]
	mov	DWORD PTR [eax], 0

; 38   : 
; 39   :    return( 0 );

	xor	eax, eax

; 40   : }

	pop	ebp
	ret	16					; 00000010H
_zServerDirInit@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
END
