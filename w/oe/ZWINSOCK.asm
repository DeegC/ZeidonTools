; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24213.1 

	TITLE	c:\10c\w\oe\ZWINSOCK.CPP
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?szlErrorTitle@@3PADA				; szlErrorTitle
PUBLIC	?g_hListenThread@@3KA				; g_hListenThread
PUBLIC	?g_dwListenThreadID@@3IA			; g_dwListenThreadID
PUBLIC	?g_bListenThreadStarted@@3EA			; g_bListenThreadStarted
PUBLIC	?g_bClosingListenSocket@@3EA			; g_bClosingListenSocket
PUBLIC	_g_nApplPort
PUBLIC	_g_nListenPort
_BSS	SEGMENT
?g_hListenThread@@3KA DD 01H DUP (?)			; g_hListenThread
?g_dwListenThreadID@@3IA DD 01H DUP (?)			; g_dwListenThreadID
?g_bListenThreadStarted@@3EA DB 01H DUP (?)		; g_bListenThreadStarted
	ALIGN	4

?g_bClosingListenSocket@@3EA DB 01H DUP (?)		; g_bClosingListenSocket
_BSS	ENDS
_DATA	SEGMENT
?szlErrorTitle@@3PADA DB 'zWinSock Error', 00H		; szlErrorTitle
	ORG $+1
_g_nApplPort DW	0ffffH
	ORG $+2
_g_nListenPort DW 0ffffH
_DATA	ENDS
CONST	SEGMENT
$SG120834 DB	'File', 00H
$SG120928 DB	00H
$SG120976 DB	00H
$SG120315 DB	00H
$SG120835 DB	'FileName', 00H
$SG120350 DB	00H
$SG120361 DB	00H
$SG120367 DB	00H
$SG120836 DB	'File', 00H
$SG120398 DB	00H
$SG120406 DB	00H
$SG120411 DB	00H
$SG120837 DB	'%d%02d%02d%02d%02d%02d%d', 00H
$SG120426 DB	00H
$SG120521 DB	00H
$SG120674 DB	00H
$SG120838 DB	'ModDate', 00H
$SG120839 DB	'File', 00H
$SG120677 DB	00H
$SG120713 DB	00H
$SG120716 DB	00H
$SG120840 DB	'FileSize', 00H
$SG120719 DB	00H
$SG120725 DB	00H
$SG120749 DB	00H
$SG120841 DB	'File', 00H
$SG120802 DB	00H
	ORG $+2
$SG120842 DB	'FileName', 00H
	ORG $+3
$SG120843 DB	'File', 00H
	ORG $+3
$SG120869 DB	'ZEIDON', 00H
	ORG $+1
$SG120870 DB	'ZEIDON.APP', 00H
	ORG $+1
$SG120871 DB	'KZAPPLOO', 00H
	ORG $+3
$SG120873 DB	'ApplicationName', 00H
$SG120874 DB	'KZFXFERO', 00H
	ORG $+3
$SG120875 DB	'APP_NAME', 00H
	ORG $+3
$SG120876 DB	'APPLICATION', 00H
$SG120877 DB	'Error: Couldn''t find application', 00H
	ORG $+3
$SG120878 DB	'Application Update Error', 00H
	ORG $+3
$SG120879 DB	'APP_NAME', 00H
	ORG $+3
$SG120880 DB	'APPLICATION', 00H
$SG120882 DB	'MaxTotalFileSize', 00H
	ORG $+3
$SG120885 DB	'Performing Application Update for app: ', 00H
$SG120886 DB	'_ExecutableSourceList', 00H
	ORG $+2
$SG120888 DB	'APP_ADOBIN', 00H
	ORG $+1
$SG120889 DB	'APPLICATION', 00H
$SG120890 DB	'File', 00H
	ORG $+3
$SG120891 DB	'File', 00H
	ORG $+3
$SG120894 DB	'FileName', 00H
	ORG $+3
$SG120895 DB	'File', 00H
	ORG $+3
$SG120896 DB	'FileName', 00H
	ORG $+3
$SG120897 DB	'File', 00H
	ORG $+3
$SG120901 DB	'File', 00H
	ORG $+3
$SG120902 DB	'File', 00H
	ORG $+3
$SG120903 DB	'File', 00H
	ORG $+3
$SG120904 DB	'File', 00H
	ORG $+3
$SG120906 DB	'ModDate', 00H
$SG120907 DB	'File', 00H
	ORG $+3
$SG120908 DB	'ModDate', 00H
$SG120909 DB	'File', 00H
	ORG $+3
$SG120910 DB	'File', 00H
	ORG $+3
$SG120911 DB	'File', 00H
	ORG $+3
$SG120912 DB	'FileName', 00H
	ORG $+3
$SG120913 DB	'File', 00H
	ORG $+3
$SG120914 DB	'Y', 00H
	ORG $+2
$SG120915 DB	'Updated', 00H
$SG120916 DB	'File', 00H
	ORG $+3
$SG120917 DB	'ModDate', 00H
$SG120918 DB	'File', 00H
	ORG $+3
$SG120919 DB	'ModDate', 00H
$SG120920 DB	'File', 00H
	ORG $+3
$SG120921 DB	'Data', 00H
	ORG $+3
$SG120922 DB	'File', 00H
	ORG $+3
$SG120923 DB	'FileSize', 00H
	ORG $+3
$SG120924 DB	'File', 00H
	ORG $+3
$SG120926 DB	'File', 00H
	ORG $+3
$SG120927 DB	'File', 00H
	ORG $+3
$SG120929 DB	'Updated', 00H
$SG120930 DB	'File', 00H
	ORG $+3
$SG120931 DB	'File', 00H
	ORG $+3
$SG120937 DB	'ReturnValue', 00H
$SG120938 DB	'Operation', 00H
	ORG $+2
$SG120960 DB	'ZEIDON', 00H
	ORG $+1
$SG120961 DB	'ZEIDON.APP', 00H
	ORG $+1
$SG120962 DB	'KZAPPLOO', 00H
	ORG $+3
$SG120963 DB	'APPLICATION', 00H
$SG120964 DB	'APPLICATION', 00H
$SG120965 DB	'APP_NAME', 00H
	ORG $+3
$SG120966 DB	'APPLICATION', 00H
$SG120967 DB	'SourceServer', 00H
	ORG $+3
$SG120969 DB	'Performing application update for app: ', 00H
$SG120970 DB	'NpV', 00H
$SG120971 DB	'CompareFiles', 00H
	ORG $+3
$SG120972 DB	'zWinSock', 00H
	ORG $+3
$SG120973 DB	'zWinSock', 00H
	ORG $+3
$SG120974 DB	'APP_ADOBIN', 00H
	ORG $+1
$SG120975 DB	'APPLICATION', 00H
$SG120977 DB	'===== Files that being downloaded are: ======', 00H
	ORG $+2
$SG120978 DB	'File', 00H
	ORG $+3
$SG120979 DB	'File', 00H
	ORG $+3
$SG120980 DB	'FileName', 00H
	ORG $+3
$SG120981 DB	'File', 00H
	ORG $+3
$SG120982 DB	'FileName: ', 00H
	ORG $+1
$SG120983 DB	'Data', 00H
	ORG $+3
$SG120984 DB	'File', 00H
	ORG $+3
$SG120985 DB	'ModDate', 00H
$SG120986 DB	'File', 00H
	ORG $+3
$SG120264 DB	'WSAEINTR', 00H
	ORG $+3
$SG120265 DB	'WSAEBADF', 00H
	ORG $+3
$SG120266 DB	'WSAEACCES', 00H
	ORG $+2
$SG120267 DB	'WSAEFAULT', 00H
	ORG $+2
$SG120268 DB	'WSAEINVAL', 00H
	ORG $+2
$SG120269 DB	'WSAEMFILE', 00H
	ORG $+2
$SG120270 DB	'WSAEWOULDBLOCK', 00H
	ORG $+1
$SG120271 DB	'WSAEINPROGRESS', 00H
	ORG $+1
$SG120272 DB	'WSAEALREADY', 00H
$SG120273 DB	'WSAENOTSOCK', 00H
$SG120274 DB	'WSAEDESTADDRREQ', 00H
$SG120275 DB	'WSAEMSGSIZE', 00H
$SG120276 DB	'WSAEPROTOTYPE', 00H
	ORG $+2
$SG120277 DB	'WSAENOPROTOOPT', 00H
	ORG $+1
$SG120278 DB	'WSAEPROTONOSUPPORT', 00H
	ORG $+1
$SG120279 DB	'WSAESOCKTNOSUPPORT', 00H
	ORG $+1
$SG120280 DB	'WSAEOPNOTSUPP', 00H
	ORG $+2
$SG120281 DB	'WSAEPFNOSUPPORT', 00H
$SG120282 DB	'WSAEAFNOSUPPORT', 00H
$SG120283 DB	'WSAEADDRINUSE', 00H
	ORG $+2
$SG120284 DB	'WSAEADDRNOTAVAIL', 00H
	ORG $+3
$SG120285 DB	'WSAENETDOWN', 00H
$SG120286 DB	'WSAENETUNREACH', 00H
	ORG $+1
$SG120287 DB	'WSAENETRESET', 00H
	ORG $+3
$SG120288 DB	'WSAECONNABORTED', 00H
$SG120289 DB	'WSAECONNRESET', 00H
	ORG $+2
$SG120290 DB	'WSAENOBUFS', 00H
	ORG $+1
$SG120291 DB	'WSAEISCONN', 00H
	ORG $+1
$SG120292 DB	'WSAENOTCONN', 00H
$SG120293 DB	'WSAESHUTDOWN', 00H
	ORG $+3
$SG120294 DB	'WSAETOOMANYREFS', 00H
$SG120295 DB	'WSAETIMEDOUT', 00H
	ORG $+3
$SG120296 DB	'WSAECONNREFUSED', 00H
$SG120297 DB	'WSAELOOP', 00H
	ORG $+3
$SG120298 DB	'WSAENAMETOOLONG', 00H
$SG120299 DB	'WSAEHOSTDOWN', 00H
	ORG $+3
$SG120300 DB	'WSAEHOSTUNREACH', 00H
$SG120301 DB	'WSAENOTEMPTY', 00H
	ORG $+3
$SG120302 DB	'WSAEPROCLIM', 00H
$SG120303 DB	'WSAEUSERS', 00H
	ORG $+2
$SG120304 DB	'WSAEDQUOT', 00H
	ORG $+2
$SG120305 DB	'WSAESTALE', 00H
	ORG $+2
$SG120306 DB	'WSAEREMOTE', 00H
	ORG $+1
$SG120307 DB	'WSASYSNOTREADY', 00H
	ORG $+1
$SG120308 DB	'WSAVERNOTSUPPORTED', 00H
	ORG $+1
$SG120309 DB	'WSANOTINITIALISED', 00H
	ORG $+2
$SG120313 DB	'(zwinsock) WinSock error Func = %s   %s %d', 00H
	ORG $+1
$SG120314 DB	'(zwinsock) Unknown WinSock error Func = %s   %d', 00H
$SG120339 DB	'(zwinsock) zNetSend -- uLth = ', 00H
	ORG $+1
$SG120342 DB	'(zwinsock) Total bytes received = ', 00H
	ORG $+1
$SG120347 DB	'(zwinsock) Sending buffer of length ', 00H
	ORG $+3
$SG120348 DB	'(zwinsock)', 00H
	ORG $+1
$SG120351 DB	'(zwinsock) send -- Error!', 00H
	ORG $+2
$SG120352 DB	'send', 00H
	ORG $+3
$SG120354 DB	'(zwinsock) Bytes sent for send ', 00H
$SG120358 DB	'(zwinsock) Sending incoming buffer of length ', 00H
	ORG $+2
$SG120359 DB	'(zwinsock)', 00H
	ORG $+1
$SG120362 DB	'(zwinsock) send -- Error!', 00H
	ORG $+2
$SG120363 DB	'send', 00H
	ORG $+3
$SG120365 DB	'(zwinsock) Bytes sent for send ', 00H
$SG120368 DB	'(zwinsock) Adding bytes to send buffer', 00H
	ORG $+1
$SG120395 DB	'(zwinsock) zNetReceive -- uLth = ', 00H
	ORG $+2
$SG120399 DB	'(zwinsock) Flushing send buffer', 00H
$SG120402 DB	'(zwinsock) Total bytes sent = ', 00H
	ORG $+1
$SG120407 DB	'(zwinsock) Trying to consolidate receive buffer', 00H
$SG120412 DB	'(zwinsock) Allocating bigger buffer', 00H
$SG120414 DB	'Out of memory', 00H
	ORG $+2
$SG120417 DB	'recv', 00H
	ORG $+3
$SG120418 DB	'(zwinsock) Error trying to extend buffer.  RC = ', 00H
	ORG $+3
$SG120420 DB	'(zwinsock) Bytes read = ', 00H
	ORG $+3
$SG120422 DB	'(zwinsock) Tracing buffer ... ', 00H
	ORG $+1
$SG120423 DB	'(zwinsock)', 00H
	ORG $+1
$SG120427 DB	'(zwinsock) Buffer still doens''t have enough data', 00H
	ORG $+3
$SG120485 DB	'Out of memory', 00H
	ORG $+2
$SG120490 DB	'ApplPort', 00H
	ORG $+3
$SG120491 DB	'[zWinSock]', 00H
	ORG $+1
$SG120493 DB	'Out of memory', 00H
	ORG $+2
$SG120496 DB	'socket', 00H
	ORG $+1
$SG120497 DB	'socket() failed', 00H
$SG120500 DB	'ioctlsocket', 00H
$SG120501 DB	'ioctlsocket() failed', 00H
	ORG $+3
$SG120504 DB	'%s took %lf seconds.', 00H
	ORG $+3
$SG120505 DB	'(zWinSock) WARNING gethostbyname() for ', 00H
$SG120507 DB	'gethostbyname', 00H
	ORG $+2
$SG120514 DB	'(zWinSock) WARNING connect() for ', 00H
	ORG $+2
$SG120508 DB	'Couldn''t resolve network address ''%s''.  Make sure the'
	DB	' server address is correct and that the Zeidon Server is runn'
	DB	'ing.', 00H
	ORG $+1
$SG120513 DB	'%s took %lf seconds.', 00H
	ORG $+3
$SG120515 DB	'connect', 00H
$SG120516 DB	'Connection to server ''%s'' failed.  Make sure the serve'
	DB	'r address is correct and that the server is running the Zeido'
	DB	'n Object Engine.', 00H
$SG120519 DB	'zWinSock', 00H
	ORG $+3
$SG120522 DB	'(zwinsock) Connection to server made!', 00H
	ORG $+2
$SG120524 DB	'Out of memory', 00H
	ORG $+2
$SG120547 DB	'(zwinsock) Total bytes sent = ', 00H
	ORG $+1
$SG120549 DB	'(zwinsock) Total bytes received = ', 00H
	ORG $+1
$SG120551 DB	'closesocket', 00H
$SG120609 DB	'SyncServerAccess', 00H
	ORG $+3
$SG120610 DB	'[zWinSock]', 00H
	ORG $+1
$SG120614 DB	'WINSOCK_WORKAROUND', 00H
	ORG $+1
$SG120618 DB	'\\Zeidon System\', 00H
	ORG $+3
$SG120621 DB	'Out of memory', 00H
	ORG $+2
$SG120623 DB	'zWinSock', 00H
	ORG $+3
$SG120625 DB	'(zwinsock) A message has been received from ', 00H
	ORG $+3
$SG120626 DB	'zWinSock', 00H
	ORG $+3
$SG120663 DB	'ListenPort', 00H
	ORG $+1
$SG120664 DB	'[zWinSock]', 00H
	ORG $+1
$SG120666 DB	'socket', 00H
	ORG $+1
$SG120667 DB	'socket() failed', 00H
$SG120669 DB	'bind', 00H
	ORG $+3
$SG120670 DB	'bind() failed', 00H
	ORG $+2
$SG120672 DB	'listen', 00H
	ORG $+1
$SG120673 DB	'listen() failed', 00H
$SG120675 DB	'(zWinSock) Waiting for client connections...', 00H
	ORG $+3
$SG120678 DB	'fnListenThreadProc trying to close ListenSocket', 00H
$SG120681 DB	'accept', 00H
	ORG $+1
$SG120682 DB	'accept(sock) failed for listen', 00H
	ORG $+1
$SG120711 DB	'zWinSock', 00H
	ORG $+3
$SG120714 DB	'(zwinsock) Stopping listen', 00H
	ORG $+1
$SG120717 DB	'(zwinsock) No Listen socket!', 00H
	ORG $+3
$SG120720 DB	'(zwinsock) Error shutting down listen socket', 00H
	ORG $+3
$SG120721 DB	'closesocket', 00H
$SG120723 DB	'NetStopListen wait for socket to finish ... TERMINATED', 00H
	ORG $+1
$SG120726 DB	'(zwinsock) Listen stopped', 00H
	ORG $+2
$SG120747 DB	'zWinSock', 00H
	ORG $+3
$SG120750 DB	'(zwinsock) Getting local host address.', 00H
	ORG $+1
$SG120755 DB	'getpeername', 00H
$SG120756 DB	'getpeername() failed', 00H
	ORG $+3
$SG120758 DB	'gethostbyaddr', 00H
	ORG $+2
$SG120759 DB	'gethostbyaddr() failed', 00H
	ORG $+1
$SG120761 DB	'Out of memory', 00H
	ORG $+2
$SG120763 DB	'(zwinsock) Local host address = ', 00H
	ORG $+3
$SG120783 DB	'Error loading starting WinSock: %d', 00H
	ORG $+1
$SG120784 DB	'(zwinsock) WinSock Version     = ', 00H
	ORG $+2
$SG120785 DB	'(zwinsock) WinSock HighVersion = ', 00H
	ORG $+2
$SG120786 DB	'(zwinsock) WinSock Description = ', 00H
	ORG $+2
$SG120787 DB	'(zwinsock) System status       = ', 00H
	ORG $+2
$SG120788 DB	'(zwinsock) Max sockets         = ', 00H
	ORG $+2
$SG120789 DB	'(zwinsock) Max UPD datagram    = ', 00H
	ORG $+2
$SG120791 DB	'Out of memory starting network ''%s''', 00H
$SG120801 DB	'zWinSock', 00H
	ORG $+3
$SG120803 DB	'(zwinsock) Shutting down network zWinSock', 00H
	ORG $+2
$SG120823 DB	'KZFXFERO', 00H
	ORG $+3
$SG120824 DB	'KZFXFERO', 00H
	ORG $+3
$SG120825 DB	'APP_NAME', 00H
	ORG $+3
$SG120826 DB	'APPLICATION', 00H
$SG120827 DB	'ApplicationName', 00H
$SG120828 DB	'KZFXFERO', 00H
	ORG $+3
$SG120829 DB	'APP_ADOBIN', 00H
	ORG $+1
$SG120830 DB	'APPLICATION', 00H
$SG120831 DB	'*', 00H
CONST	ENDS
PUBLIC	?strchr@@YAPADQADH@Z				; strchr
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	__vsnprintf_l
PUBLIC	__vsprintf_l
PUBLIC	_sprintf
PUBLIC	?fnShowError@@YAXPAD@Z				; fnShowError
PUBLIC	_zNetSend@20
PUBLIC	_zNetReceive@20
PUBLIC	_zNetOpenConnection@16
PUBLIC	_zNetCloseConnection@8
PUBLIC	_fnProcessConnectionThreadProc@4
PUBLIC	_fnListenThreadProc@4
PUBLIC	_zNetListen@12
PUBLIC	_zNetStopListen@8
PUBLIC	_zNetGetHostAddress@20
PUBLIC	_zNetStart@8
PUBLIC	_zNetClose@8
PUBLIC	_GetDirectoryList@8
PUBLIC	_CompareFiles@4
PUBLIC	__zCall_CompareFiles@8
PUBLIC	_PerformApplicationUpdate@4
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	__real@408f400000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_memcpy:PROC
EXTRN	__imp__strchr:PROC
EXTRN	_strcat:PROC
EXTRN	_strcpy:PROC
EXTRN	__imp___stricmp:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__FindClose@4:PROC
EXTRN	__imp__FindFirstFileA@8:PROC
EXTRN	__imp__FindNextFileA@8:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__CreateMutexA@12:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__FileTimeToSystemTime@8:PROC
EXTRN	__imp__wsprintfA:PROC
EXTRN	_accept@12:PROC
EXTRN	_bind@12:PROC
EXTRN	_closesocket@4:PROC
EXTRN	_connect@12:PROC
EXTRN	_ioctlsocket@12:PROC
EXTRN	_getpeername@12:PROC
EXTRN	_htons@4:PROC
EXTRN	_listen@8:PROC
EXTRN	_recv@16:PROC
EXTRN	_send@16:PROC
EXTRN	_socket@12:PROC
EXTRN	_gethostbyaddr@12:PROC
EXTRN	_gethostbyname@4:PROC
EXTRN	_gethostname@8:PROC
EXTRN	_WSAStartup@8:PROC
EXTRN	_WSACleanup@0:PROC
EXTRN	_WSAGetLastError@0:PROC
EXTRN	__imp__calloc:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__atoi:PROC
EXTRN	__imp__atol:PROC
EXTRN	__imp___beginthreadex:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	_TraceLineI@8:PROC
EXTRN	_TraceLineX@8:PROC
EXTRN	_TraceLineS@8:PROC
EXTRN	_TraceBuffer@12:PROC
EXTRN	_GetViewByName@16:PROC
EXTRN	_SetNameForView@16:PROC
EXTRN	_DropView@4:PROC
EXTRN	_CreateEntity@12:PROC
EXTRN	_DeleteEntity@12:PROC
EXTRN	_SetCursorNextEntity@12:PROC
EXTRN	_SetCursorFirstEntity@12:PROC
EXTRN	_SetCursorFirstEntityByString@20:PROC
EXTRN	_SetCursorFirstEntityByAttr@28:PROC
EXTRN	_GetStringFromAttribute@16:PROC
EXTRN	_SetAttributeFromString@16:PROC
EXTRN	_GetIntegerFromAttribute@16:PROC
EXTRN	_SetAttributeFromInteger@16:PROC
EXTRN	_SetAttributeFromAttribute@24:PROC
EXTRN	_WriteBlobToFile@16:PROC
EXTRN	_SetBlobFromFile@16:PROC
EXTRN	_CompareAttributeToAttribute@24:PROC
EXTRN	_SetMatchingAttributesByName@20:PROC
EXTRN	_OrderEntityForView@12:PROC
EXTRN	_NetCallOperation:PROC
EXTRN	_NetProcessMessage@12:PROC
EXTRN	_NetGetTraceLevel@8:PROC
EXTRN	_RegisterZeidonApplication@28:PROC
EXTRN	_UnregisterZeidonApplication@4:PROC
EXTRN	_SysAppendcDirSep@4:PROC
EXTRN	_SysGetEnvVar@12:PROC
EXTRN	_SysGetPointerFromHandle@4:PROC
EXTRN	_SysGetTickCount@0:PROC
EXTRN	_SysMessageBox@16:PROC
EXTRN	_SysReadZeidonIni@16:PROC
EXTRN	_SysSetFileTime@12:PROC
EXTRN	_GetAddrForAttribute@16:PROC
EXTRN	_SfActivateSysOI_FromFile@20:PROC
EXTRN	_SfActivateSysEmptyOI@16:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?hMutexObject@?1??fnProcessConnectionThreadProc@@9@4@4PAXA
_BSS	SEGMENT
?hMutexObject@?1??fnProcessConnectionThreadProc@@9@4@4PAXA DD 01H DUP (?) ; `fnProcessConnectionThreadProc'::`2'::hMutexObject
_BSS	ENDS
;	COMDAT ?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA
_BSS	SEGMENT
?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA DD 01H DUP (?) ; `fnProcessConnectionThreadProc'::`2'::DoSync
_BSS	ENDS
;	COMDAT ?lMaxTotalFileSize@?1??CompareFiles@@9@4@4JA
_BSS	SEGMENT
?lMaxTotalFileSize@?1??CompareFiles@@9@4@4JA DD 01H DUP (?) ; `CompareFiles'::`2'::lMaxTotalFileSize
_BSS	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_pchAppName$ = -584					; size = 4
_nMore$ = -580						; size = 2
_iFileNameIdx$ = -576					; size = 2
_vAppList$ = -572					; size = 4
_vList$ = -568						; size = 4
_nRC$ = -564						; size = 2
_szSourceServer$1 = -560				; size = 256
_szFileName$ = -304					; size = 257
_szFileDateTime$2 = -44					; size = 40
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_PerformApplicationUpdate@4 PROC

; 1892 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 584				; 00000248H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1893 :    zSHORT nRC;
; 1894 :    zSHORT iFileNameIdx;
; 1895 :    zSHORT nMore;
; 1896 :    zVIEW  vList = 0;

	mov	DWORD PTR _vList$[ebp], 0

; 1897 :    zVIEW  vAppList;
; 1898 :    zCHAR  szFileName[ zMAX_FILENAME_LTH + 1 ];
; 1899 :    zPCHAR pchAppName;
; 1900 : 
; 1901 :    // Activate the object containing the app list.
; 1902 :    SysGetEnvVar( szFileName, "ZEIDON", sizeof( szFileName ) );

	push	257					; 00000101H
	push	OFFSET $SG120960
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_SysGetEnvVar@12

; 1903 :    SysAppendcDirSep( szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 1904 :    zstrcat( szFileName, "ZEIDON.APP" );

	push	OFFSET $SG120961
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1905 :    SfActivateSysOI_FromFile( &vAppList, "KZAPPLOO", lpView, szFileName, 0 );

	push	0
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpView$[ebp]
	push	ecx
	push	OFFSET $SG120962
	lea	edx, DWORD PTR _vAppList$[ebp]
	push	edx
	call	_SfActivateSysOI_FromFile@20

; 1906 : 
; 1907 :    for ( nRC = SetCursorFirstEntity( vAppList, "APPLICATION", 0 );

	push	0
	push	OFFSET $SG120963
	mov	eax, DWORD PTR _vAppList$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN4@PerformApp
$LN2@PerformApp:

; 1909 :          nRC = SetCursorNextEntity( vAppList, "APPLICATION", 0 ) )

	push	0
	push	OFFSET $SG120964
	mov	ecx, DWORD PTR _vAppList$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN4@PerformApp:

; 1908 :          nRC >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$LN3@PerformApp

; 1910 :    {
; 1911 :       zCHAR szSourceServer[ 256 ];
; 1912 : 
; 1913 :       GetAddrForAttribute( &pchAppName, vAppList, "APPLICATION", "APP_NAME" );

	push	OFFSET $SG120965
	push	OFFSET $SG120966
	mov	eax, DWORD PTR _vAppList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pchAppName$[ebp]
	push	ecx
	call	_GetAddrForAttribute@16

; 1914 : 
; 1915 :       // Check to see if a source server is specified for this app.  If not,
; 1916 :       // then skip it.
; 1917 :       SysReadZeidonIni( -1, pchAppName, "SourceServer", szSourceServer );

	lea	edx, DWORD PTR _szSourceServer$1[ebp]
	push	edx
	push	OFFSET $SG120967
	mov	eax, DWORD PTR _pchAppName$[ebp]
	push	eax
	push	-1
	call	_SysReadZeidonIni@16

; 1918 :       if ( szSourceServer[ 0 ] == 0 )

	mov	ecx, 1
	imul	edx, ecx, 0
	movsx	eax, BYTE PTR _szSourceServer$1[ebp+edx]
	test	eax, eax
	jne	SHORT $LN11@PerformApp

; 1919 :          continue;

	jmp	SHORT $LN2@PerformApp
$LN11@PerformApp:

; 1920 : 
; 1921 :       TraceLineS( "Performing application update for app: ", pchAppName );

	mov	ecx, DWORD PTR _pchAppName$[ebp]
	push	ecx
	push	OFFSET $SG120969
	call	_TraceLineS@8
$LN7@PerformApp:

; 1922 : 
; 1923 :       // Call an operation on the server to get the files.  Since it's possible
; 1924 :       // that the call will only return a partial list, we need to loop until
; 1925 :       // we get all the files.
; 1926 :       do
; 1927 :       {
; 1928 :          vList = 0;

	mov	DWORD PTR _vList$[ebp], 0

; 1929 :          GetDirectoryList( &vList, vAppList );

	mov	edx, DWORD PTR _vAppList$[ebp]
	push	edx
	lea	eax, DWORD PTR _vList$[ebp]
	push	eax
	call	_GetDirectoryList@8

; 1930 : 
; 1931 :          // Call the operation on the server that sends down the latest files.
; 1932 :          NetCallOperation( "zWinSock", szSourceServer, vList, FALSE,

	lea	ecx, DWORD PTR _vList$[ebp]
	push	ecx
	push	OFFSET $SG120970
	lea	edx, DWORD PTR _nMore$[ebp]
	push	edx
	push	OFFSET $SG120971
	push	OFFSET $SG120972
	push	0
	mov	eax, DWORD PTR _vList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szSourceServer$1[ebp]
	push	ecx
	push	OFFSET $SG120973
	call	_NetCallOperation
	add	esp, 36					; 00000024H

; 1933 :                            "zWinSock", "CompareFiles", &nMore, "NpV", &vList );
; 1934 : 
; 1935 :          GetStringFromAttribute( szFileName, vAppList, "APPLICATION", "APP_ADOBIN" );

	push	OFFSET $SG120974
	push	OFFSET $SG120975
	mov	edx, DWORD PTR _vAppList$[ebp]
	push	edx
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 1936 :          SysAppendcDirSep( szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_SysAppendcDirSep@4

; 1937 :          iFileNameIdx = zstrlen( szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	mov	WORD PTR _iFileNameIdx$[ebp], ax

; 1938 : 
; 1939 :          TraceLineS( "===== Files that being downloaded are: ======", "" );

	push	OFFSET $SG120976
	push	OFFSET $SG120977
	call	_TraceLineS@8

; 1940 :          for ( nRC = SetCursorFirstEntity( vList, "File", 0 );

	push	0
	push	OFFSET $SG120978
	mov	eax, DWORD PTR _vList$[ebp]
	push	eax
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nRC$[ebp], ax
	jmp	SHORT $LN10@PerformApp
$LN8@PerformApp:

; 1942 :                nRC = SetCursorNextEntity( vList, "File", 0 ) )

	push	0
	push	OFFSET $SG120979
	mov	ecx, DWORD PTR _vList$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nRC$[ebp], ax
$LN10@PerformApp:

; 1941 :                nRC >= zCURSOR_SET;

	movsx	edx, WORD PTR _nRC$[ebp]
	test	edx, edx
	jl	$LN9@PerformApp

; 1943 :          {
; 1944 :             zCHAR szFileDateTime[ 40 ];
; 1945 : 
; 1946 :             GetStringFromAttribute( &szFileName[ iFileNameIdx ],

	push	OFFSET $SG120980
	push	OFFSET $SG120981
	mov	eax, DWORD PTR _vList$[ebp]
	push	eax
	movsx	ecx, WORD PTR _iFileNameIdx$[ebp]
	lea	edx, DWORD PTR _szFileName$[ebp+ecx]
	push	edx
	call	_GetStringFromAttribute@16

; 1947 :                                     vList, "File", "FileName" );
; 1948 :             TraceLineS( "FileName: ", szFileName );

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	OFFSET $SG120982
	call	_TraceLineS@8

; 1949 :             WriteBlobToFile( vList, "File", "Data", szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	OFFSET $SG120983
	push	OFFSET $SG120984
	mov	edx, DWORD PTR _vList$[ebp]
	push	edx
	call	_WriteBlobToFile@16

; 1950 : 
; 1951 :             GetStringFromAttribute( szFileDateTime, vList, "File", "ModDate" );

	push	OFFSET $SG120985
	push	OFFSET $SG120986
	mov	eax, DWORD PTR _vList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileDateTime$2[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 1952 :             SysSetFileTime( szFileName, szFileDateTime, 0 );

	push	0
	lea	edx, DWORD PTR _szFileDateTime$2[ebp]
	push	edx
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_SysSetFileTime@12

; 1953 :          }

	jmp	$LN8@PerformApp
$LN9@PerformApp:

; 1954 : 
; 1955 :          DropView( vList );

	mov	ecx, DWORD PTR _vList$[ebp]
	push	ecx
	call	_DropView@4

; 1956 : 
; 1957 :       } while ( nMore == 1 );

	movsx	edx, WORD PTR _nMore$[ebp]
	cmp	edx, 1
	je	$LN7@PerformApp

; 1958 : 
; 1959 :    } // For each APPLICATION...

	jmp	$LN2@PerformApp
$LN3@PerformApp:

; 1960 : 
; 1961 :    DropView( vAppList );

	mov	eax, DWORD PTR _vAppList$[ebp]
	push	eax
	call	_DropView@4

; 1962 :    return( 0 );

	xor	eax, eax

; 1963 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_PerformApplicationUpdate@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_ReturnValue$ = -4					; size = 2
_vArgs$ = 8						; size = 4
_pvViewList$ = 12					; size = 4
__zCall_CompareFiles@8 PROC

; 1881 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1882 :    zSHORT   ReturnValue;
; 1883 : 
; 1884 :    ReturnValue = CompareFiles( pvViewList[ 0 ] );

	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pvViewList$[ebp]
	mov	eax, DWORD PTR [edx+ecx]
	push	eax
	call	_CompareFiles@4
	mov	WORD PTR _ReturnValue$[ebp], ax

; 1885 :    SetAttributeFromInteger( vArgs, "Operation", "ReturnValue", ReturnValue );

	movsx	ecx, WORD PTR _ReturnValue$[ebp]
	push	ecx
	push	OFFSET $SG120937
	push	OFFSET $SG120938
	mov	edx, DWORD PTR _vArgs$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16

; 1886 : 
; 1887 :    return( 0 );

	xor	eax, eax

; 1888 : }

	mov	esp, ebp
	pop	ebp
	ret	8
__zCall_CompareFiles@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_lFileSize$ = -928					; size = 4
_lTotalFileSize$ = -924					; size = 4
_iNameIdx$ = -920					; size = 2
_vAppList$ = -916					; size = 4
_nRC$ = -912						; size = 2
_nFileCount$ = -908					; size = 2
_nServerRC$ = -904					; size = 2
_nCmprResult$1 = -900					; size = 2
_nClientRC$ = -896					; size = 2
_vServerList$ = -892					; size = 4
_vClientList$ = -888					; size = 4
_szServerFile$2 = -884					; size = 257
_szClientFile$3 = -624					; size = 257
_szTemp$4 = -364					; size = 100
_szFileName$ = -264					; size = 257
__$ArrayPad$ = -4					; size = 4
_pvList$ = 8						; size = 4
_CompareFiles@4 PROC

; 1741 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 928				; 000003a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1742 :    static zLONG lMaxTotalFileSize = 0;
; 1743 : 
; 1744 :    zSHORT nRC = 0;

	xor	eax, eax
	mov	WORD PTR _nRC$[ebp], ax

; 1745 :    zSHORT nServerRC;
; 1746 :    zSHORT nClientRC;
; 1747 :    zSHORT nFileCount = 0;

	xor	ecx, ecx
	mov	WORD PTR _nFileCount$[ebp], cx

; 1748 :    zLONG  lTotalFileSize = 0;

	mov	DWORD PTR _lTotalFileSize$[ebp], 0

; 1749 :    zLONG  lFileSize;
; 1750 :    zSHORT iNameIdx;
; 1751 :    zVIEW  vServerList = 0;

	mov	DWORD PTR _vServerList$[ebp], 0

; 1752 :    zVIEW  vAppList;
; 1753 :    zVIEW  vClientList = *pvList;

	mov	edx, DWORD PTR _pvList$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _vClientList$[ebp], eax

; 1754 :    zCHAR  szFileName[ zMAX_FILENAME_LTH + 1 ];
; 1755 : 
; 1756 :    // Activate the object containing the app list.
; 1757 :    SysGetEnvVar( szFileName, "ZEIDON", sizeof( szFileName ) );

	push	257					; 00000101H
	push	OFFSET $SG120869
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_SysGetEnvVar@12

; 1758 :    SysAppendcDirSep( szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 1759 :    zstrcat( szFileName, "ZEIDON.APP" );

	push	OFFSET $SG120870
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1760 :    SfActivateSysOI_FromFile( &vAppList, "KZAPPLOO", 0, szFileName, 0 );

	push	0
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	0
	push	OFFSET $SG120871
	lea	edx, DWORD PTR _vAppList$[ebp]
	push	edx
	call	_SfActivateSysOI_FromFile@20

; 1761 : 
; 1762 :    // Make sure the application exists for this server.
; 1763 :    if ( SetCursorFirstEntityByAttr( vAppList, "APPLICATION", "APP_NAME",
; 1764 :                                     vClientList, "KZFXFERO", "ApplicationName",
; 1765 :                                     0 ) < zCURSOR_SET )

	push	0
	push	OFFSET $SG120873
	push	OFFSET $SG120874
	mov	eax, DWORD PTR _vClientList$[ebp]
	push	eax
	push	OFFSET $SG120875
	push	OFFSET $SG120876
	mov	ecx, DWORD PTR _vAppList$[ebp]
	push	ecx
	call	_SetCursorFirstEntityByAttr@28
	movsx	edx, ax
	test	edx, edx
	jge	SHORT $LN6@CompareFil

; 1766 :    {
; 1767 :       SysMessageBox( *pvList, "Application Update Error",

	push	0
	push	OFFSET $SG120877
	push	OFFSET $SG120878
	mov	eax, DWORD PTR _pvList$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_SysMessageBox@16

; 1768 :                      "Error: Couldn't find application", 0 );
; 1769 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@CompareFil
$LN6@CompareFil:

; 1770 :    }
; 1771 : 
; 1772 :    // Get the list of executable files for the app server.
; 1773 :    GetStringFromAttribute( szFileName, vAppList, "APPLICATION", "APP_NAME" );

	push	OFFSET $SG120879
	push	OFFSET $SG120880
	mov	edx, DWORD PTR _vAppList$[ebp]
	push	edx
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 1774 :    if ( lMaxTotalFileSize == 0 )

	cmp	DWORD PTR ?lMaxTotalFileSize@?1??CompareFiles@@9@4@4JA, 0
	jne	SHORT $LN7@CompareFil

; 1775 :    {
; 1776 :       zCHAR szTemp[ 100 ];
; 1777 : 
; 1778 :       SysReadZeidonIni( -1, szFileName, "MaxTotalFileSize", szTemp );

	lea	ecx, DWORD PTR _szTemp$4[ebp]
	push	ecx
	push	OFFSET $SG120882
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	push	-1
	call	_SysReadZeidonIni@16

; 1779 :       if ( *szTemp )

	mov	eax, 1
	imul	ecx, eax, 0
	movsx	edx, BYTE PTR _szTemp$4[ebp+ecx]
	test	edx, edx
	je	SHORT $LN8@CompareFil

; 1780 :          lMaxTotalFileSize = zatol( szTemp );

	lea	eax, DWORD PTR _szTemp$4[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	DWORD PTR ?lMaxTotalFileSize@?1??CompareFiles@@9@4@4JA, eax
$LN8@CompareFil:

; 1781 : 
; 1782 :       if ( lMaxTotalFileSize <= 0 )

	cmp	DWORD PTR ?lMaxTotalFileSize@?1??CompareFiles@@9@4@4JA, 0
	jg	SHORT $LN7@CompareFil

; 1783 :          lMaxTotalFileSize = 1000000;

	mov	DWORD PTR ?lMaxTotalFileSize@?1??CompareFiles@@9@4@4JA, 1000000 ; 000f4240H
$LN7@CompareFil:

; 1784 :    }
; 1785 : 
; 1786 :    TraceLineS( "Performing Application Update for app: ", szFileName );

	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	push	OFFSET $SG120885
	call	_TraceLineS@8

; 1787 : 
; 1788 :    zstrcat( szFileName, "_ExecutableSourceList" );

	push	OFFSET $SG120886
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_strcat
	add	esp, 8

; 1789 :    GetViewByName( &vServerList, szFileName, 0, zLEVEL_SYSTEM );

	push	8
	push	0
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _vServerList$[ebp]
	push	ecx
	call	_GetViewByName@16

; 1790 :    if ( vServerList == 0 )

	cmp	DWORD PTR _vServerList$[ebp], 0
	jne	SHORT $LN10@CompareFil

; 1791 :    {
; 1792 :       GetDirectoryList( &vServerList, vAppList );

	mov	edx, DWORD PTR _vAppList$[ebp]
	push	edx
	lea	eax, DWORD PTR _vServerList$[ebp]
	push	eax
	call	_GetDirectoryList@8

; 1793 :       SetNameForView( vServerList, szFileName, 0, zLEVEL_SYSTEM );

	push	8
	push	0
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	mov	edx, DWORD PTR _vServerList$[ebp]
	push	edx
	call	_SetNameForView@16
$LN10@CompareFil:

; 1794 :    }
; 1795 : 
; 1796 :    GetStringFromAttribute( szFileName, vAppList, "APPLICATION", "APP_ADOBIN" );

	push	OFFSET $SG120888
	push	OFFSET $SG120889
	mov	eax, DWORD PTR _vAppList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 1797 :    SysAppendcDirSep( szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 1798 :    iNameIdx = zstrlen( szFileName );

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_strlen
	add	esp, 4
	mov	WORD PTR _iNameIdx$[ebp], ax

; 1799 : 
; 1800 :    nClientRC = SetCursorFirstEntity( vClientList, "File", 0 );

	push	0
	push	OFFSET $SG120890
	mov	ecx, DWORD PTR _vClientList$[ebp]
	push	ecx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nClientRC$[ebp], ax

; 1801 :    nServerRC = SetCursorFirstEntity( vServerList, "File", 0 );

	push	0
	push	OFFSET $SG120891
	mov	edx, DWORD PTR _vServerList$[ebp]
	push	edx
	call	_SetCursorFirstEntity@12
	mov	WORD PTR _nServerRC$[ebp], ax
$LN2@CompareFil:

; 1802 :    while ( nServerRC >= zCURSOR_SET )

	movsx	eax, WORD PTR _nServerRC$[ebp]
	test	eax, eax
	jl	$LN4@CompareFil

; 1803 :    {
; 1804 :       zCHAR szServerFile[ zMAX_FILENAME_LTH + 1 ];
; 1805 :       zCHAR szClientFile[ zMAX_FILENAME_LTH + 1 ];
; 1806 :       zSHORT nCmprResult;
; 1807 : 
; 1808 :       if ( nClientRC >= zCURSOR_SET )

	movsx	ecx, WORD PTR _nClientRC$[ebp]
	test	ecx, ecx
	jl	SHORT $LN11@CompareFil

; 1809 :       {
; 1810 :          GetStringFromAttribute( szServerFile, vServerList, "File", "FileName" );

	push	OFFSET $SG120894
	push	OFFSET $SG120895
	mov	edx, DWORD PTR _vServerList$[ebp]
	push	edx
	lea	eax, DWORD PTR _szServerFile$2[ebp]
	push	eax
	call	_GetStringFromAttribute@16

; 1811 :          GetStringFromAttribute( szClientFile, vClientList, "File", "FileName" );

	push	OFFSET $SG120896
	push	OFFSET $SG120897
	mov	ecx, DWORD PTR _vClientList$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szClientFile$3[ebp]
	push	edx
	call	_GetStringFromAttribute@16

; 1812 : 
; 1813 :          nCmprResult = zstrcmpi( szServerFile, szClientFile );

	lea	eax, DWORD PTR _szClientFile$3[ebp]
	push	eax
	lea	ecx, DWORD PTR _szServerFile$2[ebp]
	push	ecx
	call	DWORD PTR __imp___stricmp
	add	esp, 8
	mov	WORD PTR _nCmprResult$1[ebp], ax

; 1814 :       }
; 1815 :       else

	jmp	SHORT $LN12@CompareFil
$LN11@CompareFil:

; 1816 :          nCmprResult = -1;

	or	edx, -1
	mov	WORD PTR _nCmprResult$1[ebp], dx
$LN12@CompareFil:

; 1817 : 
; 1818 :       if ( nCmprResult != 0 )

	movsx	eax, WORD PTR _nCmprResult$1[ebp]
	test	eax, eax
	je	SHORT $LN13@CompareFil

; 1819 :       {
; 1820 :          // File names don't match.  Either a file exists on the server that
; 1821 :          // doesn't exist on the client or vice versa.  If the client file is
; 1822 :          // less than the server file then the file doesn't exist on the server.
; 1823 :          if ( nCmprResult > 0 )  // If client file is "lesser"

	movsx	ecx, WORD PTR _nCmprResult$1[ebp]
	test	ecx, ecx
	jle	SHORT $LN15@CompareFil

; 1824 :          {
; 1825 :             nClientRC = SetCursorNextEntity( vClientList, "File", 0 );

	push	0
	push	OFFSET $SG120901
	mov	edx, DWORD PTR _vClientList$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nClientRC$[ebp], ax

; 1826 :             continue;

	jmp	$LN2@CompareFil
$LN15@CompareFil:

; 1827 :          }
; 1828 : 
; 1829 :          // A file exists on the server that doesn't exist on the client.
; 1830 :          // Add a new entity to the client list.
; 1831 :          CreateEntity( vClientList, "File", zPOS_PREV );

	push	4
	push	OFFSET $SG120902
	mov	eax, DWORD PTR _vClientList$[ebp]
	push	eax
	call	_CreateEntity@12

; 1832 :          SetMatchingAttributesByName( vClientList, "File",

	push	3
	push	OFFSET $SG120903
	mov	ecx, DWORD PTR _vServerList$[ebp]
	push	ecx
	push	OFFSET $SG120904
	mov	edx, DWORD PTR _vClientList$[ebp]
	push	edx
	call	_SetMatchingAttributesByName@20

; 1833 :                                       vServerList, "File", zSET_ALL );
; 1834 :       }
; 1835 :       else

	jmp	SHORT $LN14@CompareFil
$LN13@CompareFil:

; 1836 :       if ( CompareAttributeToAttribute( vClientList, "File", "ModDate",
; 1837 :                                         vServerList, "File", "ModDate" ) == 0 )

	push	OFFSET $SG120906
	push	OFFSET $SG120907
	mov	eax, DWORD PTR _vServerList$[ebp]
	push	eax
	push	OFFSET $SG120908
	push	OFFSET $SG120909
	mov	ecx, DWORD PTR _vClientList$[ebp]
	push	ecx
	call	_CompareAttributeToAttribute@24
	movsx	edx, ax
	test	edx, edx
	jne	SHORT $LN14@CompareFil

; 1838 :       {
; 1839 :          // File mod dates match so we don't have to do anything.  Go on to
; 1840 :          // next files.
; 1841 :          nClientRC = SetCursorNextEntity( vClientList, "File", 0 );

	push	0
	push	OFFSET $SG120910
	mov	eax, DWORD PTR _vClientList$[ebp]
	push	eax
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nClientRC$[ebp], ax

; 1842 :          nServerRC = SetCursorNextEntity( vServerList, "File", 0 );

	push	0
	push	OFFSET $SG120911
	mov	ecx, DWORD PTR _vServerList$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nServerRC$[ebp], ax

; 1843 :          continue;

	jmp	$LN2@CompareFil
$LN14@CompareFil:

; 1844 :       }
; 1845 : 
; 1846 :       // Keep track of the number of files we are downloading.
; 1847 :       nFileCount++;

	mov	dx, WORD PTR _nFileCount$[ebp]
	add	dx, 1
	mov	WORD PTR _nFileCount$[ebp], dx

; 1848 : 
; 1849 :       GetStringFromAttribute( &szFileName[ iNameIdx ],

	push	OFFSET $SG120912
	push	OFFSET $SG120913
	mov	eax, DWORD PTR _vClientList$[ebp]
	push	eax
	movsx	ecx, WORD PTR _iNameIdx$[ebp]
	lea	edx, DWORD PTR _szFileName$[ebp+ecx]
	push	edx
	call	_GetStringFromAttribute@16

; 1850 :                               vClientList, "File", "FileName" );
; 1851 :       SetAttributeFromString( vClientList, "File", "Updated", "Y" );

	push	OFFSET $SG120914
	push	OFFSET $SG120915
	push	OFFSET $SG120916
	mov	eax, DWORD PTR _vClientList$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1852 :       SetAttributeFromAttribute( vClientList, "File", "ModDate",

	push	OFFSET $SG120917
	push	OFFSET $SG120918
	mov	ecx, DWORD PTR _vServerList$[ebp]
	push	ecx
	push	OFFSET $SG120919
	push	OFFSET $SG120920
	mov	edx, DWORD PTR _vClientList$[ebp]
	push	edx
	call	_SetAttributeFromAttribute@24

; 1853 :                                  vServerList, "File", "ModDate" );
; 1854 :       SetBlobFromFile( vClientList, "File", "Data", szFileName );

	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	push	OFFSET $SG120921
	push	OFFSET $SG120922
	mov	ecx, DWORD PTR _vClientList$[ebp]
	push	ecx
	call	_SetBlobFromFile@16

; 1855 : 
; 1856 :       // We only take so much at a time.
; 1857 :       GetIntegerFromAttribute( &lFileSize, vServerList, "File", "FileSize" );

	push	OFFSET $SG120923
	push	OFFSET $SG120924
	mov	edx, DWORD PTR _vServerList$[ebp]
	push	edx
	lea	eax, DWORD PTR _lFileSize$[ebp]
	push	eax
	call	_GetIntegerFromAttribute@16

; 1858 :       lTotalFileSize += lFileSize;

	mov	ecx, DWORD PTR _lTotalFileSize$[ebp]
	add	ecx, DWORD PTR _lFileSize$[ebp]
	mov	DWORD PTR _lTotalFileSize$[ebp], ecx

; 1859 :       if ( lTotalFileSize > lMaxTotalFileSize )

	mov	edx, DWORD PTR _lTotalFileSize$[ebp]
	cmp	edx, DWORD PTR ?lMaxTotalFileSize@?1??CompareFiles@@9@4@4JA
	jle	SHORT $LN17@CompareFil

; 1860 :       {
; 1861 :          nRC = 1;

	mov	eax, 1
	mov	WORD PTR _nRC$[ebp], ax

; 1862 :          break;

	jmp	SHORT $LN4@CompareFil
$LN17@CompareFil:

; 1863 :       }
; 1864 : 
; 1865 :       nClientRC = SetCursorNextEntity( vClientList, "File", 0 );

	push	0
	push	OFFSET $SG120926
	mov	ecx, DWORD PTR _vClientList$[ebp]
	push	ecx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nClientRC$[ebp], ax

; 1866 :       nServerRC = SetCursorNextEntity( vServerList, "File", 0 );

	push	0
	push	OFFSET $SG120927
	mov	edx, DWORD PTR _vServerList$[ebp]
	push	edx
	call	_SetCursorNextEntity@12
	mov	WORD PTR _nServerRC$[ebp], ax

; 1867 :    }

	jmp	$LN2@CompareFil
$LN4@CompareFil:

; 1868 : 
; 1869 :    // Now delete all entities that don't have the Updated flag set.
; 1870 :    while ( SetCursorFirstEntityByString( vClientList, "File", "Updated", "",
; 1871 :                                          0 ) >= zCURSOR_SET )

	push	0
	push	OFFSET $SG120928
	push	OFFSET $SG120929
	push	OFFSET $SG120930
	mov	eax, DWORD PTR _vClientList$[ebp]
	push	eax
	call	_SetCursorFirstEntityByString@20
	movsx	ecx, ax
	test	ecx, ecx
	jl	SHORT $LN5@CompareFil

; 1872 :    {
; 1873 :       DeleteEntity( vClientList, "File", zREPOS_FIRST );

	push	1
	push	OFFSET $SG120931
	mov	edx, DWORD PTR _vClientList$[ebp]
	push	edx
	call	_DeleteEntity@12

; 1874 :    }

	jmp	SHORT $LN4@CompareFil
$LN5@CompareFil:

; 1875 : 
; 1876 :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@CompareFil:

; 1877 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_CompareFiles@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_hFind$ = -660						; size = 4
_vList$ = -656						; size = 4
_FileData$ = -652					; size = 318
_lpTime$1 = -332					; size = 16
_szFileName$ = -316					; size = 257
_szTimestamp$2 = -56					; size = 50
__$ArrayPad$ = -4					; size = 4
_pvList$ = 8						; size = 4
_vAppList$ = 12						; size = 4
_GetDirectoryList@8 PROC

; 1679 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 660				; 00000294H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1680 :    WIN32_FIND_DATA FileData;
; 1681 :    HANDLE          hFind;
; 1682 :    zVIEW           vList;
; 1683 :    zCHAR           szFileName[ zMAX_FILENAME_LTH + 1 ];
; 1684 : 
; 1685 :    if ( *pvList == 0 )

	mov	eax, DWORD PTR _pvList$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@GetDirecto

; 1686 :    {
; 1687 :       SfActivateSysEmptyOI( pvList, "KZFXFERO", 0, zMULTIPLE | zLEVEL_SYSTEM );

	push	264					; 00000108H
	push	0
	push	OFFSET $SG120823
	mov	ecx, DWORD PTR _pvList$[ebp]
	push	ecx
	call	_SfActivateSysEmptyOI@16

; 1688 :       CreateEntity( *pvList, "KZFXFERO", zPOS_FIRST );

	push	1
	push	OFFSET $SG120824
	mov	edx, DWORD PTR _pvList$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_CreateEntity@12

; 1689 :       SetAttributeFromAttribute( *pvList, "KZFXFERO", "ApplicationName",

	push	OFFSET $SG120825
	push	OFFSET $SG120826
	mov	ecx, DWORD PTR _vAppList$[ebp]
	push	ecx
	push	OFFSET $SG120827
	push	OFFSET $SG120828
	mov	edx, DWORD PTR _pvList$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_SetAttributeFromAttribute@24
$LN5@GetDirecto:

; 1690 :                                  vAppList, "APPLICATION", "APP_NAME" );
; 1691 :    }
; 1692 : 
; 1693 :    vList = *pvList;  // Just so it's easier.

	mov	ecx, DWORD PTR _pvList$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _vList$[ebp], edx

; 1694 : 
; 1695 :    GetStringFromAttribute( szFileName, vAppList, "APPLICATION", "APP_ADOBIN" );

	push	OFFSET $SG120829
	push	OFFSET $SG120830
	mov	eax, DWORD PTR _vAppList$[ebp]
	push	eax
	lea	ecx, DWORD PTR _szFileName$[ebp]
	push	ecx
	call	_GetStringFromAttribute@16

; 1696 :    SysAppendcDirSep( szFileName );

	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	_SysAppendcDirSep@4

; 1697 :    zstrcat( szFileName, "*" );

	push	OFFSET $SG120831
	lea	eax, DWORD PTR _szFileName$[ebp]
	push	eax
	call	_strcat
	add	esp, 8

; 1698 : 
; 1699 :    hFind = FindFirstFile( szFileName, &FileData );

	lea	ecx, DWORD PTR _FileData$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szFileName$[ebp]
	push	edx
	call	DWORD PTR __imp__FindFirstFileA@8
	mov	DWORD PTR _hFind$[ebp], eax

; 1700 :    if ( hFind != INVALID_HANDLE_VALUE )

	cmp	DWORD PTR _hFind$[ebp], -1
	je	$LN6@GetDirecto
$LN4@GetDirecto:

; 1701 :    {
; 1702 :       do
; 1703 :       {
; 1704 :          if ( ( FileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) == 0 )

	mov	eax, DWORD PTR _FileData$[ebp]
	and	eax, 16					; 00000010H
	jne	$LN2@GetDirecto

; 1705 :          {
; 1706 :             zCHAR      szTimestamp[ 50 ];
; 1707 :             SYSTEMTIME lpTime;
; 1708 : 
; 1709 :             CreateEntity( vList, "File", zPOS_LAST );

	push	2
	push	OFFSET $SG120834
	mov	ecx, DWORD PTR _vList$[ebp]
	push	ecx
	call	_CreateEntity@12

; 1710 :             SetAttributeFromString( vList, "File", "FileName",

	lea	edx, DWORD PTR _FileData$[ebp+44]
	push	edx
	push	OFFSET $SG120835
	push	OFFSET $SG120836
	mov	eax, DWORD PTR _vList$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1711 :                                     FileData.cFileName );
; 1712 : 
; 1713 :             FileTimeToSystemTime( &FileData.ftLastWriteTime, &lpTime );

	lea	ecx, DWORD PTR _lpTime$1[ebp]
	push	ecx
	lea	edx, DWORD PTR _FileData$[ebp+20]
	push	edx
	call	DWORD PTR __imp__FileTimeToSystemTime@8

; 1714 :             zsprintf( szTimestamp, "%d%02d%02d%02d%02d%02d%d",

	movzx	eax, WORD PTR _lpTime$1[ebp+14]
	push	eax
	movzx	ecx, WORD PTR _lpTime$1[ebp+12]
	push	ecx
	movzx	edx, WORD PTR _lpTime$1[ebp+10]
	push	edx
	movzx	eax, WORD PTR _lpTime$1[ebp+8]
	push	eax
	movzx	ecx, WORD PTR _lpTime$1[ebp+6]
	push	ecx
	movzx	edx, WORD PTR _lpTime$1[ebp+2]
	push	edx
	movzx	eax, WORD PTR _lpTime$1[ebp]
	push	eax
	push	OFFSET $SG120837
	lea	ecx, DWORD PTR _szTimestamp$2[ebp]
	push	ecx
	call	_sprintf
	add	esp, 36					; 00000024H

; 1715 :                       lpTime.wYear, lpTime.wMonth, lpTime.wDay, lpTime.wHour,
; 1716 :                       lpTime.wMinute, lpTime.wSecond, lpTime.wMilliseconds );
; 1717 :             SetAttributeFromString( vList, "File", "ModDate", szTimestamp );

	lea	edx, DWORD PTR _szTimestamp$2[ebp]
	push	edx
	push	OFFSET $SG120838
	push	OFFSET $SG120839
	mov	eax, DWORD PTR _vList$[ebp]
	push	eax
	call	_SetAttributeFromString@16

; 1718 :             SetAttributeFromInteger( vList, "File", "FileSize",

	mov	ecx, DWORD PTR _FileData$[ebp+32]
	push	ecx
	push	OFFSET $SG120840
	push	OFFSET $SG120841
	mov	edx, DWORD PTR _vList$[ebp]
	push	edx
	call	_SetAttributeFromInteger@16
$LN2@GetDirecto:

; 1719 :                                      FileData.nFileSizeLow );
; 1720 :          }
; 1721 : 
; 1722 :       } while ( FindNextFile( hFind, &FileData ) );

	lea	eax, DWORD PTR _FileData$[ebp]
	push	eax
	mov	ecx, DWORD PTR _hFind$[ebp]
	push	ecx
	call	DWORD PTR __imp__FindNextFileA@8
	test	eax, eax
	jne	$LN4@GetDirecto

; 1723 : 
; 1724 :       FindClose( hFind );

	mov	edx, DWORD PTR _hFind$[ebp]
	push	edx
	call	DWORD PTR __imp__FindClose@4
$LN6@GetDirecto:

; 1725 :    }
; 1726 : 
; 1727 :    // Last thing...sort files by name so we can more quickly compare them.
; 1728 :    OrderEntityForView( vList, "File", "FileName" );

	push	OFFSET $SG120842
	push	OFFSET $SG120843
	mov	eax, DWORD PTR _vList$[ebp]
	push	eax
	call	_OrderEntityForView@12

; 1729 : 
; 1730 :    return( 0 );

	xor	eax, eax

; 1731 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_GetDirectoryList@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_lpSockets$ = -4					; size = 4
_lpView$ = 8						; size = 4
_ppHandle$ = 12						; size = 4
_zNetClose@8 PROC

; 1598 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 1599 :    LPSOCKETS lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 1600 : 
; 1601 :    if ( NetGetTraceLevel( lpView, "zWinSock" ) > 0 )

	push	OFFSET $SG120801
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_NetGetTraceLevel@8
	cwde
	test	eax, eax
	jle	SHORT $LN2@zNetClose

; 1602 :       TraceLineS( "(zwinsock) Shutting down network zWinSock", "" );

	push	OFFSET $SG120802
	push	OFFSET $SG120803
	call	_TraceLineS@8
$LN2@zNetClose:

; 1603 : 
; 1604 :    if ( lpSockets->sockListen != INVALID_SOCKET )

	mov	ecx, DWORD PTR _lpSockets$[ebp]
	cmp	DWORD PTR [ecx+64], -1
	je	SHORT $LN3@zNetClose

; 1605 :       zNetStopListen( lpView, ppHandle );

	mov	edx, DWORD PTR _ppHandle$[ebp]
	push	edx
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_zNetStopListen@8
$LN3@zNetClose:

; 1606 : 
; 1607 : #if !defined(  __UNIX__ )
; 1608 :    WSACleanup();

	call	_WSACleanup@0

; 1609 : #endif
; 1610 : 
; 1611 :    // After the following call, lpSockets is no longer valid.
; 1612 :    free( (zPVOID) lpSockets->hMemHandle );

	mov	ecx, DWORD PTR _lpSockets$[ebp]
	mov	edx, DWORD PTR [ecx+60]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4

; 1613 : 
; 1614 :    *ppHandle = 0;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	DWORD PTR [eax], 0

; 1615 : 
; 1616 :    return( 0 );

	xor	eax, eax

; 1617 : 
; 1618 : } // zNetClose

	mov	esp, ebp
	pop	ebp
	ret	8
_zNetClose@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_hMemHandle$ = -604					; size = 4
_status$ = -600						; size = 4
$T1 = -596						; size = 4
_lpSockets$ = -592					; size = 4
_WSAData$ = -588					; size = 398
_szTemp$2 = -188					; size = 80
_szTemp$3 = -108					; size = 80
_dummy1$ = -28						; size = 10
_dummy2$ = -16						; size = 10
__$ArrayPad$ = -4					; size = 4
_pchNetworkName$ = 8					; size = 4
_ppHandle$ = 12						; size = 4
_zNetStart@8 PROC

; 1521 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 604				; 0000025cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1522 :    zLONG     hMemHandle;
; 1523 :    LPSOCKETS lpSockets;
; 1524 : 
; 1525 : #ifdef __WIN32__
; 1526 : 
; 1527 :    char      dummy1[ 10 ]; // BoundsChecker reported an error that said
; 1528 :    WSADATA   WSAData;      // WSAStartup() was writing past WSAData.  Dummy
; 1529 :    char      dummy2[ 10 ]; // vars are to protect stack.
; 1530 :    int       status;
; 1531 : 
; 1532 :    // Following is to stop compiler warnings:
; 1533 :    *dummy1 = *dummy2 = 0;

	mov	eax, 1
	imul	ecx, eax, 0
	mov	DWORD PTR $T1[ebp], ecx
	cmp	DWORD PTR $T1[ebp], 10			; 0000000aH
	jae	SHORT $LN5@zNetStart
	jmp	SHORT $LN6@zNetStart
$LN5@zNetStart:
	call	___report_rangecheckfailure
$LN6@zNetStart:
	mov	edx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _dummy2$[ebp+edx], 0
	mov	eax, 1
	imul	ecx, eax, 0
	mov	BYTE PTR _dummy1$[ebp+ecx], 0

; 1534 : 
; 1535 :    *ppHandle = 0;

	mov	edx, DWORD PTR _ppHandle$[ebp]
	mov	DWORD PTR [edx], 0

; 1536 : 
; 1537 :    if ( (status = WSAStartup( 0x0101, &WSAData )) != 0 )

	lea	eax, DWORD PTR _WSAData$[ebp]
	push	eax
	push	257					; 00000101H
	call	_WSAStartup@8
	mov	DWORD PTR _status$[ebp], eax
	cmp	DWORD PTR _status$[ebp], 0
	je	SHORT $LN2@zNetStart

; 1538 :    {
; 1539 :       char szTemp[ 80 ];
; 1540 : 
; 1541 :       sprintf( szTemp, "Error loading starting WinSock: %d", status );

	mov	ecx, DWORD PTR _status$[ebp]
	push	ecx
	push	OFFSET $SG120783
	lea	edx, DWORD PTR _szTemp$3[ebp]
	push	edx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 1542 :       SysMessageBox( 0, szlErrorTitle, szTemp, -1 );

	push	-1
	lea	eax, DWORD PTR _szTemp$3[ebp]
	push	eax
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1543 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN4@zNetStart
$LN2@zNetStart:

; 1544 :    }
; 1545 : 
; 1546 : // TraceLineX( "(zwinsock) Task ID             = ", (zLONG) SysGetTaskID( ) );
; 1547 :    TraceLineX( "(zwinsock) WinSock Version     = ", WSAData.wVersion );

	movzx	ecx, WORD PTR _WSAData$[ebp]
	push	ecx
	push	OFFSET $SG120784
	call	_TraceLineX@8

; 1548 :    TraceLineX( "(zwinsock) WinSock HighVersion = ", WSAData.wHighVersion );

	movzx	edx, WORD PTR _WSAData$[ebp+2]
	push	edx
	push	OFFSET $SG120785
	call	_TraceLineX@8

; 1549 :    TraceLineS( "(zwinsock) WinSock Description = ", WSAData.szDescription );

	lea	eax, DWORD PTR _WSAData$[ebp+4]
	push	eax
	push	OFFSET $SG120786
	call	_TraceLineS@8

; 1550 :    TraceLineS( "(zwinsock) System status       = ", WSAData.szSystemStatus );

	lea	ecx, DWORD PTR _WSAData$[ebp+261]
	push	ecx
	push	OFFSET $SG120787
	call	_TraceLineS@8

; 1551 :    TraceLineI( "(zwinsock) Max sockets         = ", WSAData.iMaxSockets );

	movzx	edx, WORD PTR _WSAData$[ebp+390]
	push	edx
	push	OFFSET $SG120788
	call	_TraceLineI@8

; 1552 :    TraceLineI( "(zwinsock) Max UPD datagram    = ", WSAData.iMaxUdpDg );

	movzx	eax, WORD PTR _WSAData$[ebp+392]
	push	eax
	push	OFFSET $SG120789
	call	_TraceLineI@8

; 1553 : 
; 1554 : #endif // __WIN32__
; 1555 : 
; 1556 :    hMemHandle = (zLONG) malloc( sizeof( SocketsRecord ) );

	push	72					; 00000048H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _hMemHandle$[ebp], eax

; 1557 :    *ppHandle = (zPCHAR) hMemHandle;

	mov	ecx, DWORD PTR _ppHandle$[ebp]
	mov	edx, DWORD PTR _hMemHandle$[ebp]
	mov	DWORD PTR [ecx], edx

; 1558 :    if ( *ppHandle == 0 )

	mov	eax, DWORD PTR _ppHandle$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@zNetStart

; 1559 :    {
; 1560 :       char szTemp[ 80 ];
; 1561 : 
; 1562 : #ifdef __WIN32__
; 1563 :       WSACleanup();

	call	_WSACleanup@0

; 1564 :       wsprintf( szTemp, "Out of memory starting network '%s'", pchNetworkName );

	mov	ecx, DWORD PTR _pchNetworkName$[ebp]
	push	ecx
	push	OFFSET $SG120791
	lea	edx, DWORD PTR _szTemp$2[ebp]
	push	edx
	call	DWORD PTR __imp__wsprintfA
	add	esp, 12					; 0000000cH

; 1565 :       SysMessageBox( 0, szlErrorTitle, szTemp, -1 );

	push	-1
	lea	eax, DWORD PTR _szTemp$2[ebp]
	push	eax
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1566 : #endif
; 1567 : 
; 1568 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN4@zNetStart
$LN3@zNetStart:

; 1569 :    }
; 1570 : 
; 1571 :    lpSockets = (LPSOCKETS) *ppHandle;

	mov	ecx, DWORD PTR _ppHandle$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _lpSockets$[ebp], edx

; 1572 :    zstrcpy( lpSockets->szNetworkName, pchNetworkName );

	mov	eax, DWORD PTR _pchNetworkName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpSockets$[ebp]
	push	ecx
	call	_strcpy
	add	esp, 8

; 1573 :    lpSockets->hMemHandle = hMemHandle;

	mov	edx, DWORD PTR _lpSockets$[ebp]
	mov	eax, DWORD PTR _hMemHandle$[ebp]
	mov	DWORD PTR [edx+60], eax

; 1574 :    lpSockets->sockListen = INVALID_SOCKET;

	mov	ecx, DWORD PTR _lpSockets$[ebp]
	mov	DWORD PTR [ecx+64], -1

; 1575 : 
; 1576 :    return( 0 );

	xor	eax, eax
$LN4@zNetStart:

; 1577 : 
; 1578 : } // zNetStart

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_zNetStart@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_lpSockets$ = -40					; size = 4
_iLen$1 = -36						; size = 4
_pHost$2 = -32						; size = 4
_nTraceLevel$ = -28					; size = 2
_lpConn$3 = -24						; size = 4
_stRmtAddr$4 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
_lpView$ = 8						; size = 4
_ppHandle$ = 12						; size = 4
_ppvConnPtr$ = 16					; size = 4
_cHost$ = 20						; size = 1
_pchHostAddress$ = 24					; size = 4
_zNetGetHostAddress@20 PROC

; 1432 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1433 :    LPSOCKETS    lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 1434 :    zSHORT       nTraceLevel = NetGetTraceLevel( lpView, "zWinSock" );

	push	OFFSET $SG120747
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_NetGetTraceLevel@8
	mov	WORD PTR _nTraceLevel$[ebp], ax

; 1435 : 
; 1436 :    if ( nTraceLevel > 1 )

	movsx	eax, WORD PTR _nTraceLevel$[ebp]
	cmp	eax, 1
	jle	SHORT $LN2@zNetGetHos

; 1437 :       TraceLineS( "(zwinsock) Getting local host address.", "" );

	push	OFFSET $SG120749
	push	OFFSET $SG120750
	call	_TraceLineS@8
$LN2@zNetGetHos:

; 1438 : 
; 1439 :    if ( ppvConnPtr && cHost == 'R' )

	cmp	DWORD PTR _ppvConnPtr$[ebp], 0
	je	$LN3@zNetGetHos
	movsx	ecx, BYTE PTR _cHost$[ebp]
	cmp	ecx, 82					; 00000052H
	jne	$LN3@zNetGetHos

; 1440 :    {
; 1441 :       LPCONNECTION lpConn = (LPCONNECTION) *ppvConnPtr;

	mov	edx, DWORD PTR _ppvConnPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpConn$3[ebp], eax

; 1442 : 
; 1443 :       // Check to see if we've already retrieved the name of the client.
; 1444 :       if ( lpConn->pchPeerName == 0 )

	mov	ecx, DWORD PTR _lpConn$3[ebp]
	cmp	DWORD PTR [ecx+12], 0
	jne	$LN5@zNetGetHos

; 1445 :       {
; 1446 :          socklen_t          iLen;
; 1447 :          PHOSTENT           pHost;
; 1448 :          struct sockaddr_in stRmtAddr;
; 1449 : 
; 1450 :          // Get the host address of the client.
; 1451 :          iLen = sizeof( struct sockaddr );

	mov	DWORD PTR _iLen$1[ebp], 16		; 00000010H

; 1452 :          if ( getpeername( lpConn->sock, (struct sockaddr *) &stRmtAddr,
; 1453 :                            &iLen ) == SOCKET_ERROR )

	lea	edx, DWORD PTR _iLen$1[ebp]
	push	edx
	lea	eax, DWORD PTR _stRmtAddr$4[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConn$3[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_getpeername@12
	cmp	eax, -1
	jne	SHORT $LN6@zNetGetHos

; 1454 :          {
; 1455 :             SHOWERROR( "getpeername" );

	push	OFFSET $SG120755
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1456 :             SysMessageBox( 0, szlErrorTitle, "getpeername() failed", -1 );

	push	-1
	push	OFFSET $SG120756
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1457 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@zNetGetHos
$LN6@zNetGetHos:

; 1458 :          }
; 1459 : 
; 1460 :          pHost = gethostbyaddr( (const char *) &stRmtAddr.sin_addr,

	push	2
	push	4
	lea	eax, DWORD PTR _stRmtAddr$4[ebp+4]
	push	eax
	call	_gethostbyaddr@12
	mov	DWORD PTR _pHost$2[ebp], eax

; 1461 :                                 4, AF_INET );
; 1462 :          if ( pHost == 0 )

	cmp	DWORD PTR _pHost$2[ebp], 0
	jne	SHORT $LN7@zNetGetHos

; 1463 :          {
; 1464 :             SHOWERROR( "gethostbyaddr" );

	push	OFFSET $SG120758
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1465 :             SysMessageBox( 0, szlErrorTitle, "gethostbyaddr() failed", -1 );

	push	-1
	push	OFFSET $SG120759
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1466 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@zNetGetHos
$LN7@zNetGetHos:

; 1467 :          }
; 1468 : 
; 1469 :          // Set up peer name.
; 1470 :          lpConn->hPeerNameMem = (zLONG) malloc( zstrlen( pHost->h_name ) + 1 );

	mov	ecx, DWORD PTR _pHost$2[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _lpConn$3[ebp]
	mov	DWORD PTR [ecx+36], eax

; 1471 :          lpConn->pchPeerName = (zPCHAR) lpConn->hPeerNameMem;

	mov	edx, DWORD PTR _lpConn$3[ebp]
	mov	eax, DWORD PTR _lpConn$3[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+12], ecx

; 1472 :          if ( lpConn->pchPeerName == 0 )

	mov	edx, DWORD PTR _lpConn$3[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN8@zNetGetHos

; 1473 :          {
; 1474 :             SysMessageBox( 0, szlErrorTitle, "Out of memory", -1 );

	push	-1
	push	OFFSET $SG120761
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1475 :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@zNetGetHos
$LN8@zNetGetHos:

; 1476 :          }
; 1477 : 
; 1478 :          zstrcpy( lpConn->pchPeerName, pHost->h_name );

	mov	eax, DWORD PTR _pHost$2[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _lpConn$3[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_strcpy
	add	esp, 8
$LN5@zNetGetHos:

; 1479 :       }
; 1480 : 
; 1481 :       zstrcpy( pchHostAddress, lpConn->pchPeerName );

	mov	ecx, DWORD PTR _lpConn$3[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR _pchHostAddress$[ebp]
	push	eax
	call	_strcpy
	add	esp, 8

; 1482 :    }
; 1483 :    else

	jmp	SHORT $LN4@zNetGetHos
$LN3@zNetGetHos:

; 1484 :    {
; 1485 :       gethostname( pchHostAddress, 300 );

	push	300					; 0000012cH
	mov	ecx, DWORD PTR _pchHostAddress$[ebp]
	push	ecx
	call	_gethostname@8
$LN4@zNetGetHos:

; 1486 : 
; 1487 :       // For non-connections we get the address from the ZEIDON.INI
; 1488 :    // SysReadZeidonIni( -1, "[Zeidon]", "HostAddress", pchHostAddress );
; 1489 :    }
; 1490 : 
; 1491 :    if ( nTraceLevel > 1 )

	movsx	edx, WORD PTR _nTraceLevel$[ebp]
	cmp	edx, 1
	jle	SHORT $LN9@zNetGetHos

; 1492 :       TraceLineS( "(zwinsock) Local host address = ", pchHostAddress );

	mov	eax, DWORD PTR _pchHostAddress$[ebp]
	push	eax
	push	OFFSET $SG120763
	call	_TraceLineS@8
$LN9@zNetGetHos:

; 1493 : 
; 1494 :    return( 0 );

	xor	eax, eax
$LN1@zNetGetHos:

; 1495 : 
; 1496 : } // zStopListen

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_zNetGetHostAddress@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_lpSockets$ = -12					; size = 4
_lSleepCnt$ = -8					; size = 4
_nTraceLevel$ = -4					; size = 2
_lpView$ = 8						; size = 4
_ppHandle$ = 12						; size = 4
_zNetStopListen@8 PROC

; 1344 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1345 :    LPSOCKETS   lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 1346 :    zSHORT      nTraceLevel = NetGetTraceLevel( lpView, "zWinSock" );

	push	OFFSET $SG120711
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_NetGetTraceLevel@8
	mov	WORD PTR _nTraceLevel$[ebp], ax

; 1347 :    zLONG       lSleepCnt;
; 1348 : 
; 1349 :    if ( nTraceLevel > 1 )

	movsx	eax, WORD PTR _nTraceLevel$[ebp]
	cmp	eax, 1
	jle	SHORT $LN4@zNetStopLi

; 1350 :       TraceLineS( "(zwinsock) Stopping listen", "" );

	push	OFFSET $SG120713
	push	OFFSET $SG120714
	call	_TraceLineS@8
$LN4@zNetStopLi:

; 1351 : 
; 1352 :    if ( lpSockets->sockListen == INVALID_SOCKET )

	mov	ecx, DWORD PTR _lpSockets$[ebp]
	cmp	DWORD PTR [ecx+64], -1
	jne	SHORT $LN5@zNetStopLi

; 1353 :    {
; 1354 :       TraceLineS( "(zwinsock) No Listen socket!", "" );

	push	OFFSET $SG120716
	push	OFFSET $SG120717
	call	_TraceLineS@8

; 1355 :       return( 0 ); // return 0 because nothing was done.

	xor	eax, eax
	jmp	$LN1@zNetStopLi
$LN5@zNetStopLi:

; 1356 :    }
; 1357 : 
; 1358 : #ifdef __UNIX__
; 1359 : 
; 1360 :    closesocket( lpSockets->sockListen );
; 1361 : 
; 1362 : #else
; 1363 : 
; 1364 :    // Set a flag indicating that we're closing the socket.  This allows the
; 1365 :    // thread handling the accept() call to ignore the error code returned
; 1366 :    // from accept( ).
; 1367 :    g_bClosingListenSocket = TRUE;

	mov	BYTE PTR ?g_bClosingListenSocket@@3EA, 1 ; g_bClosingListenSocket

; 1368 : 
; 1369 :    if ( closesocket( lpSockets->sockListen ) == SOCKET_ERROR )

	mov	edx, DWORD PTR _lpSockets$[ebp]
	mov	eax, DWORD PTR [edx+64]
	push	eax
	call	_closesocket@4
	cmp	eax, -1
	jne	SHORT $LN6@zNetStopLi

; 1370 :    {
; 1371 :       TraceLineS( "(zwinsock) Error shutting down listen socket", "" );

	push	OFFSET $SG120719
	push	OFFSET $SG120720
	call	_TraceLineS@8

; 1372 :       SHOWERROR( "closesocket" );

	push	OFFSET $SG120721
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1373 :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	SHORT $LN1@zNetStopLi
$LN6@zNetStopLi:

; 1374 :    }
; 1375 : 
; 1376 :    // Now we'll wait until the thread handling the socket is finished.
; 1377 :    lSleepCnt = 0;

	mov	DWORD PTR _lSleepCnt$[ebp], 0
$LN2@zNetStopLi:

; 1378 :    while ( g_bClosingListenSocket )

	movzx	ecx, BYTE PTR ?g_bClosingListenSocket@@3EA ; g_bClosingListenSocket
	test	ecx, ecx
	je	SHORT $LN3@zNetStopLi

; 1379 :    {
; 1380 :       lSleepCnt++;

	mov	edx, DWORD PTR _lSleepCnt$[ebp]
	add	edx, 1
	mov	DWORD PTR _lSleepCnt$[ebp], edx

; 1381 :       if ( lSleepCnt > 10000 )

	cmp	DWORD PTR _lSleepCnt$[ebp], 10000	; 00002710H
	jle	SHORT $LN7@zNetStopLi

; 1382 :       {
; 1383 :          SysMessageBox( 0, szlErrorTitle,

	push	-1
	push	OFFSET $SG120723
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1384 :                         "NetStopListen wait for socket to finish ... TERMINATED", -1 );
; 1385 :          g_bClosingListenSocket = FALSE;

	mov	BYTE PTR ?g_bClosingListenSocket@@3EA, 0 ; g_bClosingListenSocket
$LN7@zNetStopLi:

; 1386 :       }
; 1387 : 
; 1388 :       Sleep( 100 );

	push	100					; 00000064H
	call	DWORD PTR __imp__Sleep@4

; 1389 :    }

	jmp	SHORT $LN2@zNetStopLi
$LN3@zNetStopLi:

; 1390 : #endif
; 1391 : 
; 1392 :    lpSockets->sockListen = INVALID_SOCKET;

	mov	eax, DWORD PTR _lpSockets$[ebp]
	mov	DWORD PTR [eax+64], -1

; 1393 : 
; 1394 :    if ( nTraceLevel > 1 )

	movsx	ecx, WORD PTR _nTraceLevel$[ebp]
	cmp	ecx, 1
	jle	SHORT $LN8@zNetStopLi

; 1395 :       TraceLineS( "(zwinsock) Listen stopped", "" );

	push	OFFSET $SG120725
	push	OFFSET $SG120726
	call	_TraceLineS@8
$LN8@zNetStopLi:

; 1396 : 
; 1397 :    return( 0 );

	xor	eax, eax
$LN1@zNetStopLi:

; 1398 : 
; 1399 : } // zStopListen

	mov	esp, ebp
	pop	ebp
	ret	8
_zNetStopListen@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_LisnInfo$ = -16					; size = 10
_lpSockets$ = -4					; size = 4
_ppHandle$ = 8						; size = 4
_pchAddress$ = 12					; size = 4
_lpView$ = 16						; size = 4
_zNetListen@12 PROC

; 1273 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1274 :    LPSOCKETS         lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 1275 : // struct ListenInfo LisnInfo = { 0 };
; 1276 :    struct ListenInfo LisnInfo;
; 1277 : 
; 1278 :    // Set up info we need to pass to new thread.
; 1279 :    LisnInfo.hTask = lpView->hTask;

	mov	edx, DWORD PTR _lpView$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _LisnInfo$[ebp], eax

; 1280 :    LisnInfo.lpSockets = lpSockets;

	mov	ecx, DWORD PTR _lpSockets$[ebp]
	mov	DWORD PTR _LisnInfo$[ebp+4], ecx

; 1281 :    LisnInfo.nRC = 0;

	xor	edx, edx
	mov	WORD PTR _LisnInfo$[ebp+8], dx

; 1282 :    g_bListenThreadStarted = FALSE;

	mov	BYTE PTR ?g_bListenThreadStarted@@3EA, 0 ; g_bListenThreadStarted

; 1283 : 
; 1284 : #ifdef __UNIX__
; 1285 : 
; 1286 :    zSHORT      nTraceLevel = NetGetTraceLevel( lpView, "zwinsock" );
; 1287 :    pthread_t   NewThread;
; 1288 : 
; 1289 :    if ( nTraceLevel > 1 )
; 1290 :    {
; 1291 :       TraceLineS( "(zwinsock) Starting listen", "" );
; 1292 :    }
; 1293 : 
; 1294 :    // Create a thread to perform the listen.  This keeps the current
; 1295 :    // thread from being blocked.
; 1296 :    if ( pthread_create( &NewThread, 0, fnListenThreadProc, &LisnInfo ) != 0 )
; 1297 :    {
; 1298 :       TraceLineS( "Error starting Listen thread", "" );
; 1299 :       return( zCALL_ERROR );
; 1300 :    }
; 1301 : 
; 1302 :    TraceLineI( "Thread created = ", NewThread );
; 1303 : 
; 1304 :    lpSockets->tidListen = NewThread;
; 1305 : 
; 1306 : #else
; 1307 : 
; 1308 :    // Start up a thread to create the socket and wait for connections.
; 1309 :    g_hListenThread = _beginthreadex( 0, 0,  // security, stacksize

	push	OFFSET ?g_dwListenThreadID@@3IA		; g_dwListenThreadID
	push	0
	lea	eax, DWORD PTR _LisnInfo$[ebp]
	push	eax
	push	OFFSET _fnListenThreadProc@4
	push	0
	push	0
	call	DWORD PTR __imp___beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR ?g_hListenThread@@3KA, eax	; g_hListenThread

; 1310 :                                      fnListenThreadProc,
; 1311 :                                      (zPVOID) &LisnInfo, 0, // arglist, initflag
; 1312 :                                      &g_dwListenThreadID );
; 1313 :    if ( g_hListenThread )

	cmp	DWORD PTR ?g_hListenThread@@3KA, 0	; g_hListenThread
	je	SHORT $LN2@zNetListen

; 1314 :       CloseHandle( (HANDLE) g_hListenThread );

	mov	ecx, DWORD PTR ?g_hListenThread@@3KA	; g_hListenThread
	push	ecx
	call	DWORD PTR __imp__CloseHandle@4
$LN2@zNetListen:

; 1315 : 
; 1316 : #endif
; 1317 : 
; 1318 :    // Now wait until the thread has finished its initialization.
; 1319 :    while ( g_bListenThreadStarted == FALSE )

	movzx	edx, BYTE PTR ?g_bListenThreadStarted@@3EA ; g_bListenThreadStarted
	test	edx, edx
	jne	SHORT $LN3@zNetListen

; 1320 :       Sleep( 10 );

	push	10					; 0000000aH
	call	DWORD PTR __imp__Sleep@4
	jmp	SHORT $LN2@zNetListen
$LN3@zNetListen:

; 1321 : 
; 1322 :    return( LisnInfo.nRC );

	mov	ax, WORD PTR _LisnInfo$[ebp+8]

; 1323 : 
; 1324 : } // zNetListen

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_zNetListen@12 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_dwThreadID$1 = -92					; size = 4
$T2 = -88						; size = 4
$T3 = -84						; size = 4
$T4 = -80						; size = 4
_hTask$ = -76						; size = 4
$T5 = -72						; size = 4
_nTraceLevel$ = -68					; size = 2
_vSubtask$ = -64					; size = 4
_hConnThread$6 = -60					; size = 4
_nRet$ = -56						; size = 4
_lpListenInfo$ = -52					; size = 4
_pSockTask$ = -48					; size = 4
_listenSocket$ = -44					; size = 4
_saServer$ = -40					; size = 16
_szPort$ = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_fnListenThreadProc@4 PROC

; 1073 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 1074 :    zSHORT       nTraceLevel = 1; // NetGetTraceLevel( lpView, "zWinSock" );

	mov	eax, 1
	mov	WORD PTR _nTraceLevel$[ebp], ax

; 1075 :    char         szPort[ 20 ];
; 1076 :    LPLISTENINFO lpListenInfo = (LPLISTENINFO) p;

	mov	ecx, DWORD PTR _p$[ebp]
	mov	DWORD PTR _lpListenInfo$[ebp], ecx

; 1077 :    zVIEW        vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 1078 : // SOCKET       NewSocket;
; 1079 :    LPTASK       hTask = lpListenInfo->hTask;

	mov	edx, DWORD PTR _lpListenInfo$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _hTask$[ebp], eax

; 1080 : 
; 1081 : #ifdef __UNIX__
; 1082 : 
; 1083 :    if ( RegisterZeidonApplication( &vSubtask, 0, 0, 0,
; 1084 :                                    "\\\\Zeidon System\\", 0, 0 ) != 0 )
; 1085 :    {
; 1086 :       TraceLineS( "ERROR Registering app ERROR", "" );
; 1087 :       return( 0 );
; 1088 :    }
; 1089 : 
; 1090 :    TraceLineI( "New thread task id = ", SysGetTaskID( ) );
; 1091 : 
; 1092 : #endif
; 1093 : 
; 1094 :    // We'll assume that we return an error until proven otherwise.
; 1095 :    lpListenInfo->nRC = zCALL_ERROR;

	mov	ecx, -16				; fffffff0H
	mov	edx, DWORD PTR _lpListenInfo$[ebp]
	mov	WORD PTR [edx+8], cx

; 1096 : 
; 1097 :    // Get port number.
; 1098 :    if ( g_nListenPort == -1 )

	movsx	eax, WORD PTR _g_nListenPort
	cmp	eax, -1
	jne	SHORT $LN4@fnListenTh

; 1099 :    {
; 1100 :       SysReadZeidonIni( -1, "[zWinSock]", "ListenPort", szPort );

	lea	ecx, DWORD PTR _szPort$[ebp]
	push	ecx
	push	OFFSET $SG120663
	push	OFFSET $SG120664
	push	-1
	call	_SysReadZeidonIni@16

; 1101 :       g_nListenPort = (short) zatol( szPort );

	lea	edx, DWORD PTR _szPort$[ebp]
	push	edx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _g_nListenPort, ax
$LN4@fnListenTh:

; 1102 :    }
; 1103 : 
; 1104 :    //
; 1105 :    // Create a TCP/IP stream socket to "listen" with
; 1106 :    //
; 1107 :    SOCKET  listenSocket;
; 1108 : 
; 1109 :    listenSocket = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );

	push	6
	push	1
	push	2
	call	_socket@12
	mov	DWORD PTR _listenSocket$[ebp], eax

; 1110 :    if ( listenSocket == INVALID_SOCKET )

	cmp	DWORD PTR _listenSocket$[ebp], -1
	jne	SHORT $LN5@fnListenTh

; 1111 :    {
; 1112 :       SHOWERROR( "socket" );

	push	OFFSET $SG120666
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1113 :       SysMessageBox( 0, szlErrorTitle, "socket() failed", -1 );

	push	-1
	push	OFFSET $SG120667
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1114 : 
; 1115 :       g_bListenThreadStarted = TRUE;

	mov	BYTE PTR ?g_bListenThreadStarted@@3EA, 1 ; g_bListenThreadStarted

; 1116 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnListenTh
$LN5@fnListenTh:

; 1117 :    }
; 1118 : 
; 1119 :    //
; 1120 :    // Fill in the address structure
; 1121 :    //
; 1122 :    SOCKADDR_IN saServer;
; 1123 : 
; 1124 :    saServer.sin_family = AF_INET;

	mov	eax, 2
	mov	WORD PTR _saServer$[ebp], ax

; 1125 :    saServer.sin_addr.s_addr = INADDR_ANY;  // Let WinSock supply address

	mov	DWORD PTR _saServer$[ebp+4], 0

; 1126 :    saServer.sin_port = htons( (short) g_nListenPort );

	movzx	ecx, WORD PTR _g_nListenPort
	push	ecx
	call	_htons@4
	mov	WORD PTR _saServer$[ebp+2], ax

; 1127 : 
; 1128 :    //
; 1129 :    // bind the name to the socket
; 1130 :    //
; 1131 :    int nRet;
; 1132 : 
; 1133 :    nRet = bind( listenSocket, (PSOCKADDR) &saServer, sizeof( struct sockaddr ) );

	push	16					; 00000010H
	lea	edx, DWORD PTR _saServer$[ebp]
	push	edx
	mov	eax, DWORD PTR _listenSocket$[ebp]
	push	eax
	call	_bind@12
	mov	DWORD PTR _nRet$[ebp], eax

; 1134 :    if ( nRet == SOCKET_ERROR )

	cmp	DWORD PTR _nRet$[ebp], -1
	jne	SHORT $LN6@fnListenTh

; 1135 :    {
; 1136 :       SHOWERROR( "bind" );

	push	OFFSET $SG120669
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1137 :       SysMessageBox( 0, szlErrorTitle, "bind() failed", -1 );

	push	-1
	push	OFFSET $SG120670
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1138 :       g_bListenThreadStarted = TRUE;

	mov	BYTE PTR ?g_bListenThreadStarted@@3EA, 1 ; g_bListenThreadStarted

; 1139 :       closesocket( listenSocket );

	mov	ecx, DWORD PTR _listenSocket$[ebp]
	push	ecx
	call	_closesocket@4

; 1140 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnListenTh
$LN6@fnListenTh:

; 1141 :    }
; 1142 : 
; 1143 :    nRet = listen( listenSocket, MAX_PENDING_CONNECTS );

	push	16					; 00000010H
	mov	edx, DWORD PTR _listenSocket$[ebp]
	push	edx
	call	_listen@8
	mov	DWORD PTR _nRet$[ebp], eax

; 1144 :    if ( nRet == SOCKET_ERROR )

	cmp	DWORD PTR _nRet$[ebp], -1
	jne	SHORT $LN7@fnListenTh

; 1145 :    {
; 1146 :       SHOWERROR( "listen" );

	push	OFFSET $SG120672
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1147 :       SysMessageBox( 0, szlErrorTitle, "listen() failed", -1 );

	push	-1
	push	OFFSET $SG120673
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1148 :       g_bListenThreadStarted = TRUE;

	mov	BYTE PTR ?g_bListenThreadStarted@@3EA, 1 ; g_bListenThreadStarted

; 1149 :       closesocket( listenSocket );

	mov	eax, DWORD PTR _listenSocket$[ebp]
	push	eax
	call	_closesocket@4

; 1150 :       return( 0 );

	xor	eax, eax
	jmp	$LN1@fnListenTh
$LN7@fnListenTh:

; 1151 :    }
; 1152 : 
; 1153 :    // Listen started OK so set return.
; 1154 :    lpListenInfo->nRC = 0;

	xor	ecx, ecx
	mov	edx, DWORD PTR _lpListenInfo$[ebp]
	mov	WORD PTR [edx+8], cx

; 1155 :    lpListenInfo->lpSockets->sockListen = listenSocket;

	mov	eax, DWORD PTR _lpListenInfo$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	edx, DWORD PTR _listenSocket$[ebp]
	mov	DWORD PTR [ecx+64], edx

; 1156 : 
; 1157 :    // At this point everything's good so let's start waiting for connections.
; 1158 :    // Setting this flag allow the parent thread to continue.
; 1159 :    g_bListenThreadStarted = TRUE;

	mov	BYTE PTR ?g_bListenThreadStarted@@3EA, 1 ; g_bListenThreadStarted

; 1160 : 
; 1161 :    TraceLineS( "(zWinSock) Waiting for client connections...", "" );

	push	OFFSET $SG120674
	push	OFFSET $SG120675
	call	_TraceLineS@8
$LN2@fnListenTh:

; 1162 : 
; 1163 :    zSOCKTASK    *pSockTask;
; 1164 : 
; 1165 :    // Loop until we the listen socket is closed.
; 1166 :    while ( TRUE )

	mov	eax, 1
	test	eax, eax
	je	$LN3@fnListenTh

; 1167 :    {
; 1168 :       if ( g_bClosingListenSocket )

	movzx	ecx, BYTE PTR ?g_bClosingListenSocket@@3EA ; g_bClosingListenSocket
	test	ecx, ecx
	je	SHORT $LN8@fnListenTh

; 1169 :          TraceLineS( "fnListenThreadProc trying to close ListenSocket", "" );

	push	OFFSET $SG120677
	push	OFFSET $SG120678
	call	_TraceLineS@8
$LN8@fnListenTh:

; 1170 : 
; 1171 : #ifdef __UNIX__x
; 1172 :       fd_set         ready;
; 1173 :       struct timeval sTimeVal;
; 1174 : 
; 1175 :       // Call select() to see if there are any connections waiting.
; 1176 :       FD_ZERO( &ready );
; 1177 :       FD_SET( listenSocket, &ready );
; 1178 : 
; 1179 :       if ( select( listenSocket + 1, &ready, 0, 0, 0 ) < 0 )
; 1180 :       {
; 1181 :          SHOWERROR( "select" );
; 1182 :          break;
; 1183 :       }
; 1184 : 
; 1185 :       // If socket doesn't have any connections waiting, then continue loop.
; 1186 :       if ( !FD_ISSET( listenSocket, &ready ) )
; 1187 :          continue;
; 1188 : #endif
; 1189 : 
; 1190 :       // On a successful connection, fnProcessConnectionThreadProc is
; 1191 :       // responsible for deleting pSockTask!
; 1192 :       pSockTask = new zSOCKTASK;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	mov	edx, DWORD PTR $T5[ebp]
	mov	DWORD PTR _pSockTask$[ebp], edx

; 1193 :       pSockTask->hTask = hTask;

	mov	eax, DWORD PTR _pSockTask$[ebp]
	mov	ecx, DWORD PTR _hTask$[ebp]
	mov	DWORD PTR [eax], ecx

; 1194 :       pSockTask->sock = accept( listenSocket, 0, 0 );

	push	0
	push	0
	mov	edx, DWORD PTR _listenSocket$[ebp]
	push	edx
	call	_accept@12
	mov	ecx, DWORD PTR _pSockTask$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 1195 :       if ( pSockTask->sock == INVALID_SOCKET )

	mov	edx, DWORD PTR _pSockTask$[ebp]
	cmp	DWORD PTR [edx+4], -1
	jne	SHORT $LN9@fnListenTh

; 1196 :       {
; 1197 :          // It's possible we received the error because the socket was closed
; 1198 :          // by another thread.  In this case we'll ignore the error and just
; 1199 :          // return.
; 1200 :          if ( g_bClosingListenSocket )

	movzx	eax, BYTE PTR ?g_bClosingListenSocket@@3EA ; g_bClosingListenSocket
	test	eax, eax
	je	SHORT $LN10@fnListenTh

; 1201 :          {
; 1202 :             // Turn the flag back off so we can re-use it.  This also tells
; 1203 :             // the closing thread that we're done.
; 1204 :             g_bClosingListenSocket = FALSE;

	mov	BYTE PTR ?g_bClosingListenSocket@@3EA, 0 ; g_bClosingListenSocket

; 1205 :             delete( pSockTask );

	mov	ecx, DWORD PTR _pSockTask$[ebp]
	mov	DWORD PTR $T4[ebp], ecx
	push	8
	mov	edx, DWORD PTR $T4[ebp]
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 1206 :             return( 0 );

	xor	eax, eax
	jmp	$LN1@fnListenTh
$LN10@fnListenTh:

; 1207 :          }
; 1208 : 
; 1209 :          SHOWERROR( "accept" );

	push	OFFSET $SG120681
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 1210 :          SysMessageBox( 0, szlErrorTitle, "accept(sock) failed for listen", -1 );

	push	-1
	push	OFFSET $SG120682
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1211 :          closesocket( listenSocket );

	mov	eax, DWORD PTR _listenSocket$[ebp]
	push	eax
	call	_closesocket@4

; 1212 :          delete( pSockTask );

	mov	ecx, DWORD PTR _pSockTask$[ebp]
	mov	DWORD PTR $T3[ebp], ecx
	push	8
	mov	edx, DWORD PTR $T3[ebp]
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 1213 :          return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@fnListenTh
$LN9@fnListenTh:

; 1214 :       }
; 1215 : 
; 1216 :       // Fire off another thread to handle this connection.
; 1217 : #ifdef __UNIX__
; 1218 :       pthread_t NewThread;
; 1219 : 
; 1220 :       if ( pthread_create( &NewThread, 0, fnProcessConnectionThreadProc,
; 1221 :                            (zPVOID) pSockTask ) != 0 )
; 1222 :       {
; 1223 :          TraceLineS( "Error starting process connection thread", "" );
; 1224 :          delete( pSockTask );
; 1225 :          return( 0 );
; 1226 :       }
; 1227 : 
; 1228 :       TraceLineI( "Thread created = ", NewThread );
; 1229 : 
; 1230 : #else
; 1231 :       HANDLE hConnThread;
; 1232 :       UINT   dwThreadID;
; 1233 : 
; 1234 :       hConnThread = (HANDLE) _beginthreadex( 0, 0,  // security, stacksize,

	lea	eax, DWORD PTR _dwThreadID$1[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _pSockTask$[ebp]
	push	ecx
	push	OFFSET _fnProcessConnectionThreadProc@4
	push	0
	push	0
	call	DWORD PTR __imp___beginthreadex
	add	esp, 24					; 00000018H
	mov	DWORD PTR _hConnThread$6[ebp], eax

; 1235 :                                              fnProcessConnectionThreadProc, // start address
; 1236 :                                              (zPVOID) pSockTask, 0,  // arglist, initial state
; 1237 :                                              &dwThreadID );  // thread identifier
; 1238 :       if ( hConnThread )

	cmp	DWORD PTR _hConnThread$6[ebp], 0
	je	SHORT $LN11@fnListenTh

; 1239 :          CloseHandle( (HANDLE) hConnThread );

	mov	edx, DWORD PTR _hConnThread$6[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4

; 1240 :       else

	jmp	SHORT $LN12@fnListenTh
$LN11@fnListenTh:

; 1241 :          delete( pSockTask );

	mov	eax, DWORD PTR _pSockTask$[ebp]
	mov	DWORD PTR $T2[ebp], eax
	push	8
	mov	ecx, DWORD PTR $T2[ebp]
	push	ecx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@fnListenTh:

; 1242 : #endif
; 1243 : 
; 1244 :    } // while ( TRUE )...

	jmp	$LN2@fnListenTh
$LN3@fnListenTh:

; 1245 : 
; 1246 :    if ( vSubtask )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $LN13@fnListenTh

; 1247 :       UnregisterZeidonApplication( vSubtask );

	mov	edx, DWORD PTR _vSubtask$[ebp]
	push	edx
	call	_UnregisterZeidonApplication@4
$LN13@fnListenTh:

; 1248 : 
; 1249 :    return( 0 );

	xor	eax, eax
$LN1@fnListenTh:

; 1250 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnListenThreadProc@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_lBlockOff$ = -164					; size = 4
_lpTask$ = -160						; size = 4
_cr$ = -156						; size = 43
_sock$ = -112						; size = 4
_pp$ = -108						; size = 4
$T1 = -104						; size = 4
_pv$ = -100						; size = 4
_pSockTask$ = -96					; size = 4
_nRC$ = -92						; size = 2
_vSubtask$ = -88					; size = 4
_szBuf$2 = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
_fnProcessConnectionThreadProc@4 PROC

; 944  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 945  :    LPSOCKTASK         pSockTask = (LPSOCKTASK) p;

	mov	eax, DWORD PTR _p$[ebp]
	mov	DWORD PTR _pSockTask$[ebp], eax

; 946  : // LPTASK             lpTask = (LPTASK) zGETPTR( pSockTask->hTask );
; 947  :    LPTASK             lpTask = (LPTASK) SysGetPointerFromHandle( pSockTask->hTask );

	mov	ecx, DWORD PTR _pSockTask$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_SysGetPointerFromHandle@4
	mov	DWORD PTR _lpTask$[ebp], eax

; 948  :    SOCKET             sock = pSockTask->sock;

	mov	eax, DWORD PTR _pSockTask$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _sock$[ebp], ecx

; 949  :    zVIEW              vSubtask = 0;

	mov	DWORD PTR _vSubtask$[ebp], 0

; 950  :    long               lBlockOff = FALSE;

	mov	DWORD PTR _lBlockOff$[ebp], 0

; 951  :    zPVOID             pv;
; 952  :    ConnectionRecord   cr = { 0 };

	mov	DWORD PTR _cr$[ebp], 0
	push	39					; 00000027H
	push	0
	lea	edx, DWORD PTR _cr$[ebp+4]
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH

; 953  :    zSHORT             nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 954  :    zPVOID pp = 0;  // debug code

	mov	DWORD PTR _pp$[ebp], 0

; 955  : 
; 956  :    delete( pSockTask );

	mov	ecx, DWORD PTR _pSockTask$[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	push	8
	mov	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 957  : 
; 958  : #ifdef __WIN32__
; 959  :    static HANDLE      hMutexObject = 0;
; 960  :    static int         DoSync = 0;
; 961  :    // Valid values for DoSync:  0 = zeidon.ini not read yet
; 962  :    //                          -1 = dont use sync mechanisms
; 963  :    //                           1 = use sync Mechanism (Mutex)
; 964  : 
; 965  :    if ( DoSync == 0 )

	cmp	DWORD PTR ?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA, 0
	jne	SHORT $LN2@fnProcessC

; 966  :    {
; 967  :       char szBuf[ 80 ];
; 968  : 
; 969  :       SysReadZeidonIni( -1, "[zWinSock]", "SyncServerAccess", szBuf );

	lea	eax, DWORD PTR _szBuf$2[ebp]
	push	eax
	push	OFFSET $SG120609
	push	OFFSET $SG120610
	push	-1
	call	_SysReadZeidonIni@16

; 970  :       DoSync = atoi( szBuf );

	lea	ecx, DWORD PTR _szBuf$2[ebp]
	push	ecx
	call	DWORD PTR __imp__atoi
	add	esp, 4
	mov	DWORD PTR ?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA, eax

; 971  :       if ( DoSync == 0 )

	cmp	DWORD PTR ?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA, 0
	jne	SHORT $LN2@fnProcessC

; 972  :          DoSync = -1;   // atoi returns 0 if string was empty

	mov	DWORD PTR ?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA, -1
$LN2@fnProcessC:

; 973  :    }
; 974  : 
; 975  :    if ( DoSync > 0 )

	cmp	DWORD PTR ?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA, 0
	jle	SHORT $LN4@fnProcessC

; 976  :    {
; 977  :       if ( hMutexObject == 0 )

	cmp	DWORD PTR ?hMutexObject@?1??fnProcessConnectionThreadProc@@9@4@4PAXA, 0
	jne	SHORT $LN5@fnProcessC

; 978  :          hMutexObject = CreateMutex( 0, FALSE, "WINSOCK_WORKAROUND" );

	push	OFFSET $SG120614
	push	0
	push	0
	call	DWORD PTR __imp__CreateMutexA@12
	mov	DWORD PTR ?hMutexObject@?1??fnProcessConnectionThreadProc@@9@4@4PAXA, eax
$LN5@fnProcessC:

; 979  : 
; 980  :       if ( hMutexObject == 0 )

	cmp	DWORD PTR ?hMutexObject@?1??fnProcessConnectionThreadProc@@9@4@4PAXA, 0
	jne	SHORT $LN6@fnProcessC

; 981  :          goto EndOfFunction;

	jmp	$EndOfFunction$16
	jmp	$EndOfFunction$16
$LN6@fnProcessC:

; 982  : 
; 983  :       WaitForSingleObject( hMutexObject, INFINITE );

	push	-1
	mov	edx, DWORD PTR ?hMutexObject@?1??fnProcessConnectionThreadProc@@9@4@4PAXA
	push	edx
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN4@fnProcessC:

; 984  :    }
; 985  : #else
; 986  :    TraceLineI( "New thread task id = ", SysGetTaskID( ) );
; 987  : #endif
; 988  : 
; 989  :    if ( RegisterZeidonApplication( &vSubtask, 0, 0, 0,
; 990  :                                    "\\\\Zeidon System\\", 0, 0 ) != 0 )

	push	0
	push	0
	push	OFFSET $SG120618
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_RegisterZeidonApplication@28
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN8@fnProcessC

; 991  :       goto EndOfFunction;

	jmp	$EndOfFunction$16
	jmp	$EndOfFunction$16
$LN8@fnProcessC:

; 992  : 
; 993  :    // Debug code - do a quick test to make sure that vSubtask is a valid
; 994  :    // pointer.
; 995  :    pp = (zPVOID) vSubtask->hTask;

	mov	edx, DWORD PTR _vSubtask$[ebp]
	mov	eax, DWORD PTR [edx+14]
	mov	DWORD PTR _pp$[ebp], eax

; 996  : 
; 997  :    // Set up a buffer to receive network traffic.
; 998  :    cr.hBufferMem = (zLONG) malloc( BUFFER_LTH );

	push	32000					; 00007d00H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _cr$[ebp+32], eax

; 999  :    cr.pchBuffer = (zPCHAR) cr.hBufferMem;

	mov	ecx, DWORD PTR _cr$[ebp+32]
	mov	DWORD PTR _cr$[ebp+4], ecx

; 1000 :    if ( cr.pchBuffer == 0 )

	cmp	DWORD PTR _cr$[ebp+4], 0
	jne	SHORT $LN10@fnProcessC

; 1001 :    {
; 1002 :       SysMessageBox( 0, szlErrorTitle, "Out of memory", -1 );

	push	-1
	push	OFFSET $SG120621
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 1003 :       goto EndOfFunction;

	jmp	SHORT $EndOfFunction$16
	jmp	SHORT $EndOfFunction$16
$LN10@fnProcessC:

; 1004 :    }
; 1005 : 
; 1006 :    // Init connection info.
; 1007 :    cr.sock        = sock;

	mov	edx, DWORD PTR _sock$[ebp]
	mov	DWORD PTR _cr$[ebp], edx

; 1008 :    cr.ulBufferLth = BUFFER_LTH;

	mov	DWORD PTR _cr$[ebp+20], 32000		; 00007d00H

; 1009 :    cr.pchNextByte = cr.pchBuffer;

	mov	eax, DWORD PTR _cr$[ebp+4]
	mov	DWORD PTR _cr$[ebp+8], eax

; 1010 :    cr.ulUnusedLth = 0;

	mov	DWORD PTR _cr$[ebp+16], 0

; 1011 :    cr.nTraceLevel = NetGetTraceLevel( vSubtask, "zWinSock" );

	push	OFFSET $SG120623
	mov	ecx, DWORD PTR _vSubtask$[ebp]
	push	ecx
	call	_NetGetTraceLevel@8
	mov	WORD PTR _cr$[ebp+40], ax

; 1012 : 
; 1013 :    if ( cr.nTraceLevel > 0 )

	movsx	edx, WORD PTR _cr$[ebp+40]
	test	edx, edx
	jle	SHORT $LN12@fnProcessC

; 1014 :       TraceLineS( "(zwinsock) A message has been received from ",

	mov	eax, DWORD PTR _cr$[ebp+12]
	push	eax
	push	OFFSET $SG120625
	call	_TraceLineS@8
$LN12@fnProcessC:

; 1015 :                   cr.pchPeerName );
; 1016 : 
; 1017 :    pv = &cr;

	lea	ecx, DWORD PTR _cr$[ebp]
	mov	DWORD PTR _pv$[ebp], ecx

; 1018 : 
; 1019 :    // If the trace level is > 0 then we'll call Core without a try block so
; 1020 :    // that we can catch crashes in the debugger.
; 1021 :    // In the production environment, TraceLevel should be set to zero so
; 1022 :    // that the errors will be handled and processing will continue.
; 1023 : #if 1
; 1024 :    nRC = NetProcessMessage( vSubtask, "zWinSock", &pv );

	lea	edx, DWORD PTR _pv$[ebp]
	push	edx
	push	OFFSET $SG120626
	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_NetProcessMessage@12
	mov	WORD PTR _nRC$[ebp], ax
$EndOfFunction$16:

; 1025 : #else
; 1026 :    if ( cr.nTraceLevel > 0 )
; 1027 :       nRC = NetProcessMessage( vSubtask, "zWinSock", &pv );
; 1028 :    else
; 1029 :    {
; 1030 :       try
; 1031 :       {
; 1032 :          nRC = NetProcessMessage( vSubtask, "zWinSock", &pv );
; 1033 :       }
; 1034 :       catch ( ... )
; 1035 :       {
; 1036 :          zCHAR szMsg[ 200 ];
; 1037 :          zCHAR szDateTime[ 50 ];
; 1038 :          zCHAR szSysDateTime[ 30 ];
; 1039 : 
; 1040 :          SysGetDateTime( szSysDateTime );
; 1041 :          UfFormatDateTime( szDateTime, szSysDateTime, "YYYY-MM-DD HH:MI:SS" );
; 1042 :          zsprintf( szMsg, "(%s) Client %s created an exception in NetProcessMessage",
; 1043 :                    szDateTime, cr.pchPeerName );
; 1044 :          TraceLineS( "EXCEPTION >>>>>>>>>>>>>>>>>>>>>>>> zWinsock: ", szMsg );
; 1045 :       // SysMessageBox( 0, "Exception in zWinsock", szMsg, -1 );
; 1046 :       }
; 1047 :    }
; 1048 : #endif
; 1049 : 
; 1050 : EndOfFunction:
; 1051 : 
; 1052 :    // Close the connection
; 1053 :    zNetCloseConnection( (zPPVOID) &pv, (zPPVOID) &pv );

	lea	ecx, DWORD PTR _pv$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pv$[ebp]
	push	edx
	call	_zNetCloseConnection@8

; 1054 : 
; 1055 :    if ( vSubtask )

	cmp	DWORD PTR _vSubtask$[ebp], 0
	je	SHORT $LN13@fnProcessC

; 1056 :       UnregisterZeidonApplication( vSubtask );

	mov	eax, DWORD PTR _vSubtask$[ebp]
	push	eax
	call	_UnregisterZeidonApplication@4
$LN13@fnProcessC:

; 1057 : 
; 1058 :    #ifdef __WIN32__
; 1059 :       if ( DoSync > 0 )

	cmp	DWORD PTR ?DoSync@?1??fnProcessConnectionThreadProc@@9@4@4HA, 0
	jle	SHORT $LN14@fnProcessC

; 1060 :          ReleaseMutex( hMutexObject );

	mov	ecx, DWORD PTR ?hMutexObject@?1??fnProcessConnectionThreadProc@@9@4@4PAXA
	push	ecx
	call	DWORD PTR __imp__ReleaseMutex@4
$LN14@fnProcessC:

; 1061 :    #endif
; 1062 : 
; 1063 :    return( 0 );

	xor	eax, eax

; 1064 : 
; 1065 : } // fnProcessConnectionThreadProc

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_fnProcessConnectionThreadProc@4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_lpSockets$ = -8					; size = 4
_lpConn$ = -4						; size = 4
_ppHandle$ = 8						; size = 4
_ppvConnPtr$ = 12					; size = 4
_zNetCloseConnection@8 PROC

; 889  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 890  :    LPSOCKETS      lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 891  :    LPCONNECTION   lpConn = (LPCONNECTION) *ppvConnPtr;

	mov	edx, DWORD PTR _ppvConnPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpConn$[ebp], eax

; 892  : 
; 893  :    // Check the flag to see if the last send/receive command was a send.  If
; 894  :    // the last command was a send, then the send buffer might need to be
; 895  :    // flushed.
; 896  :    if ( lpConn )

	cmp	DWORD PTR _lpConn$[ebp], 0
	je	$LN2@zNetCloseC

; 897  :    {
; 898  :       if ( lpConn->bLastReceive == FALSE )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movzx	edx, BYTE PTR [ecx+42]
	test	edx, edx
	jne	SHORT $LN3@zNetCloseC

; 899  :       {
; 900  :          zNetSend( ppHandle, ppvConnPtr, 0, 0, 0 );

	push	0
	push	0
	push	0
	mov	eax, DWORD PTR _ppvConnPtr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppHandle$[ebp]
	push	ecx
	call	_zNetSend@20

; 901  : 
; 902  :          if ( lpConn->nTraceLevel > 0 && lpConn->ulTotalBytes > 0 )

	mov	edx, DWORD PTR _lpConn$[ebp]
	movsx	eax, WORD PTR [edx+40]
	test	eax, eax
	jle	SHORT $LN5@zNetCloseC
	mov	ecx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [ecx+24], 0
	jbe	SHORT $LN5@zNetCloseC

; 903  :             TraceLineI( "(zwinsock) Total bytes sent = ", lpConn->ulTotalBytes );

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	push	OFFSET $SG120547
	call	_TraceLineI@8
$LN5@zNetCloseC:

; 904  :       }
; 905  :       else

	jmp	SHORT $LN4@zNetCloseC
$LN3@zNetCloseC:

; 906  :       {
; 907  :          if ( lpConn->nTraceLevel > 0 && lpConn->ulTotalBytes > 0 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	test	edx, edx
	jle	SHORT $LN4@zNetCloseC
	mov	eax, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [eax+24], 0
	jbe	SHORT $LN4@zNetCloseC

; 908  :             TraceLineI( "(zwinsock) Total bytes received = ", lpConn->ulTotalBytes );

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	push	OFFSET $SG120549
	call	_TraceLineI@8
$LN4@zNetCloseC:

; 909  :       }
; 910  : 
; 911  :       if ( closesocket( lpConn->sock ) == SOCKET_ERROR )

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_closesocket@4
	cmp	eax, -1
	jne	SHORT $LN7@zNetCloseC

; 912  :          SHOWERROR( "closesocket" );

	push	OFFSET $SG120551
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4
$LN7@zNetCloseC:

; 913  : 
; 914  :       free( (zPVOID) lpConn->hBufferMem );

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 915  :       free( (zPVOID) lpConn->hPeerNameMem );

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+36]
	push	edx
	call	DWORD PTR __imp__free
	add	esp, 4

; 916  :       free( (zPVOID) lpConn->hMemHandle );

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4

; 917  : 
; 918  :       *ppvConnPtr = 0;

	mov	edx, DWORD PTR _ppvConnPtr$[ebp]
	mov	DWORD PTR [edx], 0
$LN2@zNetCloseC:

; 919  :    }
; 920  : 
; 921  :    return( 0 );

	xor	eax, eax

; 922  : 
; 923  : } // zNetCloseConnection

	mov	esp, ebp
	pop	ebp
	ret	8
_zNetCloseConnection@8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_lpSockets$ = -1736					; size = 4
_lBlockOff$ = -1732					; size = 4
_lStart$1 = -1728					; size = 4
_lEnd$2 = -1724						; size = 4
_lStart$3 = -1720					; size = 4
_lEnd$4 = -1716						; size = 4
_hMem$ = -1712						; size = 4
_pHost$ = -1708						; size = 4
_DestSocket$ = -1704					; size = 4
_pch$ = -1700						; size = 4
_sock$ = -1696						; size = 4
_nPort$ = -1692						; size = 2
_nRC$ = -1688						; size = 2
_lpConn$ = -1684					; size = 4
_szMsg$5 = -1680					; size = 500
_szMsg$6 = -1180					; size = 500
_sz$7 = -680						; size = 200
_sz$8 = -480						; size = 200
_szServerAddress$ = -280				; size = 256
_szPort$9 = -24						; size = 20
__$ArrayPad$ = -4					; size = 4
_ppHandle$ = 8						; size = 4
_ppvConnPtr$ = 12					; size = 4
_pchAddress$ = 16					; size = 4
_lpView$ = 20						; size = 4
_zNetOpenConnection@16 PROC

; 644  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1736				; 000006c8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 645  :    LPSOCKETS      lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 646  :    LPCONNECTION   lpConn;
; 647  :    SOCKET         sock = INVALID_SOCKET;

	mov	DWORD PTR _sock$[ebp], -1

; 648  :    SOCKADDR_IN    *DestSocket;
; 649  :    PHOSTENT       pHost;
; 650  :    zCHAR          szServerAddress[ 256 ];
; 651  :    zPCHAR         pch;
; 652  :    zLONG          hMem;
; 653  :    u_long         lBlockOff = 0;

	mov	DWORD PTR _lBlockOff$[ebp], 0

; 654  :    u_short        nPort;
; 655  :    zSHORT         nRC = zCALL_ERROR;

	mov	edx, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], dx

; 656  : 
; 657  :    // Set up a buffer to receive network traffic.
; 658  :    hMem = (zLONG) calloc( 1, sizeof( ConnectionRecord ) );

	push	43					; 0000002bH
	push	1
	call	DWORD PTR __imp__calloc
	add	esp, 8
	mov	DWORD PTR _hMem$[ebp], eax

; 659  :    lpConn = (LPCONNECTION) hMem;

	mov	eax, DWORD PTR _hMem$[ebp]
	mov	DWORD PTR _lpConn$[ebp], eax

; 660  :    if ( lpConn == 0 )

	cmp	DWORD PTR _lpConn$[ebp], 0
	jne	SHORT $LN6@zNetOpenCo

; 661  :    {
; 662  :       SysMessageBox( 0, szlErrorTitle, "Out of memory", -1 );

	push	-1
	push	OFFSET $SG120485
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 663  :       return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@zNetOpenCo
$LN6@zNetOpenCo:

; 664  :    }
; 665  : 
; 666  :    // Since we may manipulate the server address let's copy it to a temp var.
; 667  :    zstrcpy( szServerAddress, pchAddress );

	mov	ecx, DWORD PTR _pchAddress$[ebp]
	push	ecx
	lea	edx, DWORD PTR _szServerAddress$[ebp]
	push	edx
	call	_strcpy
	add	esp, 8

; 668  : 
; 669  :    // Check to see if the port number is part of the address.  If it is, then
; 670  :    // copy it to szPort.
; 671  :    pch = zstrchr( szServerAddress, ':' );

	push	58					; 0000003aH
	lea	eax, DWORD PTR _szServerAddress$[ebp]
	push	eax
	call	?strchr@@YAPADQADH@Z			; strchr
	add	esp, 8
	mov	DWORD PTR _pch$[ebp], eax

; 672  :    if ( pch )

	cmp	DWORD PTR _pch$[ebp], 0
	je	SHORT $LN7@zNetOpenCo

; 673  :    {
; 674  :       // Change ':' to null-term.
; 675  :       *pch++ = 0;

	mov	ecx, DWORD PTR _pch$[ebp]
	mov	BYTE PTR [ecx], 0
	mov	edx, DWORD PTR _pch$[ebp]
	add	edx, 1
	mov	DWORD PTR _pch$[ebp], edx

; 676  : 
; 677  :       // Convert port number.
; 678  :       nPort = (u_short) zatol( pch );

	mov	eax, DWORD PTR _pch$[ebp]
	push	eax
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nPort$[ebp], ax

; 679  :    }
; 680  :    else

	jmp	SHORT $LN10@zNetOpenCo
$LN7@zNetOpenCo:

; 681  :    if ( g_nApplPort != (u_short) -1 )

	movzx	ecx, WORD PTR _g_nApplPort
	cmp	ecx, 65535				; 0000ffffH
	je	SHORT $LN9@zNetOpenCo

; 682  :    {
; 683  :       nPort = g_nApplPort;

	mov	dx, WORD PTR _g_nApplPort
	mov	WORD PTR _nPort$[ebp], dx

; 684  :    }
; 685  :    else

	jmp	SHORT $LN10@zNetOpenCo
$LN9@zNetOpenCo:

; 686  :    {
; 687  :       zCHAR szPort[ 20 ];
; 688  : 
; 689  :       // The port value wasn't specified so get the default port from the Ini file.
; 690  :       SysReadZeidonIni( -1, "[zWinSock]", "ApplPort", szPort );

	lea	eax, DWORD PTR _szPort$9[ebp]
	push	eax
	push	OFFSET $SG120490
	push	OFFSET $SG120491
	push	-1
	call	_SysReadZeidonIni@16

; 691  :       nPort = (u_short) zatol( szPort );

	lea	ecx, DWORD PTR _szPort$9[ebp]
	push	ecx
	call	DWORD PTR __imp__atol
	add	esp, 4
	mov	WORD PTR _nPort$[ebp], ax

; 692  :       g_nApplPort = nPort;

	mov	dx, WORD PTR _nPort$[ebp]
	mov	WORD PTR _g_nApplPort, dx
$LN10@zNetOpenCo:

; 693  :    }
; 694  : 
; 695  :    lpConn->hMemHandle = hMem;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR _hMem$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 696  : 
; 697  :    // Set up a buffer to receive network traffic.
; 698  :    lpConn->hBufferMem = (zLONG) malloc( BUFFER_LTH );

	push	32000					; 00007d00H
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [edx+32], eax

; 699  :    lpConn->pchBuffer  = (zPCHAR) lpConn->hBufferMem;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+32]
	mov	DWORD PTR [eax+4], edx

; 700  :    if ( lpConn->pchBuffer == 0 )

	mov	eax, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN11@zNetOpenCo

; 701  :    {
; 702  :       SysMessageBox( 0, szlErrorTitle, "Out of memory", -1 );

	push	-1
	push	OFFSET $SG120493
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 703  :       goto EndOfFunction;

	jmp	$LN12@zNetOpenCo
	jmp	$EndOfFunction$35
$LN11@zNetOpenCo:

; 704  :    }
; 705  : 
; 706  :    lpConn->ulBufferLth = BUFFER_LTH;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+20], 32000		; 00007d00H

; 707  : 
; 708  :    sock = socket( AF_INET, SOCK_STREAM, 0 );

	push	0
	push	1
	push	2
	call	_socket@12
	mov	DWORD PTR _sock$[ebp], eax

; 709  :    if ( sock == INVALID_SOCKET )

	cmp	DWORD PTR _sock$[ebp], -1
	jne	SHORT $LN13@zNetOpenCo

; 710  :    {
; 711  :       SHOWERROR( "socket" );

	push	OFFSET $SG120496
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 712  :       SysMessageBox( 0, szlErrorTitle, "socket() failed", -1 );

	push	-1
	push	OFFSET $SG120497
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 713  :       goto EndOfFunction;

	jmp	$LN14@zNetOpenCo
	jmp	$EndOfFunction$35
$LN13@zNetOpenCo:

; 714  :    }
; 715  : 
; 716  : #ifdef __WIN32__
; 717  :    if ( ioctlsocket( sock, FIONBIO, &lBlockOff ) == SOCKET_ERROR )

	lea	edx, DWORD PTR _lBlockOff$[ebp]
	push	edx
	push	-2147195266				; 8004667eH
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	call	_ioctlsocket@12
	cmp	eax, -1
	jne	SHORT $LN15@zNetOpenCo

; 718  :    {
; 719  :       SHOWERROR( "ioctlsocket" );

	push	OFFSET $SG120500
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 720  :       SysMessageBox( 0, szlErrorTitle, "ioctlsocket() failed", -1 );

	push	-1
	push	OFFSET $SG120501
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 721  :       goto EndOfFunction;

	jmp	$LN16@zNetOpenCo
	jmp	$EndOfFunction$35
$LN15@zNetOpenCo:

; 722  :    }
; 723  : #endif
; 724  : 
; 725  :    while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN3@zNetOpenCo

; 726  :    {
; 727  :       zCHAR szMsg[ 500 ];
; 728  :       zLONG lStart, lEnd;
; 729  : 
; 730  :       lStart = SysGetTickCount();

	call	_SysGetTickCount@0
	mov	DWORD PTR _lStart$3[ebp], eax

; 731  :       pHost = gethostbyname( szServerAddress );

	lea	edx, DWORD PTR _szServerAddress$[ebp]
	push	edx
	call	_gethostbyname@4
	mov	DWORD PTR _pHost$[ebp], eax

; 732  :       lEnd = SysGetTickCount();

	call	_SysGetTickCount@0
	mov	DWORD PTR _lEnd$4[ebp], eax

; 733  : 
; 734  :       // Trace an error if over 5 seconds.
; 735  :       if ( lEnd - lStart > 5 * zTICKS_PER_SECOND )

	mov	eax, DWORD PTR _lEnd$4[ebp]
	sub	eax, DWORD PTR _lStart$3[ebp]
	cmp	eax, 5000				; 00001388H
	jle	SHORT $LN17@zNetOpenCo

; 736  :       {
; 737  :          char sz[ 200 ];
; 738  : 
; 739  :          zsprintf( sz, "%s took %lf seconds.", szServerAddress,

	mov	ecx, DWORD PTR _lEnd$4[ebp]
	sub	ecx, DWORD PTR _lStart$3[ebp]
	cvtsi2sd xmm0, ecx
	divsd	xmm0, QWORD PTR __real@408f400000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	edx, DWORD PTR _szServerAddress$[ebp]
	push	edx
	push	OFFSET $SG120504
	lea	eax, DWORD PTR _sz$8[ebp]
	push	eax
	call	_sprintf
	add	esp, 20					; 00000014H

; 740  :                    (double) ( lEnd - lStart ) / zTICKS_PER_SECOND );
; 741  :          TraceLineS( "(zWinSock) WARNING gethostbyname() for ", sz );

	lea	ecx, DWORD PTR _sz$8[ebp]
	push	ecx
	push	OFFSET $SG120505
	call	_TraceLineS@8
$LN17@zNetOpenCo:

; 742  :       }
; 743  : 
; 744  :       if ( pHost )

	cmp	DWORD PTR _pHost$[ebp], 0
	je	SHORT $LN18@zNetOpenCo

; 745  :          break;  // Got the info, so break.

	jmp	SHORT $LN3@zNetOpenCo
$LN18@zNetOpenCo:

; 746  : 
; 747  :       SHOWERROR( "gethostbyname" );

	push	OFFSET $SG120507
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 748  :       zsprintf( szMsg, "Couldn't resolve network address '%s'.  Make sure the server "

	lea	edx, DWORD PTR _szServerAddress$[ebp]
	push	edx
	push	OFFSET $SG120508
	lea	eax, DWORD PTR _szMsg$6[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 749  :                 "address is correct and that the Zeidon Server is running.",
; 750  :                 szServerAddress );
; 751  : 
; 752  : #ifdef __UNIX__
; 753  :       nRC = -1;
; 754  :       goto EndOfFunction;
; 755  : #else
; 756  :       if ( SysMessageBox( lpView, szlErrorTitle, szMsg, MB_RETRYCANCEL ) == IDCANCEL )

	push	5
	lea	ecx, DWORD PTR _szMsg$6[ebp]
	push	ecx
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	mov	edx, DWORD PTR _lpView$[ebp]
	push	edx
	call	_SysMessageBox@16
	cmp	eax, 2
	jne	SHORT $LN19@zNetOpenCo

; 757  :       {
; 758  :          nRC = -1;

	or	eax, -1
	mov	WORD PTR _nRC$[ebp], ax

; 759  :          goto EndOfFunction;

	jmp	$LN20@zNetOpenCo
	jmp	$EndOfFunction$35
$LN19@zNetOpenCo:

; 760  :       }
; 761  : #endif
; 762  :    }

	jmp	$LN15@zNetOpenCo
$LN3@zNetOpenCo:

; 763  : 
; 764  :    // Create the destination socket so we can call 'connect'.  Since the
; 765  :    // destination socket structure has a variable length we'll temporarily
; 766  :    // use our buffer that we created.
; 767  :    DestSocket = (SOCKADDR_IN *) &lpConn->pchBuffer[ BUFFER_LTH / 2 ];

	mov	ecx, 1
	imul	edx, ecx, 16000
	mov	eax, DWORD PTR _lpConn$[ebp]
	add	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _DestSocket$[ebp], edx

; 768  :    zmemcpy( &(DestSocket->sin_addr), pHost->h_addr, pHost->h_length );

	mov	ecx, DWORD PTR _pHost$[ebp]
	movsx	edx, WORD PTR [ecx+10]
	push	edx
	mov	eax, 4
	imul	ecx, eax, 0
	mov	edx, DWORD PTR _pHost$[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [eax+ecx]
	push	ecx
	mov	edx, DWORD PTR _DestSocket$[ebp]
	add	edx, 4
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 769  :    DestSocket->sin_port   = htons( nPort );

	movzx	eax, WORD PTR _nPort$[ebp]
	push	eax
	call	_htons@4
	mov	ecx, DWORD PTR _DestSocket$[ebp]
	mov	WORD PTR [ecx+2], ax

; 770  :    DestSocket->sin_family = AF_INET;

	mov	edx, 2
	mov	eax, DWORD PTR _DestSocket$[ebp]
	mov	WORD PTR [eax], dx
$LN4@zNetOpenCo:

; 771  : 
; 772  :    // Try to connect to the server.  We'll keep trying until:
; 773  :    //  1) We get through.
; 774  :    //  2) User says to quit trying.
; 775  :    while ( TRUE )

	mov	ecx, 1
	test	ecx, ecx
	je	$LN5@zNetOpenCo

; 776  :    {
; 777  :       zCHAR szMsg[ 500 ];
; 778  :       zLONG lStart, lEnd;
; 779  : 
; 780  :       lStart = SysGetTickCount();

	call	_SysGetTickCount@0
	mov	DWORD PTR _lStart$1[ebp], eax

; 781  :       if ( connect( sock, (PSOCKADDR) DestSocket, sizeof( *DestSocket ) ) == 0 )

	push	16					; 00000010H
	mov	edx, DWORD PTR _DestSocket$[ebp]
	push	edx
	mov	eax, DWORD PTR _sock$[ebp]
	push	eax
	call	_connect@12
	test	eax, eax
	jne	SHORT $LN21@zNetOpenCo

; 782  :       {
; 783  :          lEnd = SysGetTickCount();

	call	_SysGetTickCount@0
	mov	DWORD PTR _lEnd$2[ebp], eax

; 784  : 
; 785  :          // Trace an error if over 5 seconds.
; 786  :          if ( lEnd - lStart > 5 * zTICKS_PER_SECOND )

	mov	ecx, DWORD PTR _lEnd$2[ebp]
	sub	ecx, DWORD PTR _lStart$1[ebp]
	cmp	ecx, 5000				; 00001388H
	jle	SHORT $LN22@zNetOpenCo

; 787  :          {
; 788  :             char sz[ 200 ];
; 789  : 
; 790  :             zsprintf( sz, "%s took %lf seconds.", szServerAddress,

	mov	edx, DWORD PTR _lEnd$2[ebp]
	sub	edx, DWORD PTR _lStart$1[ebp]
	cvtsi2sd xmm0, edx
	divsd	xmm0, QWORD PTR __real@408f400000000000
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	lea	eax, DWORD PTR _szServerAddress$[ebp]
	push	eax
	push	OFFSET $SG120513
	lea	ecx, DWORD PTR _sz$7[ebp]
	push	ecx
	call	_sprintf
	add	esp, 20					; 00000014H

; 791  :                       (double) ( lEnd - lStart ) / zTICKS_PER_SECOND );
; 792  :             TraceLineS( "(zWinSock) WARNING connect() for ", sz );

	lea	edx, DWORD PTR _sz$7[ebp]
	push	edx
	push	OFFSET $SG120514
	call	_TraceLineS@8
$LN22@zNetOpenCo:

; 793  :          }
; 794  : 
; 795  :          break;  // Got a good connection, break loop.

	jmp	SHORT $LN5@zNetOpenCo
$LN21@zNetOpenCo:

; 796  :       }
; 797  : 
; 798  :       SHOWERROR( "connect" );

	push	OFFSET $SG120515
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 799  : 
; 800  :       zsprintf( szMsg, "Connection to server '%s' failed.  Make sure the server "

	mov	eax, DWORD PTR _pchAddress$[ebp]
	push	eax
	push	OFFSET $SG120516
	lea	ecx, DWORD PTR _szMsg$5[ebp]
	push	ecx
	call	_sprintf
	add	esp, 12					; 0000000cH

; 801  :                 "address is correct and that the server is running the Zeidon "
; 802  :                 "Object Engine.", pchAddress );
; 803  : 
; 804  : #ifdef __UNIX__
; 805  :       nRC = -1;
; 806  :       goto EndOfFunction;
; 807  : #else
; 808  :       if ( SysMessageBox( lpView, szlErrorTitle, szMsg, MB_RETRYCANCEL ) == IDCANCEL )

	push	5
	lea	edx, DWORD PTR _szMsg$5[ebp]
	push	edx
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_SysMessageBox@16
	cmp	eax, 2
	jne	SHORT $LN23@zNetOpenCo

; 809  :       {
; 810  :          nRC = -1;

	or	ecx, -1
	mov	WORD PTR _nRC$[ebp], cx

; 811  :          goto EndOfFunction;

	jmp	$LN24@zNetOpenCo
	jmp	$EndOfFunction$35
$LN23@zNetOpenCo:

; 812  :       }
; 813  : #endif
; 814  :    }

	jmp	$LN4@zNetOpenCo
$LN5@zNetOpenCo:

; 815  : 
; 816  :    // Everything is OK, so set nRC.
; 817  :    nRC = 0;

	xor	edx, edx
	mov	WORD PTR _nRC$[ebp], dx

; 818  : 
; 819  :    // Init connection info.
; 820  :    lpConn->sock         = sock;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR _sock$[ebp]
	mov	DWORD PTR [eax], ecx

; 821  :    lpConn->pchNextByte  = lpConn->pchBuffer;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+8], ecx

; 822  :    lpConn->ulUnusedLth  = 0;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [edx+16], 0

; 823  :    lpConn->nTraceLevel  = NetGetTraceLevel( lpView, "zWinSock" );

	push	OFFSET $SG120519
	mov	eax, DWORD PTR _lpView$[ebp]
	push	eax
	call	_NetGetTraceLevel@8
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	WORD PTR [ecx+40], ax

; 824  :    lpConn->bLastReceive = FALSE;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	BYTE PTR [edx+42], 0

; 825  : 
; 826  :    if ( lpConn->nTraceLevel > 0 )

	mov	eax, DWORD PTR _lpConn$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	test	ecx, ecx
	jle	SHORT $LN25@zNetOpenCo

; 827  :       TraceLineS( "(zwinsock) Connection to server made!", "" );

	push	OFFSET $SG120521
	push	OFFSET $SG120522
	call	_TraceLineS@8
$LN25@zNetOpenCo:

; 828  : 
; 829  :    // Set up a buffer to hold the peer name.
; 830  :    lpConn->hPeerNameMem = (zLONG) malloc( zstrlen( szServerAddress ) + 1 );

	lea	edx, DWORD PTR _szServerAddress$[ebp]
	push	edx
	call	_strlen
	add	esp, 4
	add	eax, 1
	push	eax
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+36], eax

; 831  :    lpConn->pchPeerName = (zPCHAR) lpConn->hPeerNameMem;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	mov	DWORD PTR [edx+12], ecx

; 832  :    if ( lpConn->pchPeerName == 0 )

	mov	edx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [edx+12], 0
	jne	SHORT $LN26@zNetOpenCo

; 833  :    {
; 834  :       SysMessageBox( 0, szlErrorTitle, "Out of memory", -1 );

	push	-1
	push	OFFSET $SG120524
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 835  :       nRC = zCALL_ERROR;

	mov	eax, -16				; fffffff0H
	mov	WORD PTR _nRC$[ebp], ax

; 836  :       goto EndOfFunction;

	jmp	SHORT $LN27@zNetOpenCo
	jmp	SHORT $EndOfFunction$35
$LN26@zNetOpenCo:

; 837  :    }
; 838  : 
; 839  :    zstrcpy( lpConn->pchPeerName, szServerAddress );

	lea	ecx, DWORD PTR _szServerAddress$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_strcpy
	add	esp, 8
$LN12@zNetOpenCo:
$LN14@zNetOpenCo:
$LN16@zNetOpenCo:
$LN20@zNetOpenCo:
$LN24@zNetOpenCo:
$LN27@zNetOpenCo:
$EndOfFunction$35:

; 840  : 
; 841  : EndOfFunction:
; 842  :    if ( nRC == zCALL_ERROR )

	movsx	ecx, WORD PTR _nRC$[ebp]
	cmp	ecx, -16				; fffffff0H
	jne	$LN28@zNetOpenCo

; 843  :    {
; 844  :       // We're ending with an error, so clean up.
; 845  :       if ( lpConn->hBufferMem )

	mov	edx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [edx+32], 0
	je	SHORT $LN30@zNetOpenCo

; 846  :          free( (zPVOID) lpConn->hBufferMem );

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+32]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN30@zNetOpenCo:

; 847  : 
; 848  :       if ( lpConn->hPeerNameMem )

	mov	edx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [edx+36], 0
	je	SHORT $LN31@zNetOpenCo

; 849  :          free( (zPVOID) lpConn->hPeerNameMem );

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+36]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN31@zNetOpenCo:

; 850  : 
; 851  :       if ( lpConn->hMemHandle )

	mov	edx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN32@zNetOpenCo

; 852  :          free( (zPVOID) lpConn->hMemHandle );

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	DWORD PTR __imp__free
	add	esp, 4
$LN32@zNetOpenCo:

; 853  : 
; 854  :       if ( sock != INVALID_SOCKET )

	cmp	DWORD PTR _sock$[ebp], -1
	je	SHORT $LN33@zNetOpenCo

; 855  :          closesocket( sock );

	mov	edx, DWORD PTR _sock$[ebp]
	push	edx
	call	_closesocket@4
$LN33@zNetOpenCo:

; 856  : 
; 857  :       lpConn->hBufferMem   = 0;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+32], 0

; 858  :       lpConn->hPeerNameMem = 0;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+36], 0

; 859  :       lpConn->hMemHandle   = 0;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [edx+28], 0

; 860  :    }
; 861  :    else

	jmp	SHORT $LN29@zNetOpenCo
$LN28@zNetOpenCo:

; 862  :       *ppvConnPtr = lpConn;

	mov	eax, DWORD PTR _ppvConnPtr$[ebp]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax], ecx
$LN29@zNetOpenCo:

; 863  : 
; 864  :    return( nRC );

	mov	ax, WORD PTR _nRC$[ebp]
$LN1@zNetOpenCo:

; 865  : 
; 866  : } // zNetOpenConnection

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_zNetOpenConnection@16 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_lpSockets$ = -28					; size = 4
_hNewBuff$1 = -24					; size = 4
_uMaxRead$ = -20					; size = 4
_ulUsed$ = -16						; size = 4
_pchNewBuff$2 = -12					; size = 4
_iBytes$3 = -8						; size = 4
_lpConn$ = -4						; size = 4
_ppHandle$ = 8						; size = 4
_ppvConnPtr$ = 12					; size = 4
_ppchReturnBuffer$ = 16					; size = 4
_uLth$ = 20						; size = 4
_cDataType$ = 24					; size = 1
_zNetReceive@20 PROC

; 454  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 455  :    LPSOCKETS      lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 456  :    LPCONNECTION   lpConn = (LPCONNECTION) *ppvConnPtr;

	mov	edx, DWORD PTR _ppvConnPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpConn$[ebp], eax

; 457  :    zULONG         ulUsed;
; 458  :    unsigned       uMaxRead;
; 459  : 
; 460  :    if ( lpConn->nTraceLevel > 1 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	cmp	edx, 1
	jle	SHORT $LN4@zNetReceiv

; 461  :       TraceLineI( "(zwinsock) zNetReceive -- uLth = ", uLth );

	mov	eax, DWORD PTR _uLth$[ebp]
	push	eax
	push	OFFSET $SG120395
	call	_TraceLineI@8
$LN4@zNetReceiv:

; 462  : 
; 463  :    // Check the flag to see if the last send/receive command was a send.  If
; 464  :    // the last command was a send, then the send buffer might need to be
; 465  :    // flushed.
; 466  :    if ( lpConn->bLastReceive == FALSE )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movzx	edx, BYTE PTR [ecx+42]
	test	edx, edx
	jne	SHORT $LN5@zNetReceiv

; 467  :    {
; 468  :       if ( lpConn->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpConn$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	cmp	ecx, 1
	jle	SHORT $LN6@zNetReceiv

; 469  :          TraceLineS( "(zwinsock) Flushing send buffer", "" );

	push	OFFSET $SG120398
	push	OFFSET $SG120399
	call	_TraceLineS@8
$LN6@zNetReceiv:

; 470  : 
; 471  :       if ( zNetSend( ppHandle, ppvConnPtr, 0, 0, 0 ) != 0 )

	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _ppvConnPtr$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppHandle$[ebp]
	push	eax
	call	_zNetSend@20
	movsx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN7@zNetReceiv

; 472  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@zNetReceiv
$LN7@zNetReceiv:

; 473  : 
; 474  :       lpConn->bLastReceive = TRUE;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	BYTE PTR [edx+42], 1

; 475  :       lpConn->ulTotalBytes = 0;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+24], 0

; 476  : 
; 477  :       if ( lpConn->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	test	edx, edx
	jle	SHORT $LN5@zNetReceiv

; 478  :          TraceLineI( "(zwinsock) Total bytes sent = ", lpConn->ulTotalBytes );

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET $SG120402
	call	_TraceLineI@8
$LN5@zNetReceiv:

; 479  :    }
; 480  : 
; 481  :    // Check to see if we have enough "unused" bytes in the read buffer.
; 482  :    // "Unused" bytes are bytes that have been received from the network but
; 483  :    // haven't been sent back to core.
; 484  :    if ( lpConn->ulUnusedLth >= uLth )

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+16]
	cmp	eax, DWORD PTR _uLth$[ebp]
	jb	SHORT $LN9@zNetReceiv

; 485  :    {
; 486  :       // We have enough "unused" bytes in the buffer to handle the request.
; 487  :       // Set pointers and return.
; 488  :       *ppchReturnBuffer = lpConn->pchNextByte;

	mov	ecx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 489  :       lpConn->pchNextByte += uLth;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR _uLth$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+8], edx

; 490  :       lpConn->ulUnusedLth -= uLth;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	sub	edx, DWORD PTR _uLth$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+16], edx

; 491  : 
; 492  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@zNetReceiv
$LN9@zNetReceiv:

; 493  :    }
; 494  : 
; 495  :    ulUsed = (zULONG) (lpConn->pchNextByte - lpConn->pchBuffer);

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _ulUsed$[ebp], eax

; 496  : 
; 497  :    // Check to see if there is enough space left in the buffer to hold the
; 498  :    // data needed.
; 499  :    if ( ulUsed + lpConn->ulUnusedLth + uLth > lpConn->ulBufferLth )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR _ulUsed$[ebp]
	add	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR _uLth$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	cmp	edx, DWORD PTR [eax+20]
	jbe	$LN10@zNetReceiv

; 500  :    {
; 501  :       zLONG  hNewBuff;
; 502  :       zPCHAR pchNewBuff = 0;

	mov	DWORD PTR _pchNewBuff$2[ebp], 0

; 503  : 
; 504  :       // If we get here then there is not enough space at the end of the
; 505  :       // buffer to hold the requested data.  This means we have to "move up"
; 506  :       // the "unused" bytes to the beginning of the read buffer.  It's also
; 507  :       // possible that the requested bytes is more than the buffer can hold.
; 508  :       // In this case we'll allocate a new, bigger buffer before we move the
; 509  :       // data around.
; 510  : 
; 511  :       if ( lpConn->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	test	edx, edx
	jle	SHORT $LN11@zNetReceiv

; 512  :          TraceLineS( "(zwinsock) Trying to consolidate receive buffer", "" );

	push	OFFSET $SG120406
	push	OFFSET $SG120407
	call	_TraceLineS@8
$LN11@zNetReceiv:

; 513  : 
; 514  :       // Check to see if the buffer is big enough to hold the necessary data.
; 515  :       if ( lpConn->ulBufferLth < uLth )

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR _uLth$[ebp]
	jae	$LN12@zNetReceiv

; 516  :       {
; 517  :          if ( lpConn->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpConn$[ebp]
	movsx	eax, WORD PTR [edx+40]
	test	eax, eax
	jle	SHORT $LN14@zNetReceiv

; 518  :             TraceLineS( "(zwinsock) Allocating bigger buffer", "" );

	push	OFFSET $SG120411
	push	OFFSET $SG120412
	call	_TraceLineS@8
$LN14@zNetReceiv:

; 519  : 
; 520  :          // We need to allocate a bigger buffer.
; 521  :          hNewBuff = (zLONG) malloc( uLth + 1000 );

	mov	ecx, DWORD PTR _uLth$[ebp]
	add	ecx, 1000				; 000003e8H
	push	ecx
	call	DWORD PTR __imp__malloc
	add	esp, 4
	mov	DWORD PTR _hNewBuff$1[ebp], eax

; 522  :          pchNewBuff = (zPCHAR) hNewBuff;

	mov	edx, DWORD PTR _hNewBuff$1[ebp]
	mov	DWORD PTR _pchNewBuff$2[ebp], edx

; 523  :          if ( pchNewBuff == 0 )

	cmp	DWORD PTR _pchNewBuff$2[ebp], 0
	jne	SHORT $LN15@zNetReceiv

; 524  :          {
; 525  :             SysMessageBox( 0, szlErrorTitle, "Out of memory", -1 );

	push	-1
	push	OFFSET $SG120414
	push	OFFSET ?szlErrorTitle@@3PADA		; szlErrorTitle
	push	0
	call	_SysMessageBox@16

; 526  :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@zNetReceiv
$LN15@zNetReceiv:

; 527  :          }
; 528  : 
; 529  :          // Copy unused data from old buffer to new buffer.
; 530  :          zmemcpy( pchNewBuff, lpConn->pchNextByte,

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _pchNewBuff$2[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 531  :                   (unsigned int) lpConn->ulUnusedLth );
; 532  : 
; 533  :          // Free the old buffer.
; 534  :          free( (zPVOID) lpConn->hBufferMem );

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+32]
	push	eax
	call	DWORD PTR __imp__free
	add	esp, 4

; 535  : 
; 536  :          // Set up connection info with new buffer.
; 537  :          lpConn->ulBufferLth = uLth + 1000;

	mov	ecx, DWORD PTR _uLth$[ebp]
	add	ecx, 1000				; 000003e8H
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 538  :          lpConn->hBufferMem  = hNewBuff;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR _hNewBuff$1[ebp]
	mov	DWORD PTR [eax+32], ecx

; 539  :          lpConn->pchBuffer   = pchNewBuff;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR _pchNewBuff$2[ebp]
	mov	DWORD PTR [edx+4], eax

; 540  :       }
; 541  :       else

	jmp	SHORT $LN13@zNetReceiv
$LN12@zNetReceiv:

; 542  :       {
; 543  :          // Copy the unused data to the beginning of the buffer.  This should
; 544  :          // free up room at the end of the buffer to retrieve data off the network.
; 545  :          zmemcpy( lpConn->pchBuffer, lpConn->pchNextByte,

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN13@zNetReceiv:

; 546  :                   (unsigned int) lpConn->ulUnusedLth );
; 547  :       }
; 548  : 
; 549  :       lpConn->pchNextByte = lpConn->pchBuffer;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+8], eax

; 550  :       ulUsed = 0;

	mov	DWORD PTR _ulUsed$[ebp], 0
$LN10@zNetReceiv:

; 551  :    }
; 552  : 
; 553  :    // Determine how much space is left at the end of the buffer.  This is
; 554  :    // the max number of bytes we can get without overflowing the buffer.
; 555  :    uMaxRead = lpConn->ulBufferLth - (ulUsed + lpConn->ulUnusedLth);

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR _ulUsed$[ebp]
	add	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	sub	ecx, edx
	mov	DWORD PTR _uMaxRead$[ebp], ecx
$LN2@zNetReceiv:

; 556  : 
; 557  :    // Keep reading from the network until we have all the data we need.
; 558  :    while ( uLth > lpConn->ulUnusedLth )

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR _uLth$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	$LN3@zNetReceiv

; 559  :    {
; 560  :       int iBytes;
; 561  : 
; 562  :       // Now retrieve data from the network, appending it to the end of the
; 563  :       // data in the buffer.
; 564  :       iBytes = recv( lpConn->sock, &lpConn->pchNextByte[ lpConn->ulUnusedLth ],

	push	0
	mov	ecx, DWORD PTR _uMaxRead$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	add	eax, DWORD PTR [ecx+16]
	push	eax
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_recv@16
	mov	DWORD PTR _iBytes$3[ebp], eax

; 565  :                      uMaxRead, 0 );
; 566  :       if ( iBytes == SOCKET_ERROR || iBytes == 0 )

	cmp	DWORD PTR _iBytes$3[ebp], -1
	je	SHORT $LN17@zNetReceiv
	cmp	DWORD PTR _iBytes$3[ebp], 0
	jne	SHORT $LN16@zNetReceiv
$LN17@zNetReceiv:

; 567  :       {
; 568  :          SHOWERROR( "recv" );

	push	OFFSET $SG120417
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 569  :          TraceLineI( "(zwinsock) Error trying to extend buffer.  RC = ", iBytes );

	mov	ecx, DWORD PTR _iBytes$3[ebp]
	push	ecx
	push	OFFSET $SG120418
	call	_TraceLineI@8

; 570  :          return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@zNetReceiv
$LN16@zNetReceiv:

; 571  :       }
; 572  : 
; 573  :       if ( lpConn->nTraceLevel > 0 )

	mov	edx, DWORD PTR _lpConn$[ebp]
	movsx	eax, WORD PTR [edx+40]
	test	eax, eax
	jle	SHORT $LN18@zNetReceiv

; 574  :       {
; 575  :          TraceLineI( "(zwinsock) Bytes read = ", iBytes );

	mov	ecx, DWORD PTR _iBytes$3[ebp]
	push	ecx
	push	OFFSET $SG120420
	call	_TraceLineI@8

; 576  : 
; 577  :          if ( lpConn->nTraceLevel > 1 )

	mov	edx, DWORD PTR _lpConn$[ebp]
	movsx	eax, WORD PTR [edx+40]
	cmp	eax, 1
	jle	SHORT $LN18@zNetReceiv

; 578  :          {
; 579  :             TraceLineI( "(zwinsock) Tracing buffer ... ", iBytes );

	mov	ecx, DWORD PTR _iBytes$3[ebp]
	push	ecx
	push	OFFSET $SG120422
	call	_TraceLineI@8

; 580  :             TraceBuffer( "(zwinsock)",

	movzx	edx, WORD PTR _iBytes$3[ebp]
	push	edx
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	edx, DWORD PTR _lpConn$[ebp]
	add	ecx, DWORD PTR [edx+16]
	push	ecx
	push	OFFSET $SG120423
	call	_TraceBuffer@12
$LN18@zNetReceiv:

; 581  :                          &lpConn->pchNextByte[ lpConn->ulUnusedLth ],
; 582  :                          (zUSHORT) iBytes );
; 583  :          }
; 584  :       }
; 585  : 
; 586  :       lpConn->ulUnusedLth  += iBytes;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _iBytes$3[ebp]
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [edx+16], ecx

; 587  :       lpConn->ulTotalBytes += iBytes;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _iBytes$3[ebp]
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 588  :       uMaxRead             -= iBytes;

	mov	eax, DWORD PTR _uMaxRead$[ebp]
	sub	eax, DWORD PTR _iBytes$3[ebp]
	mov	DWORD PTR _uMaxRead$[ebp], eax

; 589  : 
; 590  :       if ( lpConn->nTraceLevel > 0 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	test	edx, edx
	jle	SHORT $LN20@zNetReceiv

; 591  :       {
; 592  :          if ( uLth > lpConn->ulUnusedLth )

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR _uLth$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jbe	SHORT $LN20@zNetReceiv

; 593  :             TraceLineS( "(zwinsock) Buffer still doens't have enough data", "" );

	push	OFFSET $SG120426
	push	OFFSET $SG120427
	call	_TraceLineS@8
$LN20@zNetReceiv:

; 594  :       }
; 595  : 
; 596  :    } // while...

	jmp	$LN2@zNetReceiv
$LN3@zNetReceiv:

; 597  : 
; 598  :    *ppchReturnBuffer = lpConn->pchNextByte;

	mov	edx, DWORD PTR _ppchReturnBuffer$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], ecx

; 599  :    lpConn->pchNextByte += uLth;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+8]
	add	eax, DWORD PTR _uLth$[ebp]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+8], eax

; 600  :    lpConn->ulUnusedLth -= uLth;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+16]
	sub	eax, DWORD PTR _uLth$[ebp]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 601  : 
; 602  :    return( 0 );

	xor	eax, eax
$LN1@zNetReceiv:

; 603  : 
; 604  : } // zNetReceive

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_zNetReceive@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_lpSockets$ = -16					; size = 4
_iBytesSent$ = -12					; size = 4
_iBytesToSend$ = -8					; size = 4
_lpConn$ = -4						; size = 4
_ppHandle$ = 8						; size = 4
_ppvConnPtr$ = 12					; size = 4
_pchBuffer$ = 16					; size = 4
_uLth$ = 20						; size = 4
_cDataType$ = 24					; size = 1
_zNetSend@20 PROC

; 308  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 309  :    LPSOCKETS      lpSockets = (LPSOCKETS) *ppHandle;

	mov	eax, DWORD PTR _ppHandle$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _lpSockets$[ebp], ecx

; 310  :    LPCONNECTION   lpConn = (LPCONNECTION) *ppvConnPtr;

	mov	edx, DWORD PTR _ppvConnPtr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _lpConn$[ebp], eax

; 311  :    int            iBytesToSend;
; 312  :    int            iBytesSent;
; 313  : 
; 314  :    if ( lpConn->nTraceLevel > 1 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	cmp	edx, 1
	jle	SHORT $LN8@zNetSend

; 315  :       TraceLineI( "(zwinsock) zNetSend -- uLth = ", uLth );

	mov	eax, DWORD PTR _uLth$[ebp]
	push	eax
	push	OFFSET $SG120339
	call	_TraceLineI@8
$LN8@zNetSend:

; 316  : 
; 317  :    // If the last command was a receive (as opposed to a send) then we need
; 318  :    // to reset the buffer for sending.
; 319  :    if ( lpConn->bLastReceive )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movzx	edx, BYTE PTR [ecx+42]
	test	edx, edx
	je	SHORT $LN9@zNetSend

; 320  :    {
; 321  :       if ( lpConn->nTraceLevel > 0 && lpConn->ulTotalBytes > 0 )

	mov	eax, DWORD PTR _lpConn$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	test	ecx, ecx
	jle	SHORT $LN10@zNetSend
	mov	edx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jbe	SHORT $LN10@zNetSend

; 322  :          TraceLineI( "(zwinsock) Total bytes received = ", lpConn->ulTotalBytes );

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET $SG120342
	call	_TraceLineI@8
$LN10@zNetSend:

; 323  : 
; 324  :       lpConn->bLastReceive = FALSE;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	BYTE PTR [edx+42], 0

; 325  :       lpConn->pchNextByte  = lpConn->pchBuffer;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+8], edx

; 326  :       lpConn->ulUnusedLth  = 0;

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+16], 0

; 327  :       lpConn->ulTotalBytes = 0;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+24], 0
$LN9@zNetSend:

; 328  :    }
; 329  : 
; 330  :    // Check to see if we need to flush the current buffer.
; 331  :    if ( (pchBuffer == 0 && lpConn->ulUnusedLth > 0) ||

	cmp	DWORD PTR _pchBuffer$[ebp], 0
	jne	SHORT $LN13@zNetSend
	mov	edx, DWORD PTR _lpConn$[ebp]
	cmp	DWORD PTR [edx+16], 0
	ja	SHORT $LN12@zNetSend
$LN13@zNetSend:
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	add	ecx, DWORD PTR _uLth$[ebp]
	mov	edx, DWORD PTR _lpConn$[ebp]
	cmp	ecx, DWORD PTR [edx+20]
	jbe	$LN11@zNetSend
$LN12@zNetSend:

; 332  :         (lpConn->ulUnusedLth + uLth > lpConn->ulBufferLth) )
; 333  :    {
; 334  :       if ( lpConn->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpConn$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	cmp	ecx, 1
	jle	SHORT $LN14@zNetSend

; 335  :       {
; 336  :          TraceLineI( "(zwinsock) Sending buffer of length ",

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET $SG120347
	call	_TraceLineI@8

; 337  :                      lpConn->ulUnusedLth );
; 338  :          TraceBuffer( "(zwinsock)",  lpConn->pchBuffer, lpConn->ulUnusedLth );

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET $SG120348
	call	_TraceBuffer@12
$LN14@zNetSend:

; 339  :       }
; 340  : 
; 341  :       iBytesToSend = (int) lpConn->ulUnusedLth;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR _iBytesToSend$[ebp], eax
$LN4@zNetSend:

; 342  : 
; 343  :       do
; 344  :       {
; 345  :          iBytesSent = send( lpConn->sock, lpConn->pchBuffer, iBytesToSend, 0 );

	push	0
	mov	ecx, DWORD PTR _iBytesToSend$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_send@16
	mov	DWORD PTR _iBytesSent$[ebp], eax

; 346  :          if ( iBytesSent == SOCKET_ERROR )

	cmp	DWORD PTR _iBytesSent$[ebp], -1
	jne	SHORT $LN15@zNetSend

; 347  :          {
; 348  :             TraceLineS( "(zwinsock) send -- Error!", "" );

	push	OFFSET $SG120350
	push	OFFSET $SG120351
	call	_TraceLineS@8

; 349  :             SHOWERROR( "send" );

	push	OFFSET $SG120352
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 350  :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@zNetSend
$LN15@zNetSend:

; 351  :          }
; 352  : 
; 353  :          if ( lpConn->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpConn$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	cmp	ecx, 1
	jle	SHORT $LN16@zNetSend

; 354  :             TraceLineI( "(zwinsock) Bytes sent for send ", iBytesSent );

	mov	edx, DWORD PTR _iBytesSent$[ebp]
	push	edx
	push	OFFSET $SG120354
	call	_TraceLineI@8
$LN16@zNetSend:

; 355  : 
; 356  :          iBytesToSend -= iBytesSent;

	mov	eax, DWORD PTR _iBytesToSend$[ebp]
	sub	eax, DWORD PTR _iBytesSent$[ebp]
	mov	DWORD PTR _iBytesToSend$[ebp], eax

; 357  : 
; 358  :       } while ( iBytesToSend > 0 );

	cmp	DWORD PTR _iBytesToSend$[ebp], 0
	jg	SHORT $LN4@zNetSend

; 359  : 
; 360  :       lpConn->ulTotalBytes += lpConn->ulUnusedLth;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _lpConn$[ebp]
	add	edx, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 361  :       lpConn->ulUnusedLth = 0;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [edx+16], 0
$LN11@zNetSend:

; 362  :    }
; 363  : 
; 364  :    // If the incoming buffer is 0 then we only needed to flush the buffer.
; 365  :    if ( pchBuffer == 0 )

	cmp	DWORD PTR _pchBuffer$[ebp], 0
	jne	SHORT $LN17@zNetSend

; 366  :       return( 0 );

	xor	eax, eax
	jmp	$LN1@zNetSend
$LN17@zNetSend:

; 367  : 
; 368  :    // If the incoming buffer length is greater than the send buffer we'll just
; 369  :    // send the incoming buffer now.
; 370  :    if ( uLth > lpConn->ulBufferLth )

	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	ecx, DWORD PTR _uLth$[ebp]
	cmp	ecx, DWORD PTR [eax+20]
	jbe	$LN18@zNetSend

; 371  :    {
; 372  :       if ( lpConn->nTraceLevel > 1 )

	mov	edx, DWORD PTR _lpConn$[ebp]
	movsx	eax, WORD PTR [edx+40]
	cmp	eax, 1
	jle	SHORT $LN19@zNetSend

; 373  :       {
; 374  :          TraceLineI( "(zwinsock) Sending incoming buffer of length ", uLth );

	mov	ecx, DWORD PTR _uLth$[ebp]
	push	ecx
	push	OFFSET $SG120358
	call	_TraceLineI@8

; 375  :          TraceBuffer( "(zwinsock)",  pchBuffer, uLth );

	mov	edx, DWORD PTR _uLth$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	push	OFFSET $SG120359
	call	_TraceBuffer@12
$LN19@zNetSend:

; 376  :       }
; 377  : 
; 378  :       iBytesToSend = (int) uLth;

	mov	ecx, DWORD PTR _uLth$[ebp]
	mov	DWORD PTR _iBytesToSend$[ebp], ecx
$LN7@zNetSend:

; 379  : 
; 380  :       do
; 381  :       {
; 382  :          iBytesSent = send( lpConn->sock, pchBuffer, iBytesToSend, 0 );

	push	0
	mov	edx, DWORD PTR _iBytesToSend$[ebp]
	push	edx
	mov	eax, DWORD PTR _pchBuffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	call	_send@16
	mov	DWORD PTR _iBytesSent$[ebp], eax

; 383  :          if ( iBytesSent == SOCKET_ERROR )

	cmp	DWORD PTR _iBytesSent$[ebp], -1
	jne	SHORT $LN20@zNetSend

; 384  :          {
; 385  :             TraceLineS( "(zwinsock) send -- Error!", "" );

	push	OFFSET $SG120361
	push	OFFSET $SG120362
	call	_TraceLineS@8

; 386  :             SHOWERROR( "send" );

	push	OFFSET $SG120363
	call	?fnShowError@@YAXPAD@Z			; fnShowError
	add	esp, 4

; 387  :             return( zCALL_ERROR );

	mov	eax, -16				; fffffff0H
	jmp	$LN1@zNetSend
$LN20@zNetSend:

; 388  :          }
; 389  : 
; 390  :          if ( lpConn->nTraceLevel > 1 )

	mov	eax, DWORD PTR _lpConn$[ebp]
	movsx	ecx, WORD PTR [eax+40]
	cmp	ecx, 1
	jle	SHORT $LN21@zNetSend

; 391  :             TraceLineI( "(zwinsock) Bytes sent for send ", iBytesSent );

	mov	edx, DWORD PTR _iBytesSent$[ebp]
	push	edx
	push	OFFSET $SG120365
	call	_TraceLineI@8
$LN21@zNetSend:

; 392  : 
; 393  :          iBytesToSend -= iBytesSent;

	mov	eax, DWORD PTR _iBytesToSend$[ebp]
	sub	eax, DWORD PTR _iBytesSent$[ebp]
	mov	DWORD PTR _iBytesToSend$[ebp], eax

; 394  : 
; 395  :       } while ( iBytesToSend > 0 );

	cmp	DWORD PTR _iBytesToSend$[ebp], 0
	jg	SHORT $LN7@zNetSend

; 396  : 
; 397  :       lpConn->ulTotalBytes += uLth;

	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, DWORD PTR _uLth$[ebp]
	mov	eax, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [eax+24], edx

; 398  : 
; 399  :       return( 0 );

	xor	eax, eax
	jmp	SHORT $LN1@zNetSend
$LN18@zNetSend:

; 400  :    }
; 401  : 
; 402  :    // Add the buffer data to the send buffer.
; 403  :    if ( lpConn->nTraceLevel > 1 )

	mov	ecx, DWORD PTR _lpConn$[ebp]
	movsx	edx, WORD PTR [ecx+40]
	cmp	edx, 1
	jle	SHORT $LN22@zNetSend

; 404  :       TraceLineS( "(zwinsock) Adding bytes to send buffer", "" );

	push	OFFSET $SG120367
	push	OFFSET $SG120368
	call	_TraceLineS@8
$LN22@zNetSend:

; 405  : 
; 406  :    zmemcpy( &lpConn->pchBuffer[ lpConn->ulUnusedLth ], pchBuffer,

	mov	eax, DWORD PTR _uLth$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pchBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	add	eax, DWORD PTR [ecx+16]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 407  :             (unsigned int) uLth );
; 408  :    lpConn->ulUnusedLth += uLth;

	mov	edx, DWORD PTR _lpConn$[ebp]
	mov	eax, DWORD PTR [edx+16]
	add	eax, DWORD PTR _uLth$[ebp]
	mov	ecx, DWORD PTR _lpConn$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 409  : 
; 410  :    return( 0 );

	xor	eax, eax
$LN1@zNetSend:

; 411  : 
; 412  : } // zNetSend

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_zNetSend@20 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\10c\w\oe\zwinsock.cpp
_TEXT	SEGMENT
_nErr$ = -788						; size = 4
_k$ = -784						; size = 4
_gErrMsgs$ = -780					; size = 376
_szMsg$ = -404						; size = 400
__$ArrayPad$ = -4					; size = 4
_pchFuncName$ = 8					; size = 4
?fnShowError@@YAXPAD@Z PROC				; fnShowError

; 196  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 788				; 00000314H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 197  :    char   szMsg[ 400 ];
; 198  :    int    nErr = WSAGetLastError( );

	call	_WSAGetLastError@0
	mov	DWORD PTR _nErr$[ebp], eax

; 199  :    int    k;
; 200  : 
; 201  :    struct ErrorMessageStruct gErrMsgs[] =
; 202  :    {
; 203  :       WSAEINTR,              "WSAEINTR",

	mov	DWORD PTR _gErrMsgs$[ebp], 10004	; 00002714H
	mov	DWORD PTR _gErrMsgs$[ebp+4], OFFSET $SG120264

; 204  :       WSAEBADF,              "WSAEBADF",

	mov	DWORD PTR _gErrMsgs$[ebp+8], 10009	; 00002719H
	mov	DWORD PTR _gErrMsgs$[ebp+12], OFFSET $SG120265

; 205  :       WSAEACCES,             "WSAEACCES",

	mov	DWORD PTR _gErrMsgs$[ebp+16], 10013	; 0000271dH
	mov	DWORD PTR _gErrMsgs$[ebp+20], OFFSET $SG120266

; 206  :       WSAEFAULT,             "WSAEFAULT",

	mov	DWORD PTR _gErrMsgs$[ebp+24], 10014	; 0000271eH
	mov	DWORD PTR _gErrMsgs$[ebp+28], OFFSET $SG120267

; 207  :       WSAEINVAL,             "WSAEINVAL",

	mov	DWORD PTR _gErrMsgs$[ebp+32], 10022	; 00002726H
	mov	DWORD PTR _gErrMsgs$[ebp+36], OFFSET $SG120268

; 208  :       WSAEMFILE,             "WSAEMFILE",

	mov	DWORD PTR _gErrMsgs$[ebp+40], 10024	; 00002728H
	mov	DWORD PTR _gErrMsgs$[ebp+44], OFFSET $SG120269

; 209  :       WSAEWOULDBLOCK,        "WSAEWOULDBLOCK",

	mov	DWORD PTR _gErrMsgs$[ebp+48], 10035	; 00002733H
	mov	DWORD PTR _gErrMsgs$[ebp+52], OFFSET $SG120270

; 210  :       WSAEINPROGRESS,        "WSAEINPROGRESS",

	mov	DWORD PTR _gErrMsgs$[ebp+56], 10036	; 00002734H
	mov	DWORD PTR _gErrMsgs$[ebp+60], OFFSET $SG120271

; 211  :       WSAEALREADY,           "WSAEALREADY",

	mov	DWORD PTR _gErrMsgs$[ebp+64], 10037	; 00002735H
	mov	DWORD PTR _gErrMsgs$[ebp+68], OFFSET $SG120272

; 212  :       WSAENOTSOCK,           "WSAENOTSOCK",

	mov	DWORD PTR _gErrMsgs$[ebp+72], 10038	; 00002736H
	mov	DWORD PTR _gErrMsgs$[ebp+76], OFFSET $SG120273

; 213  :       WSAEDESTADDRREQ,       "WSAEDESTADDRREQ",

	mov	DWORD PTR _gErrMsgs$[ebp+80], 10039	; 00002737H
	mov	DWORD PTR _gErrMsgs$[ebp+84], OFFSET $SG120274

; 214  :       WSAEMSGSIZE,           "WSAEMSGSIZE",

	mov	DWORD PTR _gErrMsgs$[ebp+88], 10040	; 00002738H
	mov	DWORD PTR _gErrMsgs$[ebp+92], OFFSET $SG120275

; 215  :       WSAEPROTOTYPE,         "WSAEPROTOTYPE",

	mov	DWORD PTR _gErrMsgs$[ebp+96], 10041	; 00002739H
	mov	DWORD PTR _gErrMsgs$[ebp+100], OFFSET $SG120276

; 216  :       WSAENOPROTOOPT,        "WSAENOPROTOOPT",

	mov	DWORD PTR _gErrMsgs$[ebp+104], 10042	; 0000273aH
	mov	DWORD PTR _gErrMsgs$[ebp+108], OFFSET $SG120277

; 217  :       WSAEPROTONOSUPPORT,    "WSAEPROTONOSUPPORT",

	mov	DWORD PTR _gErrMsgs$[ebp+112], 10043	; 0000273bH
	mov	DWORD PTR _gErrMsgs$[ebp+116], OFFSET $SG120278

; 218  :       WSAESOCKTNOSUPPORT,    "WSAESOCKTNOSUPPORT",

	mov	DWORD PTR _gErrMsgs$[ebp+120], 10044	; 0000273cH
	mov	DWORD PTR _gErrMsgs$[ebp+124], OFFSET $SG120279

; 219  :       WSAEOPNOTSUPP,         "WSAEOPNOTSUPP",

	mov	DWORD PTR _gErrMsgs$[ebp+128], 10045	; 0000273dH
	mov	DWORD PTR _gErrMsgs$[ebp+132], OFFSET $SG120280

; 220  :       WSAEPFNOSUPPORT,       "WSAEPFNOSUPPORT",

	mov	DWORD PTR _gErrMsgs$[ebp+136], 10046	; 0000273eH
	mov	DWORD PTR _gErrMsgs$[ebp+140], OFFSET $SG120281

; 221  :       WSAEAFNOSUPPORT,       "WSAEAFNOSUPPORT",

	mov	DWORD PTR _gErrMsgs$[ebp+144], 10047	; 0000273fH
	mov	DWORD PTR _gErrMsgs$[ebp+148], OFFSET $SG120282

; 222  :       WSAEADDRINUSE,         "WSAEADDRINUSE",

	mov	DWORD PTR _gErrMsgs$[ebp+152], 10048	; 00002740H
	mov	DWORD PTR _gErrMsgs$[ebp+156], OFFSET $SG120283

; 223  :       WSAEADDRNOTAVAIL,      "WSAEADDRNOTAVAIL",

	mov	DWORD PTR _gErrMsgs$[ebp+160], 10049	; 00002741H
	mov	DWORD PTR _gErrMsgs$[ebp+164], OFFSET $SG120284

; 224  :       WSAENETDOWN,           "WSAENETDOWN",

	mov	DWORD PTR _gErrMsgs$[ebp+168], 10050	; 00002742H
	mov	DWORD PTR _gErrMsgs$[ebp+172], OFFSET $SG120285

; 225  :       WSAENETUNREACH,        "WSAENETUNREACH",

	mov	DWORD PTR _gErrMsgs$[ebp+176], 10051	; 00002743H
	mov	DWORD PTR _gErrMsgs$[ebp+180], OFFSET $SG120286

; 226  :       WSAENETRESET,          "WSAENETRESET",

	mov	DWORD PTR _gErrMsgs$[ebp+184], 10052	; 00002744H
	mov	DWORD PTR _gErrMsgs$[ebp+188], OFFSET $SG120287

; 227  :       WSAECONNABORTED,       "WSAECONNABORTED",

	mov	DWORD PTR _gErrMsgs$[ebp+192], 10053	; 00002745H
	mov	DWORD PTR _gErrMsgs$[ebp+196], OFFSET $SG120288

; 228  :       WSAECONNRESET,         "WSAECONNRESET",

	mov	DWORD PTR _gErrMsgs$[ebp+200], 10054	; 00002746H
	mov	DWORD PTR _gErrMsgs$[ebp+204], OFFSET $SG120289

; 229  :       WSAENOBUFS,            "WSAENOBUFS",

	mov	DWORD PTR _gErrMsgs$[ebp+208], 10055	; 00002747H
	mov	DWORD PTR _gErrMsgs$[ebp+212], OFFSET $SG120290

; 230  :       WSAEISCONN,            "WSAEISCONN",

	mov	DWORD PTR _gErrMsgs$[ebp+216], 10056	; 00002748H
	mov	DWORD PTR _gErrMsgs$[ebp+220], OFFSET $SG120291

; 231  :       WSAENOTCONN,           "WSAENOTCONN",

	mov	DWORD PTR _gErrMsgs$[ebp+224], 10057	; 00002749H
	mov	DWORD PTR _gErrMsgs$[ebp+228], OFFSET $SG120292

; 232  :       WSAESHUTDOWN,          "WSAESHUTDOWN",

	mov	DWORD PTR _gErrMsgs$[ebp+232], 10058	; 0000274aH
	mov	DWORD PTR _gErrMsgs$[ebp+236], OFFSET $SG120293

; 233  :       WSAETOOMANYREFS,       "WSAETOOMANYREFS",

	mov	DWORD PTR _gErrMsgs$[ebp+240], 10059	; 0000274bH
	mov	DWORD PTR _gErrMsgs$[ebp+244], OFFSET $SG120294

; 234  :       WSAETIMEDOUT,          "WSAETIMEDOUT",

	mov	DWORD PTR _gErrMsgs$[ebp+248], 10060	; 0000274cH
	mov	DWORD PTR _gErrMsgs$[ebp+252], OFFSET $SG120295

; 235  :       WSAECONNREFUSED,       "WSAECONNREFUSED",

	mov	DWORD PTR _gErrMsgs$[ebp+256], 10061	; 0000274dH
	mov	DWORD PTR _gErrMsgs$[ebp+260], OFFSET $SG120296

; 236  :       WSAELOOP,              "WSAELOOP",

	mov	DWORD PTR _gErrMsgs$[ebp+264], 10062	; 0000274eH
	mov	DWORD PTR _gErrMsgs$[ebp+268], OFFSET $SG120297

; 237  :       WSAENAMETOOLONG,       "WSAENAMETOOLONG",

	mov	DWORD PTR _gErrMsgs$[ebp+272], 10063	; 0000274fH
	mov	DWORD PTR _gErrMsgs$[ebp+276], OFFSET $SG120298

; 238  :       WSAEHOSTDOWN,          "WSAEHOSTDOWN",

	mov	DWORD PTR _gErrMsgs$[ebp+280], 10064	; 00002750H
	mov	DWORD PTR _gErrMsgs$[ebp+284], OFFSET $SG120299

; 239  :       WSAEHOSTUNREACH,       "WSAEHOSTUNREACH",

	mov	DWORD PTR _gErrMsgs$[ebp+288], 10065	; 00002751H
	mov	DWORD PTR _gErrMsgs$[ebp+292], OFFSET $SG120300

; 240  :       WSAENOTEMPTY,          "WSAENOTEMPTY",

	mov	DWORD PTR _gErrMsgs$[ebp+296], 10066	; 00002752H
	mov	DWORD PTR _gErrMsgs$[ebp+300], OFFSET $SG120301

; 241  :       WSAEPROCLIM,           "WSAEPROCLIM",

	mov	DWORD PTR _gErrMsgs$[ebp+304], 10067	; 00002753H
	mov	DWORD PTR _gErrMsgs$[ebp+308], OFFSET $SG120302

; 242  :       WSAEUSERS,             "WSAEUSERS",

	mov	DWORD PTR _gErrMsgs$[ebp+312], 10068	; 00002754H
	mov	DWORD PTR _gErrMsgs$[ebp+316], OFFSET $SG120303

; 243  :       WSAEDQUOT,             "WSAEDQUOT",

	mov	DWORD PTR _gErrMsgs$[ebp+320], 10069	; 00002755H
	mov	DWORD PTR _gErrMsgs$[ebp+324], OFFSET $SG120304

; 244  :       WSAESTALE,             "WSAESTALE",

	mov	DWORD PTR _gErrMsgs$[ebp+328], 10070	; 00002756H
	mov	DWORD PTR _gErrMsgs$[ebp+332], OFFSET $SG120305

; 245  :       WSAEREMOTE,            "WSAEREMOTE",

	mov	DWORD PTR _gErrMsgs$[ebp+336], 10071	; 00002757H
	mov	DWORD PTR _gErrMsgs$[ebp+340], OFFSET $SG120306

; 246  :       WSASYSNOTREADY,        "WSASYSNOTREADY",

	mov	DWORD PTR _gErrMsgs$[ebp+344], 10091	; 0000276bH
	mov	DWORD PTR _gErrMsgs$[ebp+348], OFFSET $SG120307

; 247  :       WSAVERNOTSUPPORTED,    "WSAVERNOTSUPPORTED",

	mov	DWORD PTR _gErrMsgs$[ebp+352], 10092	; 0000276cH
	mov	DWORD PTR _gErrMsgs$[ebp+356], OFFSET $SG120308

; 248  :       WSANOTINITIALISED,     "WSANOTINITIALISED",

	mov	DWORD PTR _gErrMsgs$[ebp+360], 10093	; 0000276dH
	mov	DWORD PTR _gErrMsgs$[ebp+364], OFFSET $SG120309

; 249  :       0,                     0 };

	mov	DWORD PTR _gErrMsgs$[ebp+368], 0
	mov	DWORD PTR _gErrMsgs$[ebp+372], 0

; 250  : 
; 251  :    for ( k = 0; gErrMsgs[ k ].pchErrorMessage; k++ )

	mov	DWORD PTR _k$[ebp], 0
	jmp	SHORT $LN4@fnShowErro
$LN2@fnShowErro:
	mov	eax, DWORD PTR _k$[ebp]
	add	eax, 1
	mov	DWORD PTR _k$[ebp], eax
$LN4@fnShowErro:
	mov	ecx, DWORD PTR _k$[ebp]
	cmp	DWORD PTR _gErrMsgs$[ebp+ecx*8+4], 0
	je	SHORT $LN3@fnShowErro

; 252  :    {
; 253  :       if ( gErrMsgs[ k ].nErrorNbr == nErr )

	mov	edx, DWORD PTR _k$[ebp]
	mov	eax, DWORD PTR _gErrMsgs$[ebp+edx*8]
	cmp	eax, DWORD PTR _nErr$[ebp]
	jne	SHORT $LN5@fnShowErro

; 254  :          break;

	jmp	SHORT $LN3@fnShowErro
$LN5@fnShowErro:

; 255  :    }

	jmp	SHORT $LN2@fnShowErro
$LN3@fnShowErro:

; 256  : 
; 257  :    if ( gErrMsgs[ k ].pchErrorMessage )

	mov	ecx, DWORD PTR _k$[ebp]
	cmp	DWORD PTR _gErrMsgs$[ebp+ecx*8+4], 0
	je	SHORT $LN6@fnShowErro

; 258  :    {
; 259  :       wsprintf( szMsg, "(zwinsock) WinSock error Func = %s   %s %d",

	mov	edx, DWORD PTR _nErr$[ebp]
	push	edx
	mov	eax, DWORD PTR _k$[ebp]
	mov	ecx, DWORD PTR _gErrMsgs$[ebp+eax*8+4]
	push	ecx
	mov	edx, DWORD PTR _pchFuncName$[ebp]
	push	edx
	push	OFFSET $SG120313
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 20					; 00000014H

; 260  :                 pchFuncName, gErrMsgs[ k ].pchErrorMessage, nErr );
; 261  :    }
; 262  :    else

	jmp	SHORT $LN7@fnShowErro
$LN6@fnShowErro:

; 263  :    {
; 264  :       wsprintf( szMsg, "(zwinsock) Unknown WinSock error Func = %s   %d",

	mov	ecx, DWORD PTR _nErr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pchFuncName$[ebp]
	push	edx
	push	OFFSET $SG120314
	lea	eax, DWORD PTR _szMsg$[ebp]
	push	eax
	call	DWORD PTR __imp__wsprintfA
	add	esp, 16					; 00000010H
$LN7@fnShowErro:

; 265  :                 pchFuncName, nErr );
; 266  :    }
; 267  : 
; 268  :    TraceLineS( szMsg, "" );

	push	OFFSET $SG120315
	lea	ecx, DWORD PTR _szMsg$[ebp]
	push	ecx
	call	_TraceLineS@8

; 269  : 
; 270  : } // fnShowError

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?fnShowError@@YAXPAD@Z ENDP				; fnShowError
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);

	call	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
	lea	eax, DWORD PTR __Format$[ebp+4]
	mov	DWORD PTR __ArgList$[ebp], eax

; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);

	mov	ecx, DWORD PTR __ArgList$[ebp]
	push	ecx
	push	0
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsprintf_l
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Result$[ebp], eax

; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);

	mov	DWORD PTR __ArgList$[ebp], 0

; 1787 :     return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 1788 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	push	-1
	mov	eax, DWORD PTR __Buffer$[ebp]
	push	eax
	call	__vsnprintf_l
	add	esp, 20					; 00000014H

; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
tv74 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1386 :     int const _Result = __stdio_common_vsprintf(

	mov	eax, DWORD PTR __ArgList$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Locale$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Format$[ebp]
	push	edx
	mov	eax, DWORD PTR __BufferCount$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Buffer$[ebp]
	push	ecx
	call	___local_stdio_printf_options
	mov	edx, DWORD PTR [eax]
	or	edx, 1
	mov	eax, DWORD PTR [eax+4]
	push	eax
	push	edx
	call	DWORD PTR __imp____stdio_common_vsprintf
	add	esp, 28					; 0000001cH
	mov	DWORD PTR __Result$[ebp], eax

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	cmp	DWORD PTR __Result$[ebp], 0
	jge	SHORT $LN3@vsnprintf_
	mov	DWORD PTR tv74[ebp], -1
	jmp	SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
	mov	ecx, DWORD PTR __Result$[ebp]
	mov	DWORD PTR tv74[ebp], ecx
$LN4@vsnprintf_:
	mov	eax, DWORD PTR tv74[ebp]

; 1391 : }

	mov	esp, ebp
	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 144  :         {

	push	ebp
	mov	ebp, esp

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	pop	ebp
	ret	0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 73   : {

	push	ebp
	mov	ebp, esp

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	pop	ebp
	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\windows kits\10\include\10.0.10150.0\ucrt\string.h
;	COMDAT ?strchr@@YAPADQADH@Z
_TEXT	SEGMENT
__String$ = 8						; size = 4
__Ch$ = 12						; size = 4
?strchr@@YAPADQADH@Z PROC				; strchr, COMDAT

; 518  :     {

	push	ebp
	mov	ebp, esp

; 519  :         return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));

	mov	eax, DWORD PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR __String$[ebp]
	push	ecx
	call	DWORD PTR __imp__strchr
	add	esp, 8

; 520  :     }

	pop	ebp
	ret	0
?strchr@@YAPADQADH@Z ENDP				; strchr
_TEXT	ENDS
END
